Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 4     gotomain -> <empty>
Rule 5     program2 -> crear program2
Rule 6     program2 -> crear
Rule 7     program3 -> function program3
Rule 8     program3 -> function
Rule 9     llenarmain -> <empty>
Rule 10    crear -> var
Rule 11    crear -> vector
Rule 12    global -> <empty>
Rule 13    finglobal -> <empty>
Rule 14    main1 -> <empty>
Rule 15    finmain -> <empty>
Rule 16    var -> VAR tipo ID SEMICOLON
Rule 17    tipo -> INT
Rule 18    tipo -> FLOAT
Rule 19    tipo -> STRING
Rule 20    tipo -> BOOL
Rule 21    vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 22    vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
Rule 24    vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
Rule 25    initvector -> <empty>
Rule 26    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
Rule 27    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
Rule 28    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 29    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
Rule 30    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 31    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 32    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
Rule 33    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 34    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
Rule 35    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
Rule 36    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 37    functype -> INT
Rule 38    functype -> FLOAT
Rule 39    functype -> STRING
Rule 40    functype -> BOOL
Rule 41    pushvoid -> VOID
Rule 42    addInTable -> <empty>
Rule 43    funci -> INT ID sumparam
Rule 44    funci -> INT ID sumparam COMA funci
Rule 45    funci -> FLOAT ID sumparam
Rule 46    funci -> FLOAT ID sumparam COMA funci
Rule 47    funci -> STRING ID sumparam
Rule 48    funci -> STRING ID sumparam COMA funci
Rule 49    funci -> BOOL ID sumparam
Rule 50    funci -> BOOL ID sumparam COMA funci
Rule 51    funci -> empty
Rule 52    localvar -> var
Rule 53    localvar -> vector
Rule 54    localvar -> var localvar
Rule 55    localvar -> vector localvar
Rule 56    sumparam -> <empty>
Rule 57    return1 -> RETURN pushop expres resreturn SEMICOLON
Rule 58    return1 -> empty
Rule 59    resreturn -> <empty>
Rule 60    mainc -> LKEY RKEY
Rule 61    mainc -> LKEY bloq RKEY
Rule 62    mainc -> LKEY mainc2 bloq RKEY
Rule 63    mainc -> LKEY mainc2 RKEY
Rule 64    mainc2 -> var
Rule 65    mainc2 -> var mainc2
Rule 66    mainc2 -> vector
Rule 67    mainc2 -> vector mainc2
Rule 68    bloq -> estat
Rule 69    bloq -> estat bloq
Rule 70    estat -> asign
Rule 71    estat -> cond
Rule 72    estat -> escrit
Rule 73    estat -> ciclo
Rule 74    estat -> leer
Rule 75    estat -> fcallvoid
Rule 76    asign -> ID pushid EQUAL pushop fcall SEMICOLON
Rule 77    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 78    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
Rule 79    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 80    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 81    escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
Rule 82    escriti -> expres escrit1
Rule 83    escriti -> expres escrit2 COMA escriti
Rule 84    imprimirl -> <empty>
Rule 85    escrit1 -> <empty>
Rule 86    escrit2 -> <empty>
Rule 87    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 88    leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
Rule 89    readid -> <empty>
Rule 90    expres -> exr
Rule 91    expres -> exr log expres reslog
Rule 92    exr -> ex
Rule 93    exr -> ex rel exr resrel
Rule 94    reslog -> <empty>
Rule 95    ex -> term resterm
Rule 96    ex -> term resterm PLUS pushop ex
Rule 97    ex -> term resterm MINUS pushop ex
Rule 98    term -> fact resfact
Rule 99    term -> fact resfact TIMES pushop term
Rule 100   term -> fact resfact DIVIDE pushop term
Rule 101   fact -> LPAREN pushop expres RPAREN popop
Rule 102   fact -> var_cte
Rule 103   fact -> PLUS pushop var_cte
Rule 104   fact -> MINUS pushop var_cte
Rule 105   rel -> LOWERTHAN
Rule 106   rel -> MORETHAN
Rule 107   rel -> LOWEREQ
Rule 108   rel -> MOREEQ
Rule 109   rel -> SAME
Rule 110   rel -> DIFFERENT
Rule 111   log -> OR
Rule 112   log -> AND
Rule 113   var_cte -> ID pushid
Rule 114   var_cte -> CTE_I pushcte
Rule 115   var_cte -> CTE_F pushcte
Rule 116   var_cte -> CTE_S pushcte
Rule 117   var_cte -> TRUE pushcte
Rule 118   var_cte -> FALSE pushcte
Rule 119   var_cte -> asigvector
Rule 120   asigvector -> ID pushid LBRACE ex RBRACE
Rule 121   fcall -> ID existfunc LPAREN startera fcall1 RPAREN
Rule 122   fcall -> ID existfunc LPAREN startera RPAREN
Rule 123   fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 124   fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 125   existfunc -> <empty>
Rule 126   startera -> <empty>
Rule 127   fcall1 -> expres generateparam
Rule 128   fcall1 -> expres generateparam COMA fcall1
Rule 129   generateparam -> <empty>
Rule 130   empty -> <empty>
Rule 131   pushcte -> <empty>
Rule 132   pushid -> <empty>
Rule 133   pushop -> <empty>
Rule 134   popop -> <empty>
Rule 135   resolverasignacion -> <empty>
Rule 136   resasignvec -> <empty>
Rule 137   resfact -> <empty>
Rule 138   resterm -> <empty>
Rule 139   resrel -> <empty>
Rule 140   resif -> <empty>
Rule 141   reselse -> <empty>
Rule 142   finif -> <empty>
Rule 143   while1 -> <empty>
Rule 144   while2 -> <empty>
Rule 145   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 112
BOOL                 : 20 24 40 49 50
COLON                : 1 2 3
COMA                 : 44 46 48 50 83 128
CTE_F                : 115
CTE_I                : 21 22 23 24 114
CTE_S                : 116
DIFFERENT            : 110
DIVIDE               : 100
ELSE                 : 80
EQUAL                : 76 77 78
FALSE                : 118
FLOAT                : 18 22 38 45 46
FUNCTION             : 26 27 28 29 30 31 32 33 34 35 36
ID                   : 16 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 43 44 45 46 47 48 49 50 76 77 78 88 113 120 121 122 123 124
IF                   : 79 80
INT                  : 17 21 37 43 44
LBRACE               : 21 22 23 24 78 120
LKEY                 : 26 27 28 29 30 31 32 33 34 35 36 60 61 62 63 79 80 80 87
LOWEREQ              : 107
LOWERTHAN            : 105
LPAREN               : 26 27 28 29 30 31 32 33 34 35 36 79 80 81 87 88 101 121 122 123 124
MAIN                 : 1 2 3
MINUS                : 97 104
MOREEQ               : 108
MORETHAN             : 106
OR                   : 111
PLUS                 : 96 103
PRINT                : 81
PROGRAM              : 1 2 3
RBRACE               : 21 22 23 24 78 120
READ                 : 88
RETURN               : 57
RKEY                 : 26 27 28 29 30 31 32 33 34 35 36 60 61 62 63 79 80 80 87
RPAREN               : 26 27 28 29 30 31 32 33 34 35 36 79 80 81 87 88 101 121 122 123 124
SAME                 : 109
SEMICOLON            : 16 21 22 23 24 57 76 77 78 81 88 123 124
STRING               : 19 23 39 47 48
TIMES                : 99
TRUE                 : 117
VAR                  : 16
VECTOR               : 21 22 23 24
VOID                 : 41
WHILE                : 87
error                : 

Nonterminals, with rules where they appear

addInTable           : 26 27 28 29 30 31 32 33 34 35 36
asign                : 70
asigvector           : 119
bloq                 : 26 27 28 29 32 33 34 35 61 62 69 79 80 80 87
ciclo                : 73
cond                 : 71
crear                : 5 6
empty                : 51 58
escrit               : 72
escrit1              : 82
escrit2              : 83
escriti              : 81 83
estat                : 68 69
ex                   : 92 93 96 97 120
existfunc            : 121 122 123 124
expres               : 57 77 78 79 80 82 83 87 91 101 127 128
exr                  : 78 90 91 93
fact                 : 98 99 100
fcall                : 76
fcall1               : 121 123 128
fcallvoid            : 75
finglobal            : 1 2
finif                : 79 80
finmain              : 1 2 3
funci                : 26 27 28 29 44 46 48 50
function             : 7 8
functype             : 26 27 30 32 35 36
generateparam        : 127 128
global               : 1 2
gotomain             : 1 2 3
imprimirl            : 81
initvector           : 21 22 23 24
leer                 : 74
llenarmain           : 1 2 3
localvar             : 26 28 30 31 32 33 54 55
log                  : 91
main1                : 1 2 3
mainc                : 1 2 3
mainc2               : 62 63 65 67
popop                : 101
program              : 0
program2             : 1 2 5
program3             : 1 7
pushcte              : 114 115 116 117 118
pushid               : 76 77 78 88 113 120
pushop               : 57 76 77 78 81 88 96 97 99 100 101 103 104
pushvoid             : 28 29 31 33 34
readid               : 88 88
rel                  : 93
resasignvec          : 78
reselse              : 80
resfact              : 98 99 100
resif                : 79 80
reslog               : 91
resolverasignacion   : 77
resrel               : 93
resreturn            : 57
resterm              : 95 96 97
return1              : 26 27 32 35
startera             : 121 122 123 124
sumparam             : 43 44 45 46 47 48 49 50
term                 : 95 96 97 99 100
tipo                 : 16
var                  : 10 52 54 64 65
var_cte              : 102 103 104
vector               : 11 53 55 66 67
while1               : 87
while2               : 87
while3               : 87

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (4) gotomain -> .

    VAR             reduce using rule 4 (gotomain -> .)
    VECTOR          reduce using rule 4 (gotomain -> .)
    MAIN            reduce using rule 4 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (12) global -> .
    (9) llenarmain -> .

    VAR             reduce using rule 12 (global -> .)
    VECTOR          reduce using rule 12 (global -> .)
    MAIN            reduce using rule 9 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    program2                       shift and go to state 7
    crear                          shift and go to state 8
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 6

    (3) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 13


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (13) finglobal -> .

    FUNCTION        reduce using rule 13 (finglobal -> .)
    MAIN            reduce using rule 13 (finglobal -> .)

    finglobal                      shift and go to state 14

state 8

    (5) program2 -> crear . program2
    (6) program2 -> crear .
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 6 (program2 -> crear .)
    MAIN            reduce using rule 6 (program2 -> crear .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    crear                          shift and go to state 8
    program2                       shift and go to state 15
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 9

    (10) crear -> var .

    VAR             reduce using rule 10 (crear -> var .)
    VECTOR          reduce using rule 10 (crear -> var .)
    FUNCTION        reduce using rule 10 (crear -> var .)
    MAIN            reduce using rule 10 (crear -> var .)


state 10

    (11) crear -> vector .

    VAR             reduce using rule 11 (crear -> vector .)
    VECTOR          reduce using rule 11 (crear -> vector .)
    FUNCTION        reduce using rule 11 (crear -> vector .)
    MAIN            reduce using rule 11 (crear -> vector .)


state 11

    (16) var -> VAR . tipo ID SEMICOLON
    (17) tipo -> . INT
    (18) tipo -> . FLOAT
    (19) tipo -> . STRING
    (20) tipo -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    BOOL            shift and go to state 20

    tipo                           shift and go to state 16

state 12

    (21) vector -> VECTOR . initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR . initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR . initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR . initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (25) initvector -> .

    INT             reduce using rule 25 (initvector -> .)
    FLOAT           reduce using rule 25 (initvector -> .)
    STRING          reduce using rule 25 (initvector -> .)
    BOOL            reduce using rule 25 (initvector -> .)

    initvector                     shift and go to state 21

state 13

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 22

state 14

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (7) program3 -> . function program3
    (8) program3 -> . function
    (9) llenarmain -> .
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (llenarmain -> .)
    FUNCTION        shift and go to state 26

    program3                       shift and go to state 23
    llenarmain                     shift and go to state 24
    function                       shift and go to state 25

state 15

    (5) program2 -> crear program2 .

    FUNCTION        reduce using rule 5 (program2 -> crear program2 .)
    MAIN            reduce using rule 5 (program2 -> crear program2 .)


state 16

    (16) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 27


state 17

    (17) tipo -> INT .

    ID              reduce using rule 17 (tipo -> INT .)


state 18

    (18) tipo -> FLOAT .

    ID              reduce using rule 18 (tipo -> FLOAT .)


state 19

    (19) tipo -> STRING .

    ID              reduce using rule 19 (tipo -> STRING .)


state 20

    (20) tipo -> BOOL .

    ID              reduce using rule 20 (tipo -> BOOL .)


state 21

    (21) vector -> VECTOR initvector . INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR initvector . FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR initvector . STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR initvector . BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31


state 22

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 32

state 23

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (9) llenarmain -> .

    MAIN            reduce using rule 9 (llenarmain -> .)

    llenarmain                     shift and go to state 34

state 24

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 35


state 25

    (7) program3 -> function . program3
    (8) program3 -> function .
    (7) program3 -> . function program3
    (8) program3 -> . function
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 8 (program3 -> function .)
    FUNCTION        shift and go to state 26

    function                       shift and go to state 25
    program3                       shift and go to state 36

state 26

    (26) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (37) functype -> . INT
    (38) functype -> . FLOAT
    (39) functype -> . STRING
    (40) functype -> . BOOL
    (41) pushvoid -> . VOID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STRING          shift and go to state 41
    BOOL            shift and go to state 42
    VOID            shift and go to state 43

    functype                       shift and go to state 37
    pushvoid                       shift and go to state 38

state 27

    (16) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 44


state 28

    (21) vector -> VECTOR initvector INT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 45


state 29

    (22) vector -> VECTOR initvector FLOAT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 46


state 30

    (23) vector -> VECTOR initvector STRING . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 47


state 31

    (24) vector -> VECTOR initvector BOOL . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 48


state 32

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 49

state 33

    (60) mainc -> LKEY . RKEY
    (61) mainc -> LKEY . bloq RKEY
    (62) mainc -> LKEY . mainc2 bloq RKEY
    (63) mainc -> LKEY . mainc2 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 50
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 51
    mainc2                         shift and go to state 52
    estat                          shift and go to state 53
    var                            shift and go to state 54
    vector                         shift and go to state 55
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 34

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 67


state 35

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 68

state 36

    (7) program3 -> function program3 .

    MAIN            reduce using rule 7 (program3 -> function program3 .)


state 37

    (26) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 69


state 38

    (28) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY bloq RKEY

    ID              shift and go to state 70


state 39

    (37) functype -> INT .

    ID              reduce using rule 37 (functype -> INT .)


state 40

    (38) functype -> FLOAT .

    ID              reduce using rule 38 (functype -> FLOAT .)


state 41

    (39) functype -> STRING .

    ID              reduce using rule 39 (functype -> STRING .)


state 42

    (40) functype -> BOOL .

    ID              reduce using rule 40 (functype -> BOOL .)


state 43

    (41) pushvoid -> VOID .

    ID              reduce using rule 41 (pushvoid -> VOID .)


state 44

    (16) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)


state 45

    (21) vector -> VECTOR initvector INT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 71


state 46

    (22) vector -> VECTOR initvector FLOAT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 72


state 47

    (23) vector -> VECTOR initvector STRING ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 73


state 48

    (24) vector -> VECTOR initvector BOOL ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 74


state 49

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 50

    (60) mainc -> LKEY RKEY .

    $end            reduce using rule 60 (mainc -> LKEY RKEY .)


state 51

    (61) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 75


state 52

    (62) mainc -> LKEY mainc2 . bloq RKEY
    (63) mainc -> LKEY mainc2 . RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 77
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 76
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 53

    (68) bloq -> estat .
    (69) bloq -> estat . bloq
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            reduce using rule 68 (bloq -> estat .)
    RETURN          reduce using rule 68 (bloq -> estat .)
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    estat                          shift and go to state 53
    bloq                           shift and go to state 78
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 54

    (64) mainc2 -> var .
    (65) mainc2 -> var . mainc2
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 64 (mainc2 -> var .)
    ID              reduce using rule 64 (mainc2 -> var .)
    IF              reduce using rule 64 (mainc2 -> var .)
    PRINT           reduce using rule 64 (mainc2 -> var .)
    WHILE           reduce using rule 64 (mainc2 -> var .)
    READ            reduce using rule 64 (mainc2 -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 54
    mainc2                         shift and go to state 79
    vector                         shift and go to state 55

state 55

    (66) mainc2 -> vector .
    (67) mainc2 -> vector . mainc2
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 66 (mainc2 -> vector .)
    ID              reduce using rule 66 (mainc2 -> vector .)
    IF              reduce using rule 66 (mainc2 -> vector .)
    PRINT           reduce using rule 66 (mainc2 -> vector .)
    WHILE           reduce using rule 66 (mainc2 -> vector .)
    READ            reduce using rule 66 (mainc2 -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 55
    mainc2                         shift and go to state 80
    var                            shift and go to state 54

state 56

    (70) estat -> asign .

    ID              reduce using rule 70 (estat -> asign .)
    IF              reduce using rule 70 (estat -> asign .)
    PRINT           reduce using rule 70 (estat -> asign .)
    WHILE           reduce using rule 70 (estat -> asign .)
    READ            reduce using rule 70 (estat -> asign .)
    RKEY            reduce using rule 70 (estat -> asign .)
    RETURN          reduce using rule 70 (estat -> asign .)


state 57

    (71) estat -> cond .

    ID              reduce using rule 71 (estat -> cond .)
    IF              reduce using rule 71 (estat -> cond .)
    PRINT           reduce using rule 71 (estat -> cond .)
    WHILE           reduce using rule 71 (estat -> cond .)
    READ            reduce using rule 71 (estat -> cond .)
    RKEY            reduce using rule 71 (estat -> cond .)
    RETURN          reduce using rule 71 (estat -> cond .)


state 58

    (72) estat -> escrit .

    ID              reduce using rule 72 (estat -> escrit .)
    IF              reduce using rule 72 (estat -> escrit .)
    PRINT           reduce using rule 72 (estat -> escrit .)
    WHILE           reduce using rule 72 (estat -> escrit .)
    READ            reduce using rule 72 (estat -> escrit .)
    RKEY            reduce using rule 72 (estat -> escrit .)
    RETURN          reduce using rule 72 (estat -> escrit .)


state 59

    (73) estat -> ciclo .

    ID              reduce using rule 73 (estat -> ciclo .)
    IF              reduce using rule 73 (estat -> ciclo .)
    PRINT           reduce using rule 73 (estat -> ciclo .)
    WHILE           reduce using rule 73 (estat -> ciclo .)
    READ            reduce using rule 73 (estat -> ciclo .)
    RKEY            reduce using rule 73 (estat -> ciclo .)
    RETURN          reduce using rule 73 (estat -> ciclo .)


state 60

    (74) estat -> leer .

    ID              reduce using rule 74 (estat -> leer .)
    IF              reduce using rule 74 (estat -> leer .)
    PRINT           reduce using rule 74 (estat -> leer .)
    WHILE           reduce using rule 74 (estat -> leer .)
    READ            reduce using rule 74 (estat -> leer .)
    RKEY            reduce using rule 74 (estat -> leer .)
    RETURN          reduce using rule 74 (estat -> leer .)


state 61

    (75) estat -> fcallvoid .

    ID              reduce using rule 75 (estat -> fcallvoid .)
    IF              reduce using rule 75 (estat -> fcallvoid .)
    PRINT           reduce using rule 75 (estat -> fcallvoid .)
    WHILE           reduce using rule 75 (estat -> fcallvoid .)
    READ            reduce using rule 75 (estat -> fcallvoid .)
    RKEY            reduce using rule 75 (estat -> fcallvoid .)
    RETURN          reduce using rule 75 (estat -> fcallvoid .)


state 62

    (76) asign -> ID . pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (123) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (132) pushid -> .
    (125) existfunc -> .

    EQUAL           reduce using rule 132 (pushid -> .)
    LBRACE          reduce using rule 132 (pushid -> .)
    LPAREN          reduce using rule 125 (existfunc -> .)

    pushid                         shift and go to state 81
    existfunc                      shift and go to state 82

state 63

    (79) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 83


state 64

    (81) escrit -> PRINT . pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 84

state 65

    (87) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (143) while1 -> .

    LPAREN          reduce using rule 143 (while1 -> .)

    while1                         shift and go to state 85

state 66

    (88) leer -> READ . pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 86

state 67

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 87

state 68

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 88

state 69

    (26) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (42) addInTable -> .

    LPAREN          reduce using rule 42 (addInTable -> .)

    addInTable                     shift and go to state 89

state 70

    (28) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY bloq RKEY
    (42) addInTable -> .

    LPAREN          reduce using rule 42 (addInTable -> .)

    addInTable                     shift and go to state 90

state 71

    (21) vector -> VECTOR initvector INT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 91


state 72

    (22) vector -> VECTOR initvector FLOAT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 92


state 73

    (23) vector -> VECTOR initvector STRING ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 93


state 74

    (24) vector -> VECTOR initvector BOOL ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 94


state 75

    (61) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 61 (mainc -> LKEY bloq RKEY .)


state 76

    (62) mainc -> LKEY mainc2 bloq . RKEY

    RKEY            shift and go to state 95


state 77

    (63) mainc -> LKEY mainc2 RKEY .

    $end            reduce using rule 63 (mainc -> LKEY mainc2 RKEY .)


state 78

    (69) bloq -> estat bloq .

    RKEY            reduce using rule 69 (bloq -> estat bloq .)
    RETURN          reduce using rule 69 (bloq -> estat bloq .)


state 79

    (65) mainc2 -> var mainc2 .

    RKEY            reduce using rule 65 (mainc2 -> var mainc2 .)
    ID              reduce using rule 65 (mainc2 -> var mainc2 .)
    IF              reduce using rule 65 (mainc2 -> var mainc2 .)
    PRINT           reduce using rule 65 (mainc2 -> var mainc2 .)
    WHILE           reduce using rule 65 (mainc2 -> var mainc2 .)
    READ            reduce using rule 65 (mainc2 -> var mainc2 .)


state 80

    (67) mainc2 -> vector mainc2 .

    RKEY            reduce using rule 67 (mainc2 -> vector mainc2 .)
    ID              reduce using rule 67 (mainc2 -> vector mainc2 .)
    IF              reduce using rule 67 (mainc2 -> vector mainc2 .)
    PRINT           reduce using rule 67 (mainc2 -> vector mainc2 .)
    WHILE           reduce using rule 67 (mainc2 -> vector mainc2 .)
    READ            reduce using rule 67 (mainc2 -> vector mainc2 .)


state 81

    (76) asign -> ID pushid . EQUAL pushop fcall SEMICOLON
    (77) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON

    EQUAL           shift and go to state 96
    LBRACE          shift and go to state 97


state 82

    (123) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 98


state 83

    (79) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 100
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 84

    (81) escrit -> PRINT pushop . LPAREN imprimirl escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 115


state 85

    (87) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 116


state 86

    (88) leer -> READ pushop . LPAREN ID pushid readid RPAREN readid SEMICOLON

    LPAREN          shift and go to state 117


state 87

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 118

state 88

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 119

state 89

    (26) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 120


state 90

    (28) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY bloq RKEY

    LPAREN          shift and go to state 121


state 91

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 122


state 92

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 123


state 93

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 124


state 94

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 125


state 95

    (62) mainc -> LKEY mainc2 bloq RKEY .

    $end            reduce using rule 62 (mainc -> LKEY mainc2 bloq RKEY .)


state 96

    (76) asign -> ID pushid EQUAL . pushop fcall SEMICOLON
    (77) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (133) pushop -> .

    ID              reduce using rule 133 (pushop -> .)
    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 126

state 97

    (78) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 127
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 98

    (123) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (126) startera -> .

    RPAREN          reduce using rule 126 (startera -> .)
    LPAREN          reduce using rule 126 (startera -> .)
    PLUS            reduce using rule 126 (startera -> .)
    MINUS           reduce using rule 126 (startera -> .)
    ID              reduce using rule 126 (startera -> .)
    CTE_I           reduce using rule 126 (startera -> .)
    CTE_F           reduce using rule 126 (startera -> .)
    CTE_S           reduce using rule 126 (startera -> .)
    TRUE            reduce using rule 126 (startera -> .)
    FALSE           reduce using rule 126 (startera -> .)

    startera                       shift and go to state 128

state 99

    (101) fact -> LPAREN . pushop expres RPAREN popop
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 129

state 100

    (79) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 130


state 101

    (90) expres -> exr .
    (91) expres -> exr . log expres reslog
    (111) log -> . OR
    (112) log -> . AND

    RPAREN          reduce using rule 90 (expres -> exr .)
    SEMICOLON       reduce using rule 90 (expres -> exr .)
    COMA            reduce using rule 90 (expres -> exr .)
    OR              shift and go to state 132
    AND             shift and go to state 133

    log                            shift and go to state 131

state 102

    (92) exr -> ex .
    (93) exr -> ex . rel exr resrel
    (105) rel -> . LOWERTHAN
    (106) rel -> . MORETHAN
    (107) rel -> . LOWEREQ
    (108) rel -> . MOREEQ
    (109) rel -> . SAME
    (110) rel -> . DIFFERENT

    OR              reduce using rule 92 (exr -> ex .)
    AND             reduce using rule 92 (exr -> ex .)
    RPAREN          reduce using rule 92 (exr -> ex .)
    RBRACE          reduce using rule 92 (exr -> ex .)
    SEMICOLON       reduce using rule 92 (exr -> ex .)
    COMA            reduce using rule 92 (exr -> ex .)
    LOWERTHAN       shift and go to state 135
    MORETHAN        shift and go to state 136
    LOWEREQ         shift and go to state 137
    MOREEQ          shift and go to state 138
    SAME            shift and go to state 139
    DIFFERENT       shift and go to state 140

    rel                            shift and go to state 134

state 103

    (95) ex -> term . resterm
    (96) ex -> term . resterm PLUS pushop ex
    (97) ex -> term . resterm MINUS pushop ex
    (138) resterm -> .

    PLUS            reduce using rule 138 (resterm -> .)
    MINUS           reduce using rule 138 (resterm -> .)
    LOWERTHAN       reduce using rule 138 (resterm -> .)
    MORETHAN        reduce using rule 138 (resterm -> .)
    LOWEREQ         reduce using rule 138 (resterm -> .)
    MOREEQ          reduce using rule 138 (resterm -> .)
    SAME            reduce using rule 138 (resterm -> .)
    DIFFERENT       reduce using rule 138 (resterm -> .)
    OR              reduce using rule 138 (resterm -> .)
    AND             reduce using rule 138 (resterm -> .)
    RPAREN          reduce using rule 138 (resterm -> .)
    RBRACE          reduce using rule 138 (resterm -> .)
    SEMICOLON       reduce using rule 138 (resterm -> .)
    COMA            reduce using rule 138 (resterm -> .)

    resterm                        shift and go to state 141

state 104

    (103) fact -> PLUS . pushop var_cte
    (133) pushop -> .

    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 142

state 105

    (104) fact -> MINUS . pushop var_cte
    (133) pushop -> .

    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 143

state 106

    (98) term -> fact . resfact
    (99) term -> fact . resfact TIMES pushop term
    (100) term -> fact . resfact DIVIDE pushop term
    (137) resfact -> .

    TIMES           reduce using rule 137 (resfact -> .)
    DIVIDE          reduce using rule 137 (resfact -> .)
    PLUS            reduce using rule 137 (resfact -> .)
    MINUS           reduce using rule 137 (resfact -> .)
    LOWERTHAN       reduce using rule 137 (resfact -> .)
    MORETHAN        reduce using rule 137 (resfact -> .)
    LOWEREQ         reduce using rule 137 (resfact -> .)
    MOREEQ          reduce using rule 137 (resfact -> .)
    SAME            reduce using rule 137 (resfact -> .)
    DIFFERENT       reduce using rule 137 (resfact -> .)
    OR              reduce using rule 137 (resfact -> .)
    AND             reduce using rule 137 (resfact -> .)
    RPAREN          reduce using rule 137 (resfact -> .)
    RBRACE          reduce using rule 137 (resfact -> .)
    SEMICOLON       reduce using rule 137 (resfact -> .)
    COMA            reduce using rule 137 (resfact -> .)

    resfact                        shift and go to state 144

state 107

    (102) fact -> var_cte .

    TIMES           reduce using rule 102 (fact -> var_cte .)
    DIVIDE          reduce using rule 102 (fact -> var_cte .)
    PLUS            reduce using rule 102 (fact -> var_cte .)
    MINUS           reduce using rule 102 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 102 (fact -> var_cte .)
    MORETHAN        reduce using rule 102 (fact -> var_cte .)
    LOWEREQ         reduce using rule 102 (fact -> var_cte .)
    MOREEQ          reduce using rule 102 (fact -> var_cte .)
    SAME            reduce using rule 102 (fact -> var_cte .)
    DIFFERENT       reduce using rule 102 (fact -> var_cte .)
    OR              reduce using rule 102 (fact -> var_cte .)
    AND             reduce using rule 102 (fact -> var_cte .)
    RPAREN          reduce using rule 102 (fact -> var_cte .)
    RBRACE          reduce using rule 102 (fact -> var_cte .)
    SEMICOLON       reduce using rule 102 (fact -> var_cte .)
    COMA            reduce using rule 102 (fact -> var_cte .)


state 108

    (113) var_cte -> ID . pushid
    (120) asigvector -> ID . pushid LBRACE ex RBRACE
    (132) pushid -> .

    LBRACE          reduce using rule 132 (pushid -> .)
    TIMES           reduce using rule 132 (pushid -> .)
    DIVIDE          reduce using rule 132 (pushid -> .)
    PLUS            reduce using rule 132 (pushid -> .)
    MINUS           reduce using rule 132 (pushid -> .)
    LOWERTHAN       reduce using rule 132 (pushid -> .)
    MORETHAN        reduce using rule 132 (pushid -> .)
    LOWEREQ         reduce using rule 132 (pushid -> .)
    MOREEQ          reduce using rule 132 (pushid -> .)
    SAME            reduce using rule 132 (pushid -> .)
    DIFFERENT       reduce using rule 132 (pushid -> .)
    OR              reduce using rule 132 (pushid -> .)
    AND             reduce using rule 132 (pushid -> .)
    RPAREN          reduce using rule 132 (pushid -> .)
    RBRACE          reduce using rule 132 (pushid -> .)
    COMA            reduce using rule 132 (pushid -> .)
    SEMICOLON       reduce using rule 132 (pushid -> .)

    pushid                         shift and go to state 145

state 109

    (114) var_cte -> CTE_I . pushcte
    (131) pushcte -> .

    TIMES           reduce using rule 131 (pushcte -> .)
    DIVIDE          reduce using rule 131 (pushcte -> .)
    PLUS            reduce using rule 131 (pushcte -> .)
    MINUS           reduce using rule 131 (pushcte -> .)
    LOWERTHAN       reduce using rule 131 (pushcte -> .)
    MORETHAN        reduce using rule 131 (pushcte -> .)
    LOWEREQ         reduce using rule 131 (pushcte -> .)
    MOREEQ          reduce using rule 131 (pushcte -> .)
    SAME            reduce using rule 131 (pushcte -> .)
    DIFFERENT       reduce using rule 131 (pushcte -> .)
    OR              reduce using rule 131 (pushcte -> .)
    AND             reduce using rule 131 (pushcte -> .)
    RPAREN          reduce using rule 131 (pushcte -> .)
    RBRACE          reduce using rule 131 (pushcte -> .)
    SEMICOLON       reduce using rule 131 (pushcte -> .)
    COMA            reduce using rule 131 (pushcte -> .)

    pushcte                        shift and go to state 146

state 110

    (115) var_cte -> CTE_F . pushcte
    (131) pushcte -> .

    TIMES           reduce using rule 131 (pushcte -> .)
    DIVIDE          reduce using rule 131 (pushcte -> .)
    PLUS            reduce using rule 131 (pushcte -> .)
    MINUS           reduce using rule 131 (pushcte -> .)
    LOWERTHAN       reduce using rule 131 (pushcte -> .)
    MORETHAN        reduce using rule 131 (pushcte -> .)
    LOWEREQ         reduce using rule 131 (pushcte -> .)
    MOREEQ          reduce using rule 131 (pushcte -> .)
    SAME            reduce using rule 131 (pushcte -> .)
    DIFFERENT       reduce using rule 131 (pushcte -> .)
    OR              reduce using rule 131 (pushcte -> .)
    AND             reduce using rule 131 (pushcte -> .)
    RPAREN          reduce using rule 131 (pushcte -> .)
    RBRACE          reduce using rule 131 (pushcte -> .)
    SEMICOLON       reduce using rule 131 (pushcte -> .)
    COMA            reduce using rule 131 (pushcte -> .)

    pushcte                        shift and go to state 147

state 111

    (116) var_cte -> CTE_S . pushcte
    (131) pushcte -> .

    TIMES           reduce using rule 131 (pushcte -> .)
    DIVIDE          reduce using rule 131 (pushcte -> .)
    PLUS            reduce using rule 131 (pushcte -> .)
    MINUS           reduce using rule 131 (pushcte -> .)
    LOWERTHAN       reduce using rule 131 (pushcte -> .)
    MORETHAN        reduce using rule 131 (pushcte -> .)
    LOWEREQ         reduce using rule 131 (pushcte -> .)
    MOREEQ          reduce using rule 131 (pushcte -> .)
    SAME            reduce using rule 131 (pushcte -> .)
    DIFFERENT       reduce using rule 131 (pushcte -> .)
    OR              reduce using rule 131 (pushcte -> .)
    AND             reduce using rule 131 (pushcte -> .)
    RPAREN          reduce using rule 131 (pushcte -> .)
    RBRACE          reduce using rule 131 (pushcte -> .)
    SEMICOLON       reduce using rule 131 (pushcte -> .)
    COMA            reduce using rule 131 (pushcte -> .)

    pushcte                        shift and go to state 148

state 112

    (117) var_cte -> TRUE . pushcte
    (131) pushcte -> .

    TIMES           reduce using rule 131 (pushcte -> .)
    DIVIDE          reduce using rule 131 (pushcte -> .)
    PLUS            reduce using rule 131 (pushcte -> .)
    MINUS           reduce using rule 131 (pushcte -> .)
    LOWERTHAN       reduce using rule 131 (pushcte -> .)
    MORETHAN        reduce using rule 131 (pushcte -> .)
    LOWEREQ         reduce using rule 131 (pushcte -> .)
    MOREEQ          reduce using rule 131 (pushcte -> .)
    SAME            reduce using rule 131 (pushcte -> .)
    DIFFERENT       reduce using rule 131 (pushcte -> .)
    OR              reduce using rule 131 (pushcte -> .)
    AND             reduce using rule 131 (pushcte -> .)
    RPAREN          reduce using rule 131 (pushcte -> .)
    RBRACE          reduce using rule 131 (pushcte -> .)
    SEMICOLON       reduce using rule 131 (pushcte -> .)
    COMA            reduce using rule 131 (pushcte -> .)

    pushcte                        shift and go to state 149

state 113

    (118) var_cte -> FALSE . pushcte
    (131) pushcte -> .

    TIMES           reduce using rule 131 (pushcte -> .)
    DIVIDE          reduce using rule 131 (pushcte -> .)
    PLUS            reduce using rule 131 (pushcte -> .)
    MINUS           reduce using rule 131 (pushcte -> .)
    LOWERTHAN       reduce using rule 131 (pushcte -> .)
    MORETHAN        reduce using rule 131 (pushcte -> .)
    LOWEREQ         reduce using rule 131 (pushcte -> .)
    MOREEQ          reduce using rule 131 (pushcte -> .)
    SAME            reduce using rule 131 (pushcte -> .)
    DIFFERENT       reduce using rule 131 (pushcte -> .)
    OR              reduce using rule 131 (pushcte -> .)
    AND             reduce using rule 131 (pushcte -> .)
    RPAREN          reduce using rule 131 (pushcte -> .)
    RBRACE          reduce using rule 131 (pushcte -> .)
    SEMICOLON       reduce using rule 131 (pushcte -> .)
    COMA            reduce using rule 131 (pushcte -> .)

    pushcte                        shift and go to state 150

state 114

    (119) var_cte -> asigvector .

    TIMES           reduce using rule 119 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 119 (var_cte -> asigvector .)
    PLUS            reduce using rule 119 (var_cte -> asigvector .)
    MINUS           reduce using rule 119 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 119 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 119 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 119 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 119 (var_cte -> asigvector .)
    SAME            reduce using rule 119 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 119 (var_cte -> asigvector .)
    OR              reduce using rule 119 (var_cte -> asigvector .)
    AND             reduce using rule 119 (var_cte -> asigvector .)
    RPAREN          reduce using rule 119 (var_cte -> asigvector .)
    RBRACE          reduce using rule 119 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 119 (var_cte -> asigvector .)
    COMA            reduce using rule 119 (var_cte -> asigvector .)


state 115

    (81) escrit -> PRINT pushop LPAREN . imprimirl escriti RPAREN SEMICOLON
    (84) imprimirl -> .

    LPAREN          reduce using rule 84 (imprimirl -> .)
    PLUS            reduce using rule 84 (imprimirl -> .)
    MINUS           reduce using rule 84 (imprimirl -> .)
    ID              reduce using rule 84 (imprimirl -> .)
    CTE_I           reduce using rule 84 (imprimirl -> .)
    CTE_F           reduce using rule 84 (imprimirl -> .)
    CTE_S           reduce using rule 84 (imprimirl -> .)
    TRUE            reduce using rule 84 (imprimirl -> .)
    FALSE           reduce using rule 84 (imprimirl -> .)

    imprimirl                      shift and go to state 151

state 116

    (87) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 152
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 117

    (88) leer -> READ pushop LPAREN . ID pushid readid RPAREN readid SEMICOLON

    ID              shift and go to state 153


state 118

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 154

state 119

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 120

    (26) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 156
    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160

  ! RPAREN          [ reduce using rule 130 (empty -> .) ]

    funci                          shift and go to state 155
    empty                          shift and go to state 161

state 121

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY bloq RKEY
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 163
    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160

  ! RPAREN          [ reduce using rule 130 (empty -> .) ]

    funci                          shift and go to state 162
    empty                          shift and go to state 161

state 122

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 164


state 123

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 165


state 124

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 166


state 125

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 167


state 126

    (76) asign -> ID pushid EQUAL pushop . fcall SEMICOLON
    (77) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN
    (122) fcall -> . ID existfunc LPAREN startera RPAREN
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 168
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall                          shift and go to state 169
    expres                         shift and go to state 170
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 127

    (78) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres resasignvec SEMICOLON

    RBRACE          shift and go to state 171


state 128

    (123) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 173
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 172
    expres                         shift and go to state 174
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 129

    (101) fact -> LPAREN pushop . expres RPAREN popop
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 175
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 130

    (79) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 176


state 131

    (91) expres -> exr log . expres reslog
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 177
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 132

    (111) log -> OR .

    LPAREN          reduce using rule 111 (log -> OR .)
    PLUS            reduce using rule 111 (log -> OR .)
    MINUS           reduce using rule 111 (log -> OR .)
    ID              reduce using rule 111 (log -> OR .)
    CTE_I           reduce using rule 111 (log -> OR .)
    CTE_F           reduce using rule 111 (log -> OR .)
    CTE_S           reduce using rule 111 (log -> OR .)
    TRUE            reduce using rule 111 (log -> OR .)
    FALSE           reduce using rule 111 (log -> OR .)


state 133

    (112) log -> AND .

    LPAREN          reduce using rule 112 (log -> AND .)
    PLUS            reduce using rule 112 (log -> AND .)
    MINUS           reduce using rule 112 (log -> AND .)
    ID              reduce using rule 112 (log -> AND .)
    CTE_I           reduce using rule 112 (log -> AND .)
    CTE_F           reduce using rule 112 (log -> AND .)
    CTE_S           reduce using rule 112 (log -> AND .)
    TRUE            reduce using rule 112 (log -> AND .)
    FALSE           reduce using rule 112 (log -> AND .)


state 134

    (93) exr -> ex rel . exr resrel
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 102
    exr                            shift and go to state 178
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 135

    (105) rel -> LOWERTHAN .

    LPAREN          reduce using rule 105 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 105 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 105 (rel -> LOWERTHAN .)
    ID              reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 105 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 105 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 105 (rel -> LOWERTHAN .)


state 136

    (106) rel -> MORETHAN .

    LPAREN          reduce using rule 106 (rel -> MORETHAN .)
    PLUS            reduce using rule 106 (rel -> MORETHAN .)
    MINUS           reduce using rule 106 (rel -> MORETHAN .)
    ID              reduce using rule 106 (rel -> MORETHAN .)
    CTE_I           reduce using rule 106 (rel -> MORETHAN .)
    CTE_F           reduce using rule 106 (rel -> MORETHAN .)
    CTE_S           reduce using rule 106 (rel -> MORETHAN .)
    TRUE            reduce using rule 106 (rel -> MORETHAN .)
    FALSE           reduce using rule 106 (rel -> MORETHAN .)


state 137

    (107) rel -> LOWEREQ .

    LPAREN          reduce using rule 107 (rel -> LOWEREQ .)
    PLUS            reduce using rule 107 (rel -> LOWEREQ .)
    MINUS           reduce using rule 107 (rel -> LOWEREQ .)
    ID              reduce using rule 107 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 107 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 107 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 107 (rel -> LOWEREQ .)
    TRUE            reduce using rule 107 (rel -> LOWEREQ .)
    FALSE           reduce using rule 107 (rel -> LOWEREQ .)


state 138

    (108) rel -> MOREEQ .

    LPAREN          reduce using rule 108 (rel -> MOREEQ .)
    PLUS            reduce using rule 108 (rel -> MOREEQ .)
    MINUS           reduce using rule 108 (rel -> MOREEQ .)
    ID              reduce using rule 108 (rel -> MOREEQ .)
    CTE_I           reduce using rule 108 (rel -> MOREEQ .)
    CTE_F           reduce using rule 108 (rel -> MOREEQ .)
    CTE_S           reduce using rule 108 (rel -> MOREEQ .)
    TRUE            reduce using rule 108 (rel -> MOREEQ .)
    FALSE           reduce using rule 108 (rel -> MOREEQ .)


state 139

    (109) rel -> SAME .

    LPAREN          reduce using rule 109 (rel -> SAME .)
    PLUS            reduce using rule 109 (rel -> SAME .)
    MINUS           reduce using rule 109 (rel -> SAME .)
    ID              reduce using rule 109 (rel -> SAME .)
    CTE_I           reduce using rule 109 (rel -> SAME .)
    CTE_F           reduce using rule 109 (rel -> SAME .)
    CTE_S           reduce using rule 109 (rel -> SAME .)
    TRUE            reduce using rule 109 (rel -> SAME .)
    FALSE           reduce using rule 109 (rel -> SAME .)


state 140

    (110) rel -> DIFFERENT .

    LPAREN          reduce using rule 110 (rel -> DIFFERENT .)
    PLUS            reduce using rule 110 (rel -> DIFFERENT .)
    MINUS           reduce using rule 110 (rel -> DIFFERENT .)
    ID              reduce using rule 110 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 110 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 110 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 110 (rel -> DIFFERENT .)
    TRUE            reduce using rule 110 (rel -> DIFFERENT .)
    FALSE           reduce using rule 110 (rel -> DIFFERENT .)


state 141

    (95) ex -> term resterm .
    (96) ex -> term resterm . PLUS pushop ex
    (97) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 95 (ex -> term resterm .)
    MORETHAN        reduce using rule 95 (ex -> term resterm .)
    LOWEREQ         reduce using rule 95 (ex -> term resterm .)
    MOREEQ          reduce using rule 95 (ex -> term resterm .)
    SAME            reduce using rule 95 (ex -> term resterm .)
    DIFFERENT       reduce using rule 95 (ex -> term resterm .)
    OR              reduce using rule 95 (ex -> term resterm .)
    AND             reduce using rule 95 (ex -> term resterm .)
    RPAREN          reduce using rule 95 (ex -> term resterm .)
    RBRACE          reduce using rule 95 (ex -> term resterm .)
    SEMICOLON       reduce using rule 95 (ex -> term resterm .)
    COMA            reduce using rule 95 (ex -> term resterm .)
    PLUS            shift and go to state 179
    MINUS           shift and go to state 180


state 142

    (103) fact -> PLUS pushop . var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 181
    asigvector                     shift and go to state 114

state 143

    (104) fact -> MINUS pushop . var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 182
    asigvector                     shift and go to state 114

state 144

    (98) term -> fact resfact .
    (99) term -> fact resfact . TIMES pushop term
    (100) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 98 (term -> fact resfact .)
    MINUS           reduce using rule 98 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 98 (term -> fact resfact .)
    MORETHAN        reduce using rule 98 (term -> fact resfact .)
    LOWEREQ         reduce using rule 98 (term -> fact resfact .)
    MOREEQ          reduce using rule 98 (term -> fact resfact .)
    SAME            reduce using rule 98 (term -> fact resfact .)
    DIFFERENT       reduce using rule 98 (term -> fact resfact .)
    OR              reduce using rule 98 (term -> fact resfact .)
    AND             reduce using rule 98 (term -> fact resfact .)
    RPAREN          reduce using rule 98 (term -> fact resfact .)
    RBRACE          reduce using rule 98 (term -> fact resfact .)
    SEMICOLON       reduce using rule 98 (term -> fact resfact .)
    COMA            reduce using rule 98 (term -> fact resfact .)
    TIMES           shift and go to state 183
    DIVIDE          shift and go to state 184


state 145

    (113) var_cte -> ID pushid .
    (120) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 113 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 113 (var_cte -> ID pushid .)
    PLUS            reduce using rule 113 (var_cte -> ID pushid .)
    MINUS           reduce using rule 113 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 113 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 113 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 113 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 113 (var_cte -> ID pushid .)
    SAME            reduce using rule 113 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 113 (var_cte -> ID pushid .)
    OR              reduce using rule 113 (var_cte -> ID pushid .)
    AND             reduce using rule 113 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 113 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 113 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 113 (var_cte -> ID pushid .)
    COMA            reduce using rule 113 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 185


state 146

    (114) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 114 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 114 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 114 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 114 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 114 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 114 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 114 (var_cte -> CTE_I pushcte .)


state 147

    (115) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 115 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 115 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 115 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 115 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 115 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 115 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 115 (var_cte -> CTE_F pushcte .)


state 148

    (116) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 116 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 116 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 116 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 116 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 116 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 116 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 116 (var_cte -> CTE_S pushcte .)


state 149

    (117) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 117 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 117 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 117 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 117 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 117 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 117 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 117 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 117 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 117 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 117 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 117 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 117 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 117 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 117 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 117 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 117 (var_cte -> TRUE pushcte .)


state 150

    (118) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 118 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 118 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 118 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 118 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 118 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 118 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 118 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 118 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 118 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 118 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 118 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 118 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 118 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 118 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 118 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 118 (var_cte -> FALSE pushcte .)


state 151

    (81) escrit -> PRINT pushop LPAREN imprimirl . escriti RPAREN SEMICOLON
    (82) escriti -> . expres escrit1
    (83) escriti -> . expres escrit2 COMA escriti
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    escriti                        shift and go to state 186
    expres                         shift and go to state 187
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 152

    (87) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 188


state 153

    (88) leer -> READ pushop LPAREN ID . pushid readid RPAREN readid SEMICOLON
    (132) pushid -> .

    RPAREN          reduce using rule 132 (pushid -> .)

    pushid                         shift and go to state 189

state 154

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 155

    (26) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY bloq return1 RKEY

    RPAREN          shift and go to state 190


state 156

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 191


state 157

    (43) funci -> INT . ID sumparam
    (44) funci -> INT . ID sumparam COMA funci

    ID              shift and go to state 192


state 158

    (45) funci -> FLOAT . ID sumparam
    (46) funci -> FLOAT . ID sumparam COMA funci

    ID              shift and go to state 193


state 159

    (47) funci -> STRING . ID sumparam
    (48) funci -> STRING . ID sumparam COMA funci

    ID              shift and go to state 194


state 160

    (49) funci -> BOOL . ID sumparam
    (50) funci -> BOOL . ID sumparam COMA funci

    ID              shift and go to state 195


state 161

    (51) funci -> empty .

    RPAREN          reduce using rule 51 (funci -> empty .)


state 162

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY bloq RKEY

    RPAREN          shift and go to state 196


state 163

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 197


state 164

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 165

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 166

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)


state 167

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)


state 168

    (121) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN
    (122) fcall -> ID . existfunc LPAREN startera RPAREN
    (113) var_cte -> ID . pushid
    (120) asigvector -> ID . pushid LBRACE ex RBRACE
    (125) existfunc -> .
    (132) pushid -> .

    LPAREN          reduce using rule 125 (existfunc -> .)
    LBRACE          reduce using rule 132 (pushid -> .)
    TIMES           reduce using rule 132 (pushid -> .)
    DIVIDE          reduce using rule 132 (pushid -> .)
    PLUS            reduce using rule 132 (pushid -> .)
    MINUS           reduce using rule 132 (pushid -> .)
    LOWERTHAN       reduce using rule 132 (pushid -> .)
    MORETHAN        reduce using rule 132 (pushid -> .)
    LOWEREQ         reduce using rule 132 (pushid -> .)
    MOREEQ          reduce using rule 132 (pushid -> .)
    SAME            reduce using rule 132 (pushid -> .)
    DIFFERENT       reduce using rule 132 (pushid -> .)
    OR              reduce using rule 132 (pushid -> .)
    AND             reduce using rule 132 (pushid -> .)
    SEMICOLON       reduce using rule 132 (pushid -> .)

    existfunc                      shift and go to state 198
    pushid                         shift and go to state 145

state 169

    (76) asign -> ID pushid EQUAL pushop fcall . SEMICOLON

    SEMICOLON       shift and go to state 199


state 170

    (77) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (135) resolverasignacion -> .

    SEMICOLON       reduce using rule 135 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 200

state 171

    (78) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres resasignvec SEMICOLON

    EQUAL           shift and go to state 201


state 172

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 202


state 173

    (124) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 203


state 174

    (127) fcall1 -> expres . generateparam
    (128) fcall1 -> expres . generateparam COMA fcall1
    (129) generateparam -> .

    COMA            reduce using rule 129 (generateparam -> .)
    RPAREN          reduce using rule 129 (generateparam -> .)

    generateparam                  shift and go to state 204

state 175

    (101) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 205


state 176

    (79) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (140) resif -> .

    ID              reduce using rule 140 (resif -> .)
    IF              reduce using rule 140 (resif -> .)
    PRINT           reduce using rule 140 (resif -> .)
    WHILE           reduce using rule 140 (resif -> .)
    READ            reduce using rule 140 (resif -> .)

    resif                          shift and go to state 206

state 177

    (91) expres -> exr log expres . reslog
    (94) reslog -> .

    RPAREN          reduce using rule 94 (reslog -> .)
    SEMICOLON       reduce using rule 94 (reslog -> .)
    COMA            reduce using rule 94 (reslog -> .)

    reslog                         shift and go to state 207

state 178

    (93) exr -> ex rel exr . resrel
    (139) resrel -> .

    OR              reduce using rule 139 (resrel -> .)
    AND             reduce using rule 139 (resrel -> .)
    RPAREN          reduce using rule 139 (resrel -> .)
    RBRACE          reduce using rule 139 (resrel -> .)
    SEMICOLON       reduce using rule 139 (resrel -> .)
    COMA            reduce using rule 139 (resrel -> .)

    resrel                         shift and go to state 208

state 179

    (96) ex -> term resterm PLUS . pushop ex
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 209

state 180

    (97) ex -> term resterm MINUS . pushop ex
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 210

state 181

    (103) fact -> PLUS pushop var_cte .

    TIMES           reduce using rule 103 (fact -> PLUS pushop var_cte .)
    DIVIDE          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    PLUS            reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MINUS           reduce using rule 103 (fact -> PLUS pushop var_cte .)
    LOWERTHAN       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MORETHAN        reduce using rule 103 (fact -> PLUS pushop var_cte .)
    LOWEREQ         reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MOREEQ          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    SAME            reduce using rule 103 (fact -> PLUS pushop var_cte .)
    DIFFERENT       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    OR              reduce using rule 103 (fact -> PLUS pushop var_cte .)
    AND             reduce using rule 103 (fact -> PLUS pushop var_cte .)
    RPAREN          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    RBRACE          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    SEMICOLON       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    COMA            reduce using rule 103 (fact -> PLUS pushop var_cte .)


state 182

    (104) fact -> MINUS pushop var_cte .

    TIMES           reduce using rule 104 (fact -> MINUS pushop var_cte .)
    DIVIDE          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    PLUS            reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MINUS           reduce using rule 104 (fact -> MINUS pushop var_cte .)
    LOWERTHAN       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MORETHAN        reduce using rule 104 (fact -> MINUS pushop var_cte .)
    LOWEREQ         reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MOREEQ          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    SAME            reduce using rule 104 (fact -> MINUS pushop var_cte .)
    DIFFERENT       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    OR              reduce using rule 104 (fact -> MINUS pushop var_cte .)
    AND             reduce using rule 104 (fact -> MINUS pushop var_cte .)
    RPAREN          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    RBRACE          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    SEMICOLON       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    COMA            reduce using rule 104 (fact -> MINUS pushop var_cte .)


state 183

    (99) term -> fact resfact TIMES . pushop term
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 211

state 184

    (100) term -> fact resfact DIVIDE . pushop term
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 212

state 185

    (120) asigvector -> ID pushid LBRACE . ex RBRACE
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 213
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 186

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 214


state 187

    (82) escriti -> expres . escrit1
    (83) escriti -> expres . escrit2 COMA escriti
    (85) escrit1 -> .
    (86) escrit2 -> .

    RPAREN          reduce using rule 85 (escrit1 -> .)
    COMA            reduce using rule 86 (escrit2 -> .)

    escrit1                        shift and go to state 215
    escrit2                        shift and go to state 216

state 188

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (144) while2 -> .

    LKEY            reduce using rule 144 (while2 -> .)

    while2                         shift and go to state 217

state 189

    (88) leer -> READ pushop LPAREN ID pushid . readid RPAREN readid SEMICOLON
    (89) readid -> .

    RPAREN          reduce using rule 89 (readid -> .)

    readid                         shift and go to state 218

state 190

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY bloq return1 RKEY

    LKEY            shift and go to state 219


state 191

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 221
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 220
    bloq                           shift and go to state 222
    var                            shift and go to state 223
    vector                         shift and go to state 224
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 192

    (43) funci -> INT ID . sumparam
    (44) funci -> INT ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 225

state 193

    (45) funci -> FLOAT ID . sumparam
    (46) funci -> FLOAT ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 226

state 194

    (47) funci -> STRING ID . sumparam
    (48) funci -> STRING ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 227

state 195

    (49) funci -> BOOL ID . sumparam
    (50) funci -> BOOL ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 228

state 196

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 229


state 197

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . bloq RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 230
    bloq                           shift and go to state 231
    var                            shift and go to state 223
    vector                         shift and go to state 224
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 198

    (121) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN
    (122) fcall -> ID existfunc . LPAREN startera RPAREN

    LPAREN          shift and go to state 232


state 199

    (76) asign -> ID pushid EQUAL pushop fcall SEMICOLON .

    ID              reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    IF              reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    PRINT           reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    WHILE           reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    READ            reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    RKEY            reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    RETURN          reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)


state 200

    (77) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 233


state 201

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres resasignvec SEMICOLON
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 234

state 202

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 235


state 203

    (124) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

    ID              reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)


state 204

    (127) fcall1 -> expres generateparam .
    (128) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 127 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 236


state 205

    (101) fact -> LPAREN pushop expres RPAREN . popop
    (134) popop -> .

    TIMES           reduce using rule 134 (popop -> .)
    DIVIDE          reduce using rule 134 (popop -> .)
    PLUS            reduce using rule 134 (popop -> .)
    MINUS           reduce using rule 134 (popop -> .)
    LOWERTHAN       reduce using rule 134 (popop -> .)
    MORETHAN        reduce using rule 134 (popop -> .)
    LOWEREQ         reduce using rule 134 (popop -> .)
    MOREEQ          reduce using rule 134 (popop -> .)
    SAME            reduce using rule 134 (popop -> .)
    DIFFERENT       reduce using rule 134 (popop -> .)
    OR              reduce using rule 134 (popop -> .)
    AND             reduce using rule 134 (popop -> .)
    RPAREN          reduce using rule 134 (popop -> .)
    RBRACE          reduce using rule 134 (popop -> .)
    SEMICOLON       reduce using rule 134 (popop -> .)
    COMA            reduce using rule 134 (popop -> .)

    popop                          shift and go to state 237

state 206

    (79) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 238
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 207

    (91) expres -> exr log expres reslog .

    RPAREN          reduce using rule 91 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 91 (expres -> exr log expres reslog .)
    COMA            reduce using rule 91 (expres -> exr log expres reslog .)


state 208

    (93) exr -> ex rel exr resrel .

    OR              reduce using rule 93 (exr -> ex rel exr resrel .)
    AND             reduce using rule 93 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 93 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 93 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 93 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 93 (exr -> ex rel exr resrel .)


state 209

    (96) ex -> term resterm PLUS pushop . ex
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 239
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 210

    (97) ex -> term resterm MINUS pushop . ex
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 240
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 211

    (99) term -> fact resfact TIMES pushop . term
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 241
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 212

    (100) term -> fact resfact DIVIDE pushop . term
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 242
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 213

    (120) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 243


state 214

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 244


state 215

    (82) escriti -> expres escrit1 .

    RPAREN          reduce using rule 82 (escriti -> expres escrit1 .)


state 216

    (83) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 245


state 217

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 246


state 218

    (88) leer -> READ pushop LPAREN ID pushid readid . RPAREN readid SEMICOLON

    RPAREN          shift and go to state 247


state 219

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . bloq return1 RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 248
    bloq                           shift and go to state 249
    var                            shift and go to state 223
    vector                         shift and go to state 224
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 220

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 250
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 251
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 221

    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 36 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 36 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 222

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (130) empty -> .

    RETURN          shift and go to state 253
    RKEY            reduce using rule 130 (empty -> .)

    return1                        shift and go to state 252
    empty                          shift and go to state 254

state 223

    (52) localvar -> var .
    (54) localvar -> var . localvar
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 52 (localvar -> var .)
    ID              reduce using rule 52 (localvar -> var .)
    IF              reduce using rule 52 (localvar -> var .)
    PRINT           reduce using rule 52 (localvar -> var .)
    WHILE           reduce using rule 52 (localvar -> var .)
    READ            reduce using rule 52 (localvar -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 223
    localvar                       shift and go to state 255
    vector                         shift and go to state 224

state 224

    (53) localvar -> vector .
    (55) localvar -> vector . localvar
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 53 (localvar -> vector .)
    ID              reduce using rule 53 (localvar -> vector .)
    IF              reduce using rule 53 (localvar -> vector .)
    PRINT           reduce using rule 53 (localvar -> vector .)
    WHILE           reduce using rule 53 (localvar -> vector .)
    READ            reduce using rule 53 (localvar -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 224
    localvar                       shift and go to state 256
    var                            shift and go to state 223

state 225

    (43) funci -> INT ID sumparam .
    (44) funci -> INT ID sumparam . COMA funci

    RPAREN          reduce using rule 43 (funci -> INT ID sumparam .)
    COMA            shift and go to state 257


state 226

    (45) funci -> FLOAT ID sumparam .
    (46) funci -> FLOAT ID sumparam . COMA funci

    RPAREN          reduce using rule 45 (funci -> FLOAT ID sumparam .)
    COMA            shift and go to state 258


state 227

    (47) funci -> STRING ID sumparam .
    (48) funci -> STRING ID sumparam . COMA funci

    RPAREN          reduce using rule 47 (funci -> STRING ID sumparam .)
    COMA            shift and go to state 259


state 228

    (49) funci -> BOOL ID sumparam .
    (50) funci -> BOOL ID sumparam . COMA funci

    RPAREN          reduce using rule 49 (funci -> BOOL ID sumparam .)
    COMA            shift and go to state 260


state 229

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . bloq RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 261
    bloq                           shift and go to state 262
    var                            shift and go to state 223
    vector                         shift and go to state 224
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 230

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 263
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 264
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 231

    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 265


state 232

    (121) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN
    (122) fcall -> ID existfunc LPAREN . startera RPAREN
    (126) startera -> .

    RPAREN          reduce using rule 126 (startera -> .)
    LPAREN          reduce using rule 126 (startera -> .)
    PLUS            reduce using rule 126 (startera -> .)
    MINUS           reduce using rule 126 (startera -> .)
    ID              reduce using rule 126 (startera -> .)
    CTE_I           reduce using rule 126 (startera -> .)
    CTE_F           reduce using rule 126 (startera -> .)
    CTE_S           reduce using rule 126 (startera -> .)
    TRUE            reduce using rule 126 (startera -> .)
    FALSE           reduce using rule 126 (startera -> .)

    startera                       shift and go to state 266

state 233

    (77) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 234

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres resasignvec SEMICOLON
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 267
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 235

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

    ID              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)


state 236

    (128) fcall1 -> expres generateparam COMA . fcall1
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 174
    fcall1                         shift and go to state 268
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 237

    (101) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)


state 238

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 269


state 239

    (96) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 96 (ex -> term resterm PLUS pushop ex .)


state 240

    (97) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 97 (ex -> term resterm MINUS pushop ex .)


state 241

    (99) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 99 (term -> fact resfact TIMES pushop term .)


state 242

    (100) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)


state 243

    (120) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 244

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .

    ID              reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    IF              reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    READ            reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)


state 245

    (83) escriti -> expres escrit2 COMA . escriti
    (82) escriti -> . expres escrit1
    (83) escriti -> . expres escrit2 COMA escriti
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 187
    escriti                        shift and go to state 270
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 246

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 271
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 247

    (88) leer -> READ pushop LPAREN ID pushid readid RPAREN . readid SEMICOLON
    (89) readid -> .

    SEMICOLON       reduce using rule 89 (readid -> .)

    readid                         shift and go to state 272

state 248

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 273
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 249

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (130) empty -> .

    RETURN          shift and go to state 253
    RKEY            reduce using rule 130 (empty -> .)

    return1                        shift and go to state 274
    empty                          shift and go to state 254

state 250

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 251

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (130) empty -> .

    RETURN          shift and go to state 253
    RKEY            reduce using rule 130 (empty -> .)

    return1                        shift and go to state 275
    empty                          shift and go to state 254

state 252

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 276


state 253

    (57) return1 -> RETURN . pushop expres resreturn SEMICOLON
    (133) pushop -> .

    LPAREN          reduce using rule 133 (pushop -> .)
    PLUS            reduce using rule 133 (pushop -> .)
    MINUS           reduce using rule 133 (pushop -> .)
    ID              reduce using rule 133 (pushop -> .)
    CTE_I           reduce using rule 133 (pushop -> .)
    CTE_F           reduce using rule 133 (pushop -> .)
    CTE_S           reduce using rule 133 (pushop -> .)
    TRUE            reduce using rule 133 (pushop -> .)
    FALSE           reduce using rule 133 (pushop -> .)

    pushop                         shift and go to state 277

state 254

    (58) return1 -> empty .

    RKEY            reduce using rule 58 (return1 -> empty .)


state 255

    (54) localvar -> var localvar .

    RKEY            reduce using rule 54 (localvar -> var localvar .)
    ID              reduce using rule 54 (localvar -> var localvar .)
    IF              reduce using rule 54 (localvar -> var localvar .)
    PRINT           reduce using rule 54 (localvar -> var localvar .)
    WHILE           reduce using rule 54 (localvar -> var localvar .)
    READ            reduce using rule 54 (localvar -> var localvar .)


state 256

    (55) localvar -> vector localvar .

    RKEY            reduce using rule 55 (localvar -> vector localvar .)
    ID              reduce using rule 55 (localvar -> vector localvar .)
    IF              reduce using rule 55 (localvar -> vector localvar .)
    PRINT           reduce using rule 55 (localvar -> vector localvar .)
    WHILE           reduce using rule 55 (localvar -> vector localvar .)
    READ            reduce using rule 55 (localvar -> vector localvar .)


state 257

    (44) funci -> INT ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160
    RPAREN          reduce using rule 130 (empty -> .)

    funci                          shift and go to state 278
    empty                          shift and go to state 161

state 258

    (46) funci -> FLOAT ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160
    RPAREN          reduce using rule 130 (empty -> .)

    funci                          shift and go to state 279
    empty                          shift and go to state 161

state 259

    (48) funci -> STRING ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160
    RPAREN          reduce using rule 130 (empty -> .)

    funci                          shift and go to state 280
    empty                          shift and go to state 161

state 260

    (50) funci -> BOOL ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (130) empty -> .

    INT             shift and go to state 157
    FLOAT           shift and go to state 158
    STRING          shift and go to state 159
    BOOL            shift and go to state 160
    RPAREN          reduce using rule 130 (empty -> .)

    funci                          shift and go to state 281
    empty                          shift and go to state 161

state 261

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 282
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 262

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 283


state 263

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 264

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 284


state 265

    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 34 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 34 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)


state 266

    (121) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN
    (122) fcall -> ID existfunc LPAREN startera . RPAREN
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 286
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 285
    expres                         shift and go to state 174
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 267

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . resasignvec SEMICOLON
    (136) resasignvec -> .

    SEMICOLON       reduce using rule 136 (resasignvec -> .)

    resasignvec                    shift and go to state 287

state 268

    (128) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 128 (fcall1 -> expres generateparam COMA fcall1 .)


state 269

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (142) finif -> .

    ELSE            shift and go to state 289
    ID              reduce using rule 142 (finif -> .)
    IF              reduce using rule 142 (finif -> .)
    PRINT           reduce using rule 142 (finif -> .)
    WHILE           reduce using rule 142 (finif -> .)
    READ            reduce using rule 142 (finif -> .)
    RKEY            reduce using rule 142 (finif -> .)
    RETURN          reduce using rule 142 (finif -> .)

    finif                          shift and go to state 288

state 270

    (83) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 83 (escriti -> expres escrit2 COMA escriti .)


state 271

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 290


state 272

    (88) leer -> READ pushop LPAREN ID pushid readid RPAREN readid . SEMICOLON

    SEMICOLON       shift and go to state 291


state 273

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (130) empty -> .

    RETURN          shift and go to state 253
    RKEY            reduce using rule 130 (empty -> .)

    return1                        shift and go to state 292
    empty                          shift and go to state 254

state 274

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 293


state 275

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 294


state 276

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)


state 277

    (57) return1 -> RETURN pushop . expres resreturn SEMICOLON
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . asigvector
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 295
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    asigvector                     shift and go to state 114

state 278

    (44) funci -> INT ID sumparam COMA funci .

    RPAREN          reduce using rule 44 (funci -> INT ID sumparam COMA funci .)


state 279

    (46) funci -> FLOAT ID sumparam COMA funci .

    RPAREN          reduce using rule 46 (funci -> FLOAT ID sumparam COMA funci .)


state 280

    (48) funci -> STRING ID sumparam COMA funci .

    RPAREN          reduce using rule 48 (funci -> STRING ID sumparam COMA funci .)


state 281

    (50) funci -> BOOL ID sumparam COMA funci .

    RPAREN          reduce using rule 50 (funci -> BOOL ID sumparam COMA funci .)


state 282

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 296


state 283

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)


state 284

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 285

    (121) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN

    RPAREN          shift and go to state 297


state 286

    (122) fcall -> ID existfunc LPAREN startera RPAREN .

    SEMICOLON       reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN .)


state 287

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec . SEMICOLON

    SEMICOLON       shift and go to state 298


state 288

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 289

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 299


state 290

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (145) while3 -> .

    ID              reduce using rule 145 (while3 -> .)
    IF              reduce using rule 145 (while3 -> .)
    PRINT           reduce using rule 145 (while3 -> .)
    WHILE           reduce using rule 145 (while3 -> .)
    READ            reduce using rule 145 (while3 -> .)
    RKEY            reduce using rule 145 (while3 -> .)
    RETURN          reduce using rule 145 (while3 -> .)

    while3                         shift and go to state 300

state 291

    (88) leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .

    ID              reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    IF              reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    PRINT           reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    WHILE           reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    READ            reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    RKEY            reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)
    RETURN          reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON .)


state 292

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 301


state 293

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)


state 294

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 32 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 32 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)


state 295

    (57) return1 -> RETURN pushop expres . resreturn SEMICOLON
    (59) resreturn -> .

    SEMICOLON       reduce using rule 59 (resreturn -> .)

    resreturn                      shift and go to state 302

state 296

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 297

    (121) fcall -> ID existfunc LPAREN startera fcall1 RPAREN .

    SEMICOLON       reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN .)


state 298

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .

    ID              reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    IF              reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    PRINT           reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    WHILE           reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    READ            reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    RKEY            reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    RETURN          reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)


state 299

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (141) reselse -> .

    ID              reduce using rule 141 (reselse -> .)
    IF              reduce using rule 141 (reselse -> .)
    PRINT           reduce using rule 141 (reselse -> .)
    WHILE           reduce using rule 141 (reselse -> .)
    READ            reduce using rule 141 (reselse -> .)

    reselse                        shift and go to state 303

state 300

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 301

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)


state 302

    (57) return1 -> RETURN pushop expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 304


state 303

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN readid SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 305
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 304

    (57) return1 -> RETURN pushop expres resreturn SEMICOLON .

    RKEY            reduce using rule 57 (return1 -> RETURN pushop expres resreturn SEMICOLON .)


state 305

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 306


state 306

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (142) finif -> .

    ID              reduce using rule 142 (finif -> .)
    IF              reduce using rule 142 (finif -> .)
    PRINT           reduce using rule 142 (finif -> .)
    WHILE           reduce using rule 142 (finif -> .)
    READ            reduce using rule 142 (finif -> .)
    RKEY            reduce using rule 142 (finif -> .)
    RETURN          reduce using rule 142 (finif -> .)

    finif                          shift and go to state 307

state 307

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 120 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 121 resolved as shift
