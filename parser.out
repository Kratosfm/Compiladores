Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 4     gotomain -> <empty>
Rule 5     program2 -> crear program2
Rule 6     program2 -> crear
Rule 7     program3 -> function program3
Rule 8     program3 -> function
Rule 9     llenarmain -> <empty>
Rule 10    crear -> var
Rule 11    crear -> vector
Rule 12    global -> <empty>
Rule 13    finglobal -> <empty>
Rule 14    main1 -> <empty>
Rule 15    finmain -> <empty>
Rule 16    var -> VAR tipo ID SEMICOLON
Rule 17    tipo -> INT
Rule 18    tipo -> FLOAT
Rule 19    tipo -> STRING
Rule 20    tipo -> BOOL
Rule 21    vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 22    vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
Rule 24    vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
Rule 25    initvector -> <empty>
Rule 26    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
Rule 27    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 28    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
Rule 29    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 30    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 31    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
Rule 32    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 33    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
Rule 34    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
Rule 35    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 36    functype -> INT
Rule 37    functype -> FLOAT
Rule 38    functype -> STRING
Rule 39    functype -> BOOL
Rule 40    pushvoid -> VOID
Rule 41    addInTable -> <empty>
Rule 42    funci -> INT ID
Rule 43    funci -> INT ID COMA funci
Rule 44    funci -> FLOAT ID
Rule 45    funci -> FLOAT ID COMA funci
Rule 46    funci -> STRING ID
Rule 47    funci -> STRING ID COMA funci
Rule 48    funci -> BOOL ID
Rule 49    funci -> BOOL ID COMA funci
Rule 50    funci -> empty
Rule 51    localvar -> var
Rule 52    localvar -> vector
Rule 53    localvar -> var localvar
Rule 54    localvar -> vector localvar
Rule 55    return1 -> RETURN expres resreturn SEMICOLON
Rule 56    return1 -> empty
Rule 57    resreturn -> <empty>
Rule 58    mainc -> LKEY RKEY
Rule 59    mainc -> LKEY bloq RKEY
Rule 60    mainc -> LKEY mainc2 bloq RKEY
Rule 61    mainc -> LKEY mainc2 RKEY
Rule 62    mainc2 -> var
Rule 63    mainc2 -> var mainc2
Rule 64    mainc2 -> vector
Rule 65    mainc2 -> vector mainc2
Rule 66    bloq -> estat
Rule 67    bloq -> estat bloq
Rule 68    estat -> asign
Rule 69    estat -> cond
Rule 70    estat -> escrit
Rule 71    estat -> ciclo
Rule 72    estat -> leer
Rule 73    estat -> fcallvoid
Rule 74    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 75    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
Rule 76    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 77    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 78    escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
Rule 79    escriti -> expres escrit1
Rule 80    escriti -> expres escrit2 COMA escriti
Rule 81    imprimirl -> <empty>
Rule 82    escrit1 -> <empty>
Rule 83    escrit2 -> <empty>
Rule 84    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 85    leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
Rule 86    readid -> <empty>
Rule 87    expres -> exr
Rule 88    expres -> exr log expres reslog
Rule 89    exr -> ex
Rule 90    exr -> ex rel exr resrel
Rule 91    reslog -> <empty>
Rule 92    ex -> term resterm
Rule 93    ex -> term resterm PLUS pushop ex
Rule 94    ex -> term resterm MINUS pushop ex
Rule 95    term -> fact resfact
Rule 96    term -> fact resfact TIMES pushop term
Rule 97    term -> fact resfact DIVIDE pushop term
Rule 98    fact -> LPAREN pushop expres RPAREN popop
Rule 99    fact -> var_cte
Rule 100   fact -> PLUS var_cte
Rule 101   fact -> MINUS var_cte
Rule 102   rel -> LOWERTHAN
Rule 103   rel -> MORETHAN
Rule 104   rel -> LOWEREQ
Rule 105   rel -> MOREEQ
Rule 106   rel -> SAME
Rule 107   rel -> DIFFERENT
Rule 108   log -> OR
Rule 109   log -> AND
Rule 110   var_cte -> ID pushid
Rule 111   var_cte -> CTE_I pushcte
Rule 112   var_cte -> CTE_F pushcte
Rule 113   var_cte -> CTE_S pushcte
Rule 114   var_cte -> TRUE pushcte
Rule 115   var_cte -> FALSE pushcte
Rule 116   var_cte -> fcall
Rule 117   var_cte -> vcall
Rule 118   var_cte -> asigvector
Rule 119   asigvector -> ID pushid LBRACE ex RBRACE
Rule 120   fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
Rule 121   fcall -> ID existfunc LPAREN startera RPAREN generateGoSub
Rule 122   fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 123   fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 124   existfunc -> <empty>
Rule 125   startera -> <empty>
Rule 126   fcall1 -> expres generateparam
Rule 127   fcall1 -> expres generateparam COMA fcall1
Rule 128   generateparam -> <empty>
Rule 129   generateGoSub -> <empty>
Rule 130   vcall -> ID LBRACE expres RBRACE
Rule 131   empty -> <empty>
Rule 132   pushcte -> <empty>
Rule 133   pushid -> <empty>
Rule 134   pushop -> <empty>
Rule 135   popop -> <empty>
Rule 136   resolverasignacion -> <empty>
Rule 137   resfact -> <empty>
Rule 138   resterm -> <empty>
Rule 139   resrel -> <empty>
Rule 140   resif -> <empty>
Rule 141   reselse -> <empty>
Rule 142   finif -> <empty>
Rule 143   while1 -> <empty>
Rule 144   while2 -> <empty>
Rule 145   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 109
BOOL                 : 20 24 39 48 49
COLON                : 1 2 3
COMA                 : 43 45 47 49 80 127
CTE_F                : 112
CTE_I                : 21 22 23 24 111
CTE_S                : 113
DIFFERENT            : 107
DIVIDE               : 97
ELSE                 : 77
EQUAL                : 74 75
FALSE                : 115
FLOAT                : 18 22 37 44 45
FUNCTION             : 26 27 28 29 30 31 32 33 34 35
ID                   : 16 21 22 23 24 26 27 28 29 30 31 32 33 34 35 42 43 44 45 46 47 48 49 74 75 85 110 119 120 121 122 123 130
IF                   : 76 77
INT                  : 17 21 36 42 43
LBRACE               : 21 22 23 24 75 119 130
LKEY                 : 26 27 28 29 30 31 32 33 34 35 58 59 60 61 76 77 77 84
LOWEREQ              : 104
LOWERTHAN            : 102
LPAREN               : 26 27 28 29 30 31 32 33 34 35 76 77 78 84 85 98 120 121 122 123
MAIN                 : 1 2 3
MINUS                : 94 101
MOREEQ               : 105
MORETHAN             : 103
OR                   : 108
PLUS                 : 93 100
PRINT                : 78
PROGRAM              : 1 2 3
RBRACE               : 21 22 23 24 75 119 130
READ                 : 85
RETURN               : 55
RKEY                 : 26 27 28 29 30 31 32 33 34 35 58 59 60 61 76 77 77 84
RPAREN               : 26 27 28 29 30 31 32 33 34 35 76 77 78 84 85 98 120 121 122 123
SAME                 : 106
SEMICOLON            : 16 21 22 23 24 55 74 75 78 85 122 123
STRING               : 19 23 38 46 47
TIMES                : 96
TRUE                 : 114
VAR                  : 16
VECTOR               : 21 22 23 24
VOID                 : 40
WHILE                : 84
error                : 

Nonterminals, with rules where they appear

addInTable           : 26 27 28 29 30 31 32 33 34 35
asign                : 68
asigvector           : 118
bloq                 : 26 27 28 31 32 33 34 59 60 67 76 77 77 84
ciclo                : 71
cond                 : 69
crear                : 5 6
empty                : 50 56
escrit               : 70
escrit1              : 79
escrit2              : 80
escriti              : 78 80
estat                : 66 67
ex                   : 89 90 93 94 119
existfunc            : 120 121 122 123
expres               : 55 74 75 76 77 79 80 84 88 98 126 127 130
exr                  : 75 87 88 90
fact                 : 95 96 97
fcall                : 116
fcall1               : 120 122 127
fcallvoid            : 73
finglobal            : 1 2
finif                : 76 77
finmain              : 1 2 3
funci                : 26 27 28 43 45 47 49
function             : 7 8
functype             : 26 29 31 34 35
generateGoSub        : 120 121
generateparam        : 126 127
global               : 1 2
gotomain             : 1 2 3
imprimirl            : 78
initvector           : 21 22 23 24
leer                 : 72
llenarmain           : 1 2 3
localvar             : 26 27 29 30 31 32 53 54
log                  : 88
main1                : 1 2 3
mainc                : 1 2 3
mainc2               : 60 61 63 65
popop                : 98
program              : 0
program2             : 1 2 5
program3             : 1 7
pushcte              : 111 112 113 114 115
pushid               : 74 75 85 110 119
pushop               : 74 75 78 85 93 94 96 97 98
pushvoid             : 27 28 30 32 33
readid               : 85
rel                  : 90
reselse              : 77
resfact              : 95 96 97
resif                : 76 77
reslog               : 88
resolverasignacion   : 74
resrel               : 90
resreturn            : 55
resterm              : 92 93 94
return1              : 26 31 34
startera             : 120 121 122 123
term                 : 92 93 94 96 97
tipo                 : 16
var                  : 10 51 53 62 63
var_cte              : 99 100 101
vcall                : 117
vector               : 11 52 54 64 65
while1               : 84
while2               : 84
while3               : 84

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (4) gotomain -> .

    VAR             reduce using rule 4 (gotomain -> .)
    VECTOR          reduce using rule 4 (gotomain -> .)
    MAIN            reduce using rule 4 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (12) global -> .
    (9) llenarmain -> .

    VAR             reduce using rule 12 (global -> .)
    VECTOR          reduce using rule 12 (global -> .)
    MAIN            reduce using rule 9 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    program2                       shift and go to state 7
    crear                          shift and go to state 8
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 6

    (3) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 13


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (13) finglobal -> .

    FUNCTION        reduce using rule 13 (finglobal -> .)
    MAIN            reduce using rule 13 (finglobal -> .)

    finglobal                      shift and go to state 14

state 8

    (5) program2 -> crear . program2
    (6) program2 -> crear .
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 6 (program2 -> crear .)
    MAIN            reduce using rule 6 (program2 -> crear .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    crear                          shift and go to state 8
    program2                       shift and go to state 15
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 9

    (10) crear -> var .

    VAR             reduce using rule 10 (crear -> var .)
    VECTOR          reduce using rule 10 (crear -> var .)
    FUNCTION        reduce using rule 10 (crear -> var .)
    MAIN            reduce using rule 10 (crear -> var .)


state 10

    (11) crear -> vector .

    VAR             reduce using rule 11 (crear -> vector .)
    VECTOR          reduce using rule 11 (crear -> vector .)
    FUNCTION        reduce using rule 11 (crear -> vector .)
    MAIN            reduce using rule 11 (crear -> vector .)


state 11

    (16) var -> VAR . tipo ID SEMICOLON
    (17) tipo -> . INT
    (18) tipo -> . FLOAT
    (19) tipo -> . STRING
    (20) tipo -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    BOOL            shift and go to state 20

    tipo                           shift and go to state 16

state 12

    (21) vector -> VECTOR . initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR . initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR . initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR . initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (25) initvector -> .

    INT             reduce using rule 25 (initvector -> .)
    FLOAT           reduce using rule 25 (initvector -> .)
    STRING          reduce using rule 25 (initvector -> .)
    BOOL            reduce using rule 25 (initvector -> .)

    initvector                     shift and go to state 21

state 13

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 22

state 14

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (7) program3 -> . function program3
    (8) program3 -> . function
    (9) llenarmain -> .
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (llenarmain -> .)
    FUNCTION        shift and go to state 26

    program3                       shift and go to state 23
    llenarmain                     shift and go to state 24
    function                       shift and go to state 25

state 15

    (5) program2 -> crear program2 .

    FUNCTION        reduce using rule 5 (program2 -> crear program2 .)
    MAIN            reduce using rule 5 (program2 -> crear program2 .)


state 16

    (16) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 27


state 17

    (17) tipo -> INT .

    ID              reduce using rule 17 (tipo -> INT .)


state 18

    (18) tipo -> FLOAT .

    ID              reduce using rule 18 (tipo -> FLOAT .)


state 19

    (19) tipo -> STRING .

    ID              reduce using rule 19 (tipo -> STRING .)


state 20

    (20) tipo -> BOOL .

    ID              reduce using rule 20 (tipo -> BOOL .)


state 21

    (21) vector -> VECTOR initvector . INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR initvector . FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR initvector . STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR initvector . BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31


state 22

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (58) mainc -> . LKEY RKEY
    (59) mainc -> . LKEY bloq RKEY
    (60) mainc -> . LKEY mainc2 bloq RKEY
    (61) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 32

state 23

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (9) llenarmain -> .

    MAIN            reduce using rule 9 (llenarmain -> .)

    llenarmain                     shift and go to state 34

state 24

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 35


state 25

    (7) program3 -> function . program3
    (8) program3 -> function .
    (7) program3 -> . function program3
    (8) program3 -> . function
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 8 (program3 -> function .)
    FUNCTION        shift and go to state 26

    function                       shift and go to state 25
    program3                       shift and go to state 36

state 26

    (26) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (36) functype -> . INT
    (37) functype -> . FLOAT
    (38) functype -> . STRING
    (39) functype -> . BOOL
    (40) pushvoid -> . VOID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STRING          shift and go to state 41
    BOOL            shift and go to state 42
    VOID            shift and go to state 43

    functype                       shift and go to state 37
    pushvoid                       shift and go to state 38

state 27

    (16) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 44


state 28

    (21) vector -> VECTOR initvector INT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 45


state 29

    (22) vector -> VECTOR initvector FLOAT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 46


state 30

    (23) vector -> VECTOR initvector STRING . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 47


state 31

    (24) vector -> VECTOR initvector BOOL . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 48


state 32

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 49

state 33

    (58) mainc -> LKEY . RKEY
    (59) mainc -> LKEY . bloq RKEY
    (60) mainc -> LKEY . mainc2 bloq RKEY
    (61) mainc -> LKEY . mainc2 RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (62) mainc2 -> . var
    (63) mainc2 -> . var mainc2
    (64) mainc2 -> . vector
    (65) mainc2 -> . vector mainc2
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 50
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 51
    mainc2                         shift and go to state 52
    estat                          shift and go to state 53
    var                            shift and go to state 54
    vector                         shift and go to state 55
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 34

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 67


state 35

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 68

state 36

    (7) program3 -> function program3 .

    MAIN            reduce using rule 7 (program3 -> function program3 .)


state 37

    (26) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 69


state 38

    (27) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY bloq RKEY

    ID              shift and go to state 70


state 39

    (36) functype -> INT .

    ID              reduce using rule 36 (functype -> INT .)


state 40

    (37) functype -> FLOAT .

    ID              reduce using rule 37 (functype -> FLOAT .)


state 41

    (38) functype -> STRING .

    ID              reduce using rule 38 (functype -> STRING .)


state 42

    (39) functype -> BOOL .

    ID              reduce using rule 39 (functype -> BOOL .)


state 43

    (40) pushvoid -> VOID .

    ID              reduce using rule 40 (pushvoid -> VOID .)


state 44

    (16) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)


state 45

    (21) vector -> VECTOR initvector INT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 71


state 46

    (22) vector -> VECTOR initvector FLOAT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 72


state 47

    (23) vector -> VECTOR initvector STRING ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 73


state 48

    (24) vector -> VECTOR initvector BOOL ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 74


state 49

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 50

    (58) mainc -> LKEY RKEY .

    $end            reduce using rule 58 (mainc -> LKEY RKEY .)


state 51

    (59) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 75


state 52

    (60) mainc -> LKEY mainc2 . bloq RKEY
    (61) mainc -> LKEY mainc2 . RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 77
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 76
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 53

    (66) bloq -> estat .
    (67) bloq -> estat . bloq
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            reduce using rule 66 (bloq -> estat .)
    RETURN          reduce using rule 66 (bloq -> estat .)
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    estat                          shift and go to state 53
    bloq                           shift and go to state 78
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 54

    (62) mainc2 -> var .
    (63) mainc2 -> var . mainc2
    (62) mainc2 -> . var
    (63) mainc2 -> . var mainc2
    (64) mainc2 -> . vector
    (65) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 62 (mainc2 -> var .)
    ID              reduce using rule 62 (mainc2 -> var .)
    IF              reduce using rule 62 (mainc2 -> var .)
    PRINT           reduce using rule 62 (mainc2 -> var .)
    WHILE           reduce using rule 62 (mainc2 -> var .)
    READ            reduce using rule 62 (mainc2 -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 54
    mainc2                         shift and go to state 79
    vector                         shift and go to state 55

state 55

    (64) mainc2 -> vector .
    (65) mainc2 -> vector . mainc2
    (62) mainc2 -> . var
    (63) mainc2 -> . var mainc2
    (64) mainc2 -> . vector
    (65) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 64 (mainc2 -> vector .)
    ID              reduce using rule 64 (mainc2 -> vector .)
    IF              reduce using rule 64 (mainc2 -> vector .)
    PRINT           reduce using rule 64 (mainc2 -> vector .)
    WHILE           reduce using rule 64 (mainc2 -> vector .)
    READ            reduce using rule 64 (mainc2 -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 55
    mainc2                         shift and go to state 80
    var                            shift and go to state 54

state 56

    (68) estat -> asign .

    ID              reduce using rule 68 (estat -> asign .)
    IF              reduce using rule 68 (estat -> asign .)
    PRINT           reduce using rule 68 (estat -> asign .)
    WHILE           reduce using rule 68 (estat -> asign .)
    READ            reduce using rule 68 (estat -> asign .)
    RKEY            reduce using rule 68 (estat -> asign .)
    RETURN          reduce using rule 68 (estat -> asign .)


state 57

    (69) estat -> cond .

    ID              reduce using rule 69 (estat -> cond .)
    IF              reduce using rule 69 (estat -> cond .)
    PRINT           reduce using rule 69 (estat -> cond .)
    WHILE           reduce using rule 69 (estat -> cond .)
    READ            reduce using rule 69 (estat -> cond .)
    RKEY            reduce using rule 69 (estat -> cond .)
    RETURN          reduce using rule 69 (estat -> cond .)


state 58

    (70) estat -> escrit .

    ID              reduce using rule 70 (estat -> escrit .)
    IF              reduce using rule 70 (estat -> escrit .)
    PRINT           reduce using rule 70 (estat -> escrit .)
    WHILE           reduce using rule 70 (estat -> escrit .)
    READ            reduce using rule 70 (estat -> escrit .)
    RKEY            reduce using rule 70 (estat -> escrit .)
    RETURN          reduce using rule 70 (estat -> escrit .)


state 59

    (71) estat -> ciclo .

    ID              reduce using rule 71 (estat -> ciclo .)
    IF              reduce using rule 71 (estat -> ciclo .)
    PRINT           reduce using rule 71 (estat -> ciclo .)
    WHILE           reduce using rule 71 (estat -> ciclo .)
    READ            reduce using rule 71 (estat -> ciclo .)
    RKEY            reduce using rule 71 (estat -> ciclo .)
    RETURN          reduce using rule 71 (estat -> ciclo .)


state 60

    (72) estat -> leer .

    ID              reduce using rule 72 (estat -> leer .)
    IF              reduce using rule 72 (estat -> leer .)
    PRINT           reduce using rule 72 (estat -> leer .)
    WHILE           reduce using rule 72 (estat -> leer .)
    READ            reduce using rule 72 (estat -> leer .)
    RKEY            reduce using rule 72 (estat -> leer .)
    RETURN          reduce using rule 72 (estat -> leer .)


state 61

    (73) estat -> fcallvoid .

    ID              reduce using rule 73 (estat -> fcallvoid .)
    IF              reduce using rule 73 (estat -> fcallvoid .)
    PRINT           reduce using rule 73 (estat -> fcallvoid .)
    WHILE           reduce using rule 73 (estat -> fcallvoid .)
    READ            reduce using rule 73 (estat -> fcallvoid .)
    RKEY            reduce using rule 73 (estat -> fcallvoid .)
    RETURN          reduce using rule 73 (estat -> fcallvoid .)


state 62

    (74) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (122) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (133) pushid -> .
    (124) existfunc -> .

    EQUAL           reduce using rule 133 (pushid -> .)
    LBRACE          reduce using rule 133 (pushid -> .)
    LPAREN          reduce using rule 124 (existfunc -> .)

    pushid                         shift and go to state 81
    existfunc                      shift and go to state 82

state 63

    (76) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 83


state 64

    (78) escrit -> PRINT . pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 84

state 65

    (84) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (143) while1 -> .

    LPAREN          reduce using rule 143 (while1 -> .)

    while1                         shift and go to state 85

state 66

    (85) leer -> READ . pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 86

state 67

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 87

state 68

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (58) mainc -> . LKEY RKEY
    (59) mainc -> . LKEY bloq RKEY
    (60) mainc -> . LKEY mainc2 bloq RKEY
    (61) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 88

state 69

    (26) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (41) addInTable -> .

    LPAREN          reduce using rule 41 (addInTable -> .)

    addInTable                     shift and go to state 89

state 70

    (27) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY bloq RKEY
    (41) addInTable -> .

    LPAREN          reduce using rule 41 (addInTable -> .)

    addInTable                     shift and go to state 90

state 71

    (21) vector -> VECTOR initvector INT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 91


state 72

    (22) vector -> VECTOR initvector FLOAT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 92


state 73

    (23) vector -> VECTOR initvector STRING ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 93


state 74

    (24) vector -> VECTOR initvector BOOL ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 94


state 75

    (59) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 59 (mainc -> LKEY bloq RKEY .)


state 76

    (60) mainc -> LKEY mainc2 bloq . RKEY

    RKEY            shift and go to state 95


state 77

    (61) mainc -> LKEY mainc2 RKEY .

    $end            reduce using rule 61 (mainc -> LKEY mainc2 RKEY .)


state 78

    (67) bloq -> estat bloq .

    RKEY            reduce using rule 67 (bloq -> estat bloq .)
    RETURN          reduce using rule 67 (bloq -> estat bloq .)


state 79

    (63) mainc2 -> var mainc2 .

    RKEY            reduce using rule 63 (mainc2 -> var mainc2 .)
    ID              reduce using rule 63 (mainc2 -> var mainc2 .)
    IF              reduce using rule 63 (mainc2 -> var mainc2 .)
    PRINT           reduce using rule 63 (mainc2 -> var mainc2 .)
    WHILE           reduce using rule 63 (mainc2 -> var mainc2 .)
    READ            reduce using rule 63 (mainc2 -> var mainc2 .)


state 80

    (65) mainc2 -> vector mainc2 .

    RKEY            reduce using rule 65 (mainc2 -> vector mainc2 .)
    ID              reduce using rule 65 (mainc2 -> vector mainc2 .)
    IF              reduce using rule 65 (mainc2 -> vector mainc2 .)
    PRINT           reduce using rule 65 (mainc2 -> vector mainc2 .)
    WHILE           reduce using rule 65 (mainc2 -> vector mainc2 .)
    READ            reduce using rule 65 (mainc2 -> vector mainc2 .)


state 81

    (74) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 96
    LBRACE          shift and go to state 97


state 82

    (122) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 98


state 83

    (76) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 100
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 84

    (78) escrit -> PRINT pushop . LPAREN imprimirl escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 117


state 85

    (84) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 118


state 86

    (85) leer -> READ pushop . LPAREN ID pushid readid RPAREN SEMICOLON

    LPAREN          shift and go to state 119


state 87

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (58) mainc -> . LKEY RKEY
    (59) mainc -> . LKEY bloq RKEY
    (60) mainc -> . LKEY mainc2 bloq RKEY
    (61) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 120

state 88

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 121

state 89

    (26) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 122


state 90

    (27) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY bloq RKEY

    LPAREN          shift and go to state 123


state 91

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 124


state 92

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 125


state 93

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 126


state 94

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 127


state 95

    (60) mainc -> LKEY mainc2 bloq RKEY .

    $end            reduce using rule 60 (mainc -> LKEY mainc2 bloq RKEY .)


state 96

    (74) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 128

state 97

    (75) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres SEMICOLON
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 129
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 98

    (122) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (125) startera -> .

    RPAREN          reduce using rule 125 (startera -> .)
    LPAREN          reduce using rule 125 (startera -> .)
    PLUS            reduce using rule 125 (startera -> .)
    MINUS           reduce using rule 125 (startera -> .)
    ID              reduce using rule 125 (startera -> .)
    CTE_I           reduce using rule 125 (startera -> .)
    CTE_F           reduce using rule 125 (startera -> .)
    CTE_S           reduce using rule 125 (startera -> .)
    TRUE            reduce using rule 125 (startera -> .)
    FALSE           reduce using rule 125 (startera -> .)

    startera                       shift and go to state 130

state 99

    (98) fact -> LPAREN . pushop expres RPAREN popop
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 131

state 100

    (76) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (77) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 132


state 101

    (87) expres -> exr .
    (88) expres -> exr . log expres reslog
    (108) log -> . OR
    (109) log -> . AND

    RPAREN          reduce using rule 87 (expres -> exr .)
    SEMICOLON       reduce using rule 87 (expres -> exr .)
    COMA            reduce using rule 87 (expres -> exr .)
    RBRACE          reduce using rule 87 (expres -> exr .)
    OR              shift and go to state 134
    AND             shift and go to state 135

    log                            shift and go to state 133

state 102

    (89) exr -> ex .
    (90) exr -> ex . rel exr resrel
    (102) rel -> . LOWERTHAN
    (103) rel -> . MORETHAN
    (104) rel -> . LOWEREQ
    (105) rel -> . MOREEQ
    (106) rel -> . SAME
    (107) rel -> . DIFFERENT

    OR              reduce using rule 89 (exr -> ex .)
    AND             reduce using rule 89 (exr -> ex .)
    RPAREN          reduce using rule 89 (exr -> ex .)
    RBRACE          reduce using rule 89 (exr -> ex .)
    SEMICOLON       reduce using rule 89 (exr -> ex .)
    COMA            reduce using rule 89 (exr -> ex .)
    LOWERTHAN       shift and go to state 137
    MORETHAN        shift and go to state 138
    LOWEREQ         shift and go to state 139
    MOREEQ          shift and go to state 140
    SAME            shift and go to state 141
    DIFFERENT       shift and go to state 142

    rel                            shift and go to state 136

state 103

    (92) ex -> term . resterm
    (93) ex -> term . resterm PLUS pushop ex
    (94) ex -> term . resterm MINUS pushop ex
    (138) resterm -> .

    PLUS            reduce using rule 138 (resterm -> .)
    MINUS           reduce using rule 138 (resterm -> .)
    LOWERTHAN       reduce using rule 138 (resterm -> .)
    MORETHAN        reduce using rule 138 (resterm -> .)
    LOWEREQ         reduce using rule 138 (resterm -> .)
    MOREEQ          reduce using rule 138 (resterm -> .)
    SAME            reduce using rule 138 (resterm -> .)
    DIFFERENT       reduce using rule 138 (resterm -> .)
    OR              reduce using rule 138 (resterm -> .)
    AND             reduce using rule 138 (resterm -> .)
    RPAREN          reduce using rule 138 (resterm -> .)
    RBRACE          reduce using rule 138 (resterm -> .)
    SEMICOLON       reduce using rule 138 (resterm -> .)
    COMA            reduce using rule 138 (resterm -> .)

    resterm                        shift and go to state 143

state 104

    (100) fact -> PLUS . var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 144
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 105

    (101) fact -> MINUS . var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 145
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 106

    (95) term -> fact . resfact
    (96) term -> fact . resfact TIMES pushop term
    (97) term -> fact . resfact DIVIDE pushop term
    (137) resfact -> .

    TIMES           reduce using rule 137 (resfact -> .)
    DIVIDE          reduce using rule 137 (resfact -> .)
    PLUS            reduce using rule 137 (resfact -> .)
    MINUS           reduce using rule 137 (resfact -> .)
    LOWERTHAN       reduce using rule 137 (resfact -> .)
    MORETHAN        reduce using rule 137 (resfact -> .)
    LOWEREQ         reduce using rule 137 (resfact -> .)
    MOREEQ          reduce using rule 137 (resfact -> .)
    SAME            reduce using rule 137 (resfact -> .)
    DIFFERENT       reduce using rule 137 (resfact -> .)
    OR              reduce using rule 137 (resfact -> .)
    AND             reduce using rule 137 (resfact -> .)
    RPAREN          reduce using rule 137 (resfact -> .)
    RBRACE          reduce using rule 137 (resfact -> .)
    SEMICOLON       reduce using rule 137 (resfact -> .)
    COMA            reduce using rule 137 (resfact -> .)

    resfact                        shift and go to state 146

state 107

    (99) fact -> var_cte .

    TIMES           reduce using rule 99 (fact -> var_cte .)
    DIVIDE          reduce using rule 99 (fact -> var_cte .)
    PLUS            reduce using rule 99 (fact -> var_cte .)
    MINUS           reduce using rule 99 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 99 (fact -> var_cte .)
    MORETHAN        reduce using rule 99 (fact -> var_cte .)
    LOWEREQ         reduce using rule 99 (fact -> var_cte .)
    MOREEQ          reduce using rule 99 (fact -> var_cte .)
    SAME            reduce using rule 99 (fact -> var_cte .)
    DIFFERENT       reduce using rule 99 (fact -> var_cte .)
    OR              reduce using rule 99 (fact -> var_cte .)
    AND             reduce using rule 99 (fact -> var_cte .)
    RPAREN          reduce using rule 99 (fact -> var_cte .)
    RBRACE          reduce using rule 99 (fact -> var_cte .)
    SEMICOLON       reduce using rule 99 (fact -> var_cte .)
    COMA            reduce using rule 99 (fact -> var_cte .)


state 108

    (110) var_cte -> ID . pushid
    (120) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> ID . existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> ID . LBRACE expres RBRACE
    (119) asigvector -> ID . pushid LBRACE ex RBRACE
    (133) pushid -> .
    (124) existfunc -> .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 149
    TIMES           reduce using rule 133 (pushid -> .)
    DIVIDE          reduce using rule 133 (pushid -> .)
    PLUS            reduce using rule 133 (pushid -> .)
    MINUS           reduce using rule 133 (pushid -> .)
    LOWERTHAN       reduce using rule 133 (pushid -> .)
    MORETHAN        reduce using rule 133 (pushid -> .)
    LOWEREQ         reduce using rule 133 (pushid -> .)
    MOREEQ          reduce using rule 133 (pushid -> .)
    SAME            reduce using rule 133 (pushid -> .)
    DIFFERENT       reduce using rule 133 (pushid -> .)
    OR              reduce using rule 133 (pushid -> .)
    AND             reduce using rule 133 (pushid -> .)
    RPAREN          reduce using rule 133 (pushid -> .)
    RBRACE          reduce using rule 133 (pushid -> .)
    SEMICOLON       reduce using rule 133 (pushid -> .)
    COMA            reduce using rule 133 (pushid -> .)
    LPAREN          reduce using rule 124 (existfunc -> .)

  ! LBRACE          [ reduce using rule 133 (pushid -> .) ]

    pushid                         shift and go to state 147
    existfunc                      shift and go to state 148

state 109

    (111) var_cte -> CTE_I . pushcte
    (132) pushcte -> .

    TIMES           reduce using rule 132 (pushcte -> .)
    DIVIDE          reduce using rule 132 (pushcte -> .)
    PLUS            reduce using rule 132 (pushcte -> .)
    MINUS           reduce using rule 132 (pushcte -> .)
    LOWERTHAN       reduce using rule 132 (pushcte -> .)
    MORETHAN        reduce using rule 132 (pushcte -> .)
    LOWEREQ         reduce using rule 132 (pushcte -> .)
    MOREEQ          reduce using rule 132 (pushcte -> .)
    SAME            reduce using rule 132 (pushcte -> .)
    DIFFERENT       reduce using rule 132 (pushcte -> .)
    OR              reduce using rule 132 (pushcte -> .)
    AND             reduce using rule 132 (pushcte -> .)
    RPAREN          reduce using rule 132 (pushcte -> .)
    RBRACE          reduce using rule 132 (pushcte -> .)
    SEMICOLON       reduce using rule 132 (pushcte -> .)
    COMA            reduce using rule 132 (pushcte -> .)

    pushcte                        shift and go to state 150

state 110

    (112) var_cte -> CTE_F . pushcte
    (132) pushcte -> .

    TIMES           reduce using rule 132 (pushcte -> .)
    DIVIDE          reduce using rule 132 (pushcte -> .)
    PLUS            reduce using rule 132 (pushcte -> .)
    MINUS           reduce using rule 132 (pushcte -> .)
    LOWERTHAN       reduce using rule 132 (pushcte -> .)
    MORETHAN        reduce using rule 132 (pushcte -> .)
    LOWEREQ         reduce using rule 132 (pushcte -> .)
    MOREEQ          reduce using rule 132 (pushcte -> .)
    SAME            reduce using rule 132 (pushcte -> .)
    DIFFERENT       reduce using rule 132 (pushcte -> .)
    OR              reduce using rule 132 (pushcte -> .)
    AND             reduce using rule 132 (pushcte -> .)
    RPAREN          reduce using rule 132 (pushcte -> .)
    RBRACE          reduce using rule 132 (pushcte -> .)
    SEMICOLON       reduce using rule 132 (pushcte -> .)
    COMA            reduce using rule 132 (pushcte -> .)

    pushcte                        shift and go to state 151

state 111

    (113) var_cte -> CTE_S . pushcte
    (132) pushcte -> .

    TIMES           reduce using rule 132 (pushcte -> .)
    DIVIDE          reduce using rule 132 (pushcte -> .)
    PLUS            reduce using rule 132 (pushcte -> .)
    MINUS           reduce using rule 132 (pushcte -> .)
    LOWERTHAN       reduce using rule 132 (pushcte -> .)
    MORETHAN        reduce using rule 132 (pushcte -> .)
    LOWEREQ         reduce using rule 132 (pushcte -> .)
    MOREEQ          reduce using rule 132 (pushcte -> .)
    SAME            reduce using rule 132 (pushcte -> .)
    DIFFERENT       reduce using rule 132 (pushcte -> .)
    OR              reduce using rule 132 (pushcte -> .)
    AND             reduce using rule 132 (pushcte -> .)
    RPAREN          reduce using rule 132 (pushcte -> .)
    RBRACE          reduce using rule 132 (pushcte -> .)
    SEMICOLON       reduce using rule 132 (pushcte -> .)
    COMA            reduce using rule 132 (pushcte -> .)

    pushcte                        shift and go to state 152

state 112

    (114) var_cte -> TRUE . pushcte
    (132) pushcte -> .

    TIMES           reduce using rule 132 (pushcte -> .)
    DIVIDE          reduce using rule 132 (pushcte -> .)
    PLUS            reduce using rule 132 (pushcte -> .)
    MINUS           reduce using rule 132 (pushcte -> .)
    LOWERTHAN       reduce using rule 132 (pushcte -> .)
    MORETHAN        reduce using rule 132 (pushcte -> .)
    LOWEREQ         reduce using rule 132 (pushcte -> .)
    MOREEQ          reduce using rule 132 (pushcte -> .)
    SAME            reduce using rule 132 (pushcte -> .)
    DIFFERENT       reduce using rule 132 (pushcte -> .)
    OR              reduce using rule 132 (pushcte -> .)
    AND             reduce using rule 132 (pushcte -> .)
    RPAREN          reduce using rule 132 (pushcte -> .)
    RBRACE          reduce using rule 132 (pushcte -> .)
    SEMICOLON       reduce using rule 132 (pushcte -> .)
    COMA            reduce using rule 132 (pushcte -> .)

    pushcte                        shift and go to state 153

state 113

    (115) var_cte -> FALSE . pushcte
    (132) pushcte -> .

    TIMES           reduce using rule 132 (pushcte -> .)
    DIVIDE          reduce using rule 132 (pushcte -> .)
    PLUS            reduce using rule 132 (pushcte -> .)
    MINUS           reduce using rule 132 (pushcte -> .)
    LOWERTHAN       reduce using rule 132 (pushcte -> .)
    MORETHAN        reduce using rule 132 (pushcte -> .)
    LOWEREQ         reduce using rule 132 (pushcte -> .)
    MOREEQ          reduce using rule 132 (pushcte -> .)
    SAME            reduce using rule 132 (pushcte -> .)
    DIFFERENT       reduce using rule 132 (pushcte -> .)
    OR              reduce using rule 132 (pushcte -> .)
    AND             reduce using rule 132 (pushcte -> .)
    RPAREN          reduce using rule 132 (pushcte -> .)
    RBRACE          reduce using rule 132 (pushcte -> .)
    SEMICOLON       reduce using rule 132 (pushcte -> .)
    COMA            reduce using rule 132 (pushcte -> .)

    pushcte                        shift and go to state 154

state 114

    (116) var_cte -> fcall .

    TIMES           reduce using rule 116 (var_cte -> fcall .)
    DIVIDE          reduce using rule 116 (var_cte -> fcall .)
    PLUS            reduce using rule 116 (var_cte -> fcall .)
    MINUS           reduce using rule 116 (var_cte -> fcall .)
    LOWERTHAN       reduce using rule 116 (var_cte -> fcall .)
    MORETHAN        reduce using rule 116 (var_cte -> fcall .)
    LOWEREQ         reduce using rule 116 (var_cte -> fcall .)
    MOREEQ          reduce using rule 116 (var_cte -> fcall .)
    SAME            reduce using rule 116 (var_cte -> fcall .)
    DIFFERENT       reduce using rule 116 (var_cte -> fcall .)
    OR              reduce using rule 116 (var_cte -> fcall .)
    AND             reduce using rule 116 (var_cte -> fcall .)
    RPAREN          reduce using rule 116 (var_cte -> fcall .)
    RBRACE          reduce using rule 116 (var_cte -> fcall .)
    SEMICOLON       reduce using rule 116 (var_cte -> fcall .)
    COMA            reduce using rule 116 (var_cte -> fcall .)


state 115

    (117) var_cte -> vcall .

    TIMES           reduce using rule 117 (var_cte -> vcall .)
    DIVIDE          reduce using rule 117 (var_cte -> vcall .)
    PLUS            reduce using rule 117 (var_cte -> vcall .)
    MINUS           reduce using rule 117 (var_cte -> vcall .)
    LOWERTHAN       reduce using rule 117 (var_cte -> vcall .)
    MORETHAN        reduce using rule 117 (var_cte -> vcall .)
    LOWEREQ         reduce using rule 117 (var_cte -> vcall .)
    MOREEQ          reduce using rule 117 (var_cte -> vcall .)
    SAME            reduce using rule 117 (var_cte -> vcall .)
    DIFFERENT       reduce using rule 117 (var_cte -> vcall .)
    OR              reduce using rule 117 (var_cte -> vcall .)
    AND             reduce using rule 117 (var_cte -> vcall .)
    RPAREN          reduce using rule 117 (var_cte -> vcall .)
    RBRACE          reduce using rule 117 (var_cte -> vcall .)
    SEMICOLON       reduce using rule 117 (var_cte -> vcall .)
    COMA            reduce using rule 117 (var_cte -> vcall .)


state 116

    (118) var_cte -> asigvector .

    TIMES           reduce using rule 118 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 118 (var_cte -> asigvector .)
    PLUS            reduce using rule 118 (var_cte -> asigvector .)
    MINUS           reduce using rule 118 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 118 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 118 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 118 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 118 (var_cte -> asigvector .)
    SAME            reduce using rule 118 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 118 (var_cte -> asigvector .)
    OR              reduce using rule 118 (var_cte -> asigvector .)
    AND             reduce using rule 118 (var_cte -> asigvector .)
    RPAREN          reduce using rule 118 (var_cte -> asigvector .)
    RBRACE          reduce using rule 118 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 118 (var_cte -> asigvector .)
    COMA            reduce using rule 118 (var_cte -> asigvector .)


state 117

    (78) escrit -> PRINT pushop LPAREN . imprimirl escriti RPAREN SEMICOLON
    (81) imprimirl -> .

    LPAREN          reduce using rule 81 (imprimirl -> .)
    PLUS            reduce using rule 81 (imprimirl -> .)
    MINUS           reduce using rule 81 (imprimirl -> .)
    ID              reduce using rule 81 (imprimirl -> .)
    CTE_I           reduce using rule 81 (imprimirl -> .)
    CTE_F           reduce using rule 81 (imprimirl -> .)
    CTE_S           reduce using rule 81 (imprimirl -> .)
    TRUE            reduce using rule 81 (imprimirl -> .)
    FALSE           reduce using rule 81 (imprimirl -> .)

    imprimirl                      shift and go to state 155

state 118

    (84) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 156
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 119

    (85) leer -> READ pushop LPAREN . ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 157


state 120

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 158

state 121

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 122

    (26) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 160
    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164

  ! RPAREN          [ reduce using rule 131 (empty -> .) ]

    funci                          shift and go to state 159
    empty                          shift and go to state 165

state 123

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY bloq RKEY
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 167
    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164

  ! RPAREN          [ reduce using rule 131 (empty -> .) ]

    funci                          shift and go to state 166
    empty                          shift and go to state 165

state 124

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 125

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 169


state 126

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 170


state 127

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 171


state 128

    (74) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 172
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 129

    (75) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres SEMICOLON

    RBRACE          shift and go to state 173


state 130

    (122) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (126) fcall1 -> . expres generateparam
    (127) fcall1 -> . expres generateparam COMA fcall1
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 175
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 174
    expres                         shift and go to state 176
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 131

    (98) fact -> LPAREN pushop . expres RPAREN popop
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 177
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 132

    (76) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (77) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 178


state 133

    (88) expres -> exr log . expres reslog
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 179
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 134

    (108) log -> OR .

    LPAREN          reduce using rule 108 (log -> OR .)
    PLUS            reduce using rule 108 (log -> OR .)
    MINUS           reduce using rule 108 (log -> OR .)
    ID              reduce using rule 108 (log -> OR .)
    CTE_I           reduce using rule 108 (log -> OR .)
    CTE_F           reduce using rule 108 (log -> OR .)
    CTE_S           reduce using rule 108 (log -> OR .)
    TRUE            reduce using rule 108 (log -> OR .)
    FALSE           reduce using rule 108 (log -> OR .)


state 135

    (109) log -> AND .

    LPAREN          reduce using rule 109 (log -> AND .)
    PLUS            reduce using rule 109 (log -> AND .)
    MINUS           reduce using rule 109 (log -> AND .)
    ID              reduce using rule 109 (log -> AND .)
    CTE_I           reduce using rule 109 (log -> AND .)
    CTE_F           reduce using rule 109 (log -> AND .)
    CTE_S           reduce using rule 109 (log -> AND .)
    TRUE            reduce using rule 109 (log -> AND .)
    FALSE           reduce using rule 109 (log -> AND .)


state 136

    (90) exr -> ex rel . exr resrel
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 102
    exr                            shift and go to state 180
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 137

    (102) rel -> LOWERTHAN .

    LPAREN          reduce using rule 102 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 102 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 102 (rel -> LOWERTHAN .)
    ID              reduce using rule 102 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 102 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 102 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 102 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 102 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 102 (rel -> LOWERTHAN .)


state 138

    (103) rel -> MORETHAN .

    LPAREN          reduce using rule 103 (rel -> MORETHAN .)
    PLUS            reduce using rule 103 (rel -> MORETHAN .)
    MINUS           reduce using rule 103 (rel -> MORETHAN .)
    ID              reduce using rule 103 (rel -> MORETHAN .)
    CTE_I           reduce using rule 103 (rel -> MORETHAN .)
    CTE_F           reduce using rule 103 (rel -> MORETHAN .)
    CTE_S           reduce using rule 103 (rel -> MORETHAN .)
    TRUE            reduce using rule 103 (rel -> MORETHAN .)
    FALSE           reduce using rule 103 (rel -> MORETHAN .)


state 139

    (104) rel -> LOWEREQ .

    LPAREN          reduce using rule 104 (rel -> LOWEREQ .)
    PLUS            reduce using rule 104 (rel -> LOWEREQ .)
    MINUS           reduce using rule 104 (rel -> LOWEREQ .)
    ID              reduce using rule 104 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 104 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 104 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 104 (rel -> LOWEREQ .)
    TRUE            reduce using rule 104 (rel -> LOWEREQ .)
    FALSE           reduce using rule 104 (rel -> LOWEREQ .)


state 140

    (105) rel -> MOREEQ .

    LPAREN          reduce using rule 105 (rel -> MOREEQ .)
    PLUS            reduce using rule 105 (rel -> MOREEQ .)
    MINUS           reduce using rule 105 (rel -> MOREEQ .)
    ID              reduce using rule 105 (rel -> MOREEQ .)
    CTE_I           reduce using rule 105 (rel -> MOREEQ .)
    CTE_F           reduce using rule 105 (rel -> MOREEQ .)
    CTE_S           reduce using rule 105 (rel -> MOREEQ .)
    TRUE            reduce using rule 105 (rel -> MOREEQ .)
    FALSE           reduce using rule 105 (rel -> MOREEQ .)


state 141

    (106) rel -> SAME .

    LPAREN          reduce using rule 106 (rel -> SAME .)
    PLUS            reduce using rule 106 (rel -> SAME .)
    MINUS           reduce using rule 106 (rel -> SAME .)
    ID              reduce using rule 106 (rel -> SAME .)
    CTE_I           reduce using rule 106 (rel -> SAME .)
    CTE_F           reduce using rule 106 (rel -> SAME .)
    CTE_S           reduce using rule 106 (rel -> SAME .)
    TRUE            reduce using rule 106 (rel -> SAME .)
    FALSE           reduce using rule 106 (rel -> SAME .)


state 142

    (107) rel -> DIFFERENT .

    LPAREN          reduce using rule 107 (rel -> DIFFERENT .)
    PLUS            reduce using rule 107 (rel -> DIFFERENT .)
    MINUS           reduce using rule 107 (rel -> DIFFERENT .)
    ID              reduce using rule 107 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 107 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 107 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 107 (rel -> DIFFERENT .)
    TRUE            reduce using rule 107 (rel -> DIFFERENT .)
    FALSE           reduce using rule 107 (rel -> DIFFERENT .)


state 143

    (92) ex -> term resterm .
    (93) ex -> term resterm . PLUS pushop ex
    (94) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 92 (ex -> term resterm .)
    MORETHAN        reduce using rule 92 (ex -> term resterm .)
    LOWEREQ         reduce using rule 92 (ex -> term resterm .)
    MOREEQ          reduce using rule 92 (ex -> term resterm .)
    SAME            reduce using rule 92 (ex -> term resterm .)
    DIFFERENT       reduce using rule 92 (ex -> term resterm .)
    OR              reduce using rule 92 (ex -> term resterm .)
    AND             reduce using rule 92 (ex -> term resterm .)
    RPAREN          reduce using rule 92 (ex -> term resterm .)
    RBRACE          reduce using rule 92 (ex -> term resterm .)
    SEMICOLON       reduce using rule 92 (ex -> term resterm .)
    COMA            reduce using rule 92 (ex -> term resterm .)
    PLUS            shift and go to state 181
    MINUS           shift and go to state 182


state 144

    (100) fact -> PLUS var_cte .

    TIMES           reduce using rule 100 (fact -> PLUS var_cte .)
    DIVIDE          reduce using rule 100 (fact -> PLUS var_cte .)
    PLUS            reduce using rule 100 (fact -> PLUS var_cte .)
    MINUS           reduce using rule 100 (fact -> PLUS var_cte .)
    LOWERTHAN       reduce using rule 100 (fact -> PLUS var_cte .)
    MORETHAN        reduce using rule 100 (fact -> PLUS var_cte .)
    LOWEREQ         reduce using rule 100 (fact -> PLUS var_cte .)
    MOREEQ          reduce using rule 100 (fact -> PLUS var_cte .)
    SAME            reduce using rule 100 (fact -> PLUS var_cte .)
    DIFFERENT       reduce using rule 100 (fact -> PLUS var_cte .)
    OR              reduce using rule 100 (fact -> PLUS var_cte .)
    AND             reduce using rule 100 (fact -> PLUS var_cte .)
    RPAREN          reduce using rule 100 (fact -> PLUS var_cte .)
    RBRACE          reduce using rule 100 (fact -> PLUS var_cte .)
    SEMICOLON       reduce using rule 100 (fact -> PLUS var_cte .)
    COMA            reduce using rule 100 (fact -> PLUS var_cte .)


state 145

    (101) fact -> MINUS var_cte .

    TIMES           reduce using rule 101 (fact -> MINUS var_cte .)
    DIVIDE          reduce using rule 101 (fact -> MINUS var_cte .)
    PLUS            reduce using rule 101 (fact -> MINUS var_cte .)
    MINUS           reduce using rule 101 (fact -> MINUS var_cte .)
    LOWERTHAN       reduce using rule 101 (fact -> MINUS var_cte .)
    MORETHAN        reduce using rule 101 (fact -> MINUS var_cte .)
    LOWEREQ         reduce using rule 101 (fact -> MINUS var_cte .)
    MOREEQ          reduce using rule 101 (fact -> MINUS var_cte .)
    SAME            reduce using rule 101 (fact -> MINUS var_cte .)
    DIFFERENT       reduce using rule 101 (fact -> MINUS var_cte .)
    OR              reduce using rule 101 (fact -> MINUS var_cte .)
    AND             reduce using rule 101 (fact -> MINUS var_cte .)
    RPAREN          reduce using rule 101 (fact -> MINUS var_cte .)
    RBRACE          reduce using rule 101 (fact -> MINUS var_cte .)
    SEMICOLON       reduce using rule 101 (fact -> MINUS var_cte .)
    COMA            reduce using rule 101 (fact -> MINUS var_cte .)


state 146

    (95) term -> fact resfact .
    (96) term -> fact resfact . TIMES pushop term
    (97) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 95 (term -> fact resfact .)
    MINUS           reduce using rule 95 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 95 (term -> fact resfact .)
    MORETHAN        reduce using rule 95 (term -> fact resfact .)
    LOWEREQ         reduce using rule 95 (term -> fact resfact .)
    MOREEQ          reduce using rule 95 (term -> fact resfact .)
    SAME            reduce using rule 95 (term -> fact resfact .)
    DIFFERENT       reduce using rule 95 (term -> fact resfact .)
    OR              reduce using rule 95 (term -> fact resfact .)
    AND             reduce using rule 95 (term -> fact resfact .)
    RPAREN          reduce using rule 95 (term -> fact resfact .)
    RBRACE          reduce using rule 95 (term -> fact resfact .)
    SEMICOLON       reduce using rule 95 (term -> fact resfact .)
    COMA            reduce using rule 95 (term -> fact resfact .)
    TIMES           shift and go to state 183
    DIVIDE          shift and go to state 184


state 147

    (110) var_cte -> ID pushid .
    (119) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 110 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 110 (var_cte -> ID pushid .)
    PLUS            reduce using rule 110 (var_cte -> ID pushid .)
    MINUS           reduce using rule 110 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 110 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 110 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 110 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 110 (var_cte -> ID pushid .)
    SAME            reduce using rule 110 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 110 (var_cte -> ID pushid .)
    OR              reduce using rule 110 (var_cte -> ID pushid .)
    AND             reduce using rule 110 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 110 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 110 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 110 (var_cte -> ID pushid .)
    COMA            reduce using rule 110 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 185


state 148

    (120) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> ID existfunc . LPAREN startera RPAREN generateGoSub

    LPAREN          shift and go to state 186


state 149

    (130) vcall -> ID LBRACE . expres RBRACE
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 187
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 150

    (111) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 111 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 111 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 111 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 111 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 111 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 111 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 111 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 111 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 111 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 111 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 111 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 111 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 111 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 111 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 111 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 111 (var_cte -> CTE_I pushcte .)


state 151

    (112) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 112 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 112 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 112 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 112 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 112 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 112 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 112 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 112 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 112 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 112 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 112 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 112 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 112 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 112 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 112 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 112 (var_cte -> CTE_F pushcte .)


state 152

    (113) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 113 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 113 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 113 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 113 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 113 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 113 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 113 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 113 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 113 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 113 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 113 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 113 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 113 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 113 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 113 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 113 (var_cte -> CTE_S pushcte .)


state 153

    (114) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 114 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 114 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 114 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 114 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 114 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 114 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 114 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 114 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 114 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 114 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 114 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 114 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 114 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 114 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 114 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 114 (var_cte -> TRUE pushcte .)


state 154

    (115) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 115 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 115 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 115 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 115 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 115 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 115 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 115 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 115 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 115 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 115 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 115 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 115 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 115 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 115 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 115 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 115 (var_cte -> FALSE pushcte .)


state 155

    (78) escrit -> PRINT pushop LPAREN imprimirl . escriti RPAREN SEMICOLON
    (79) escriti -> . expres escrit1
    (80) escriti -> . expres escrit2 COMA escriti
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    escriti                        shift and go to state 188
    expres                         shift and go to state 189
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 156

    (84) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 190


state 157

    (85) leer -> READ pushop LPAREN ID . pushid readid RPAREN SEMICOLON
    (133) pushid -> .

    RPAREN          reduce using rule 133 (pushid -> .)

    pushid                         shift and go to state 191

state 158

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 159

    (26) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 RKEY

    RPAREN          shift and go to state 192


state 160

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 193


state 161

    (42) funci -> INT . ID
    (43) funci -> INT . ID COMA funci

    ID              shift and go to state 194


state 162

    (44) funci -> FLOAT . ID
    (45) funci -> FLOAT . ID COMA funci

    ID              shift and go to state 195


state 163

    (46) funci -> STRING . ID
    (47) funci -> STRING . ID COMA funci

    ID              shift and go to state 196


state 164

    (48) funci -> BOOL . ID
    (49) funci -> BOOL . ID COMA funci

    ID              shift and go to state 197


state 165

    (50) funci -> empty .

    RPAREN          reduce using rule 50 (funci -> empty .)


state 166

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY bloq RKEY

    RPAREN          shift and go to state 198


state 167

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 199


state 168

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 169

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 170

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)


state 171

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)


state 172

    (74) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (136) resolverasignacion -> .

    SEMICOLON       reduce using rule 136 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 200

state 173

    (75) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 201


state 174

    (122) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 202


state 175

    (123) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 203


state 176

    (126) fcall1 -> expres . generateparam
    (127) fcall1 -> expres . generateparam COMA fcall1
    (128) generateparam -> .

    COMA            reduce using rule 128 (generateparam -> .)
    RPAREN          reduce using rule 128 (generateparam -> .)

    generateparam                  shift and go to state 204

state 177

    (98) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 205


state 178

    (76) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (77) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (140) resif -> .

    ID              reduce using rule 140 (resif -> .)
    IF              reduce using rule 140 (resif -> .)
    PRINT           reduce using rule 140 (resif -> .)
    WHILE           reduce using rule 140 (resif -> .)
    READ            reduce using rule 140 (resif -> .)

    resif                          shift and go to state 206

state 179

    (88) expres -> exr log expres . reslog
    (91) reslog -> .

    RPAREN          reduce using rule 91 (reslog -> .)
    SEMICOLON       reduce using rule 91 (reslog -> .)
    COMA            reduce using rule 91 (reslog -> .)
    RBRACE          reduce using rule 91 (reslog -> .)

    reslog                         shift and go to state 207

state 180

    (90) exr -> ex rel exr . resrel
    (139) resrel -> .

    OR              reduce using rule 139 (resrel -> .)
    AND             reduce using rule 139 (resrel -> .)
    RPAREN          reduce using rule 139 (resrel -> .)
    RBRACE          reduce using rule 139 (resrel -> .)
    SEMICOLON       reduce using rule 139 (resrel -> .)
    COMA            reduce using rule 139 (resrel -> .)

    resrel                         shift and go to state 208

state 181

    (93) ex -> term resterm PLUS . pushop ex
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 209

state 182

    (94) ex -> term resterm MINUS . pushop ex
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 210

state 183

    (96) term -> fact resfact TIMES . pushop term
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 211

state 184

    (97) term -> fact resfact DIVIDE . pushop term
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 212

state 185

    (119) asigvector -> ID pushid LBRACE . ex RBRACE
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 213
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 186

    (120) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN generateGoSub
    (121) fcall -> ID existfunc LPAREN . startera RPAREN generateGoSub
    (125) startera -> .

    RPAREN          reduce using rule 125 (startera -> .)
    LPAREN          reduce using rule 125 (startera -> .)
    PLUS            reduce using rule 125 (startera -> .)
    MINUS           reduce using rule 125 (startera -> .)
    ID              reduce using rule 125 (startera -> .)
    CTE_I           reduce using rule 125 (startera -> .)
    CTE_F           reduce using rule 125 (startera -> .)
    CTE_S           reduce using rule 125 (startera -> .)
    TRUE            reduce using rule 125 (startera -> .)
    FALSE           reduce using rule 125 (startera -> .)

    startera                       shift and go to state 214

state 187

    (130) vcall -> ID LBRACE expres . RBRACE

    RBRACE          shift and go to state 215


state 188

    (78) escrit -> PRINT pushop LPAREN imprimirl escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 216


state 189

    (79) escriti -> expres . escrit1
    (80) escriti -> expres . escrit2 COMA escriti
    (82) escrit1 -> .
    (83) escrit2 -> .

    RPAREN          reduce using rule 82 (escrit1 -> .)
    COMA            reduce using rule 83 (escrit2 -> .)

    escrit1                        shift and go to state 217
    escrit2                        shift and go to state 218

state 190

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (144) while2 -> .

    LKEY            reduce using rule 144 (while2 -> .)

    while2                         shift and go to state 219

state 191

    (85) leer -> READ pushop LPAREN ID pushid . readid RPAREN SEMICOLON
    (86) readid -> .

    RPAREN          reduce using rule 86 (readid -> .)

    readid                         shift and go to state 220

state 192

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 RKEY

    LKEY            shift and go to state 221


state 193

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 223
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 222
    bloq                           shift and go to state 224
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 194

    (42) funci -> INT ID .
    (43) funci -> INT ID . COMA funci

    RPAREN          reduce using rule 42 (funci -> INT ID .)
    COMA            shift and go to state 227


state 195

    (44) funci -> FLOAT ID .
    (45) funci -> FLOAT ID . COMA funci

    RPAREN          reduce using rule 44 (funci -> FLOAT ID .)
    COMA            shift and go to state 228


state 196

    (46) funci -> STRING ID .
    (47) funci -> STRING ID . COMA funci

    RPAREN          reduce using rule 46 (funci -> STRING ID .)
    COMA            shift and go to state 229


state 197

    (48) funci -> BOOL ID .
    (49) funci -> BOOL ID . COMA funci

    RPAREN          reduce using rule 48 (funci -> BOOL ID .)
    COMA            shift and go to state 230


state 198

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 231


state 199

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . bloq RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 232
    bloq                           shift and go to state 233
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 200

    (74) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 234


state 201

    (75) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres SEMICOLON
    (134) pushop -> .

    LPAREN          reduce using rule 134 (pushop -> .)
    PLUS            reduce using rule 134 (pushop -> .)
    MINUS           reduce using rule 134 (pushop -> .)
    ID              reduce using rule 134 (pushop -> .)
    CTE_I           reduce using rule 134 (pushop -> .)
    CTE_F           reduce using rule 134 (pushop -> .)
    CTE_S           reduce using rule 134 (pushop -> .)
    TRUE            reduce using rule 134 (pushop -> .)
    FALSE           reduce using rule 134 (pushop -> .)

    pushop                         shift and go to state 235

state 202

    (122) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 236


state 203

    (123) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

    ID              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)


state 204

    (126) fcall1 -> expres generateparam .
    (127) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 126 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 237


state 205

    (98) fact -> LPAREN pushop expres RPAREN . popop
    (135) popop -> .

    TIMES           reduce using rule 135 (popop -> .)
    DIVIDE          reduce using rule 135 (popop -> .)
    PLUS            reduce using rule 135 (popop -> .)
    MINUS           reduce using rule 135 (popop -> .)
    LOWERTHAN       reduce using rule 135 (popop -> .)
    MORETHAN        reduce using rule 135 (popop -> .)
    LOWEREQ         reduce using rule 135 (popop -> .)
    MOREEQ          reduce using rule 135 (popop -> .)
    SAME            reduce using rule 135 (popop -> .)
    DIFFERENT       reduce using rule 135 (popop -> .)
    OR              reduce using rule 135 (popop -> .)
    AND             reduce using rule 135 (popop -> .)
    RPAREN          reduce using rule 135 (popop -> .)
    RBRACE          reduce using rule 135 (popop -> .)
    SEMICOLON       reduce using rule 135 (popop -> .)
    COMA            reduce using rule 135 (popop -> .)

    popop                          shift and go to state 238

state 206

    (76) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (77) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 239
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 207

    (88) expres -> exr log expres reslog .

    RPAREN          reduce using rule 88 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 88 (expres -> exr log expres reslog .)
    COMA            reduce using rule 88 (expres -> exr log expres reslog .)
    RBRACE          reduce using rule 88 (expres -> exr log expres reslog .)


state 208

    (90) exr -> ex rel exr resrel .

    OR              reduce using rule 90 (exr -> ex rel exr resrel .)
    AND             reduce using rule 90 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 90 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 90 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 90 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 90 (exr -> ex rel exr resrel .)


state 209

    (93) ex -> term resterm PLUS pushop . ex
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 240
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 210

    (94) ex -> term resterm MINUS pushop . ex
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 241
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 211

    (96) term -> fact resfact TIMES pushop . term
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 242
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 212

    (97) term -> fact resfact DIVIDE pushop . term
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 243
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 213

    (119) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 244


state 214

    (120) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN generateGoSub
    (121) fcall -> ID existfunc LPAREN startera . RPAREN generateGoSub
    (126) fcall1 -> . expres generateparam
    (127) fcall1 -> . expres generateparam COMA fcall1
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 246
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 245
    expres                         shift and go to state 176
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 215

    (130) vcall -> ID LBRACE expres RBRACE .

    TIMES           reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    DIVIDE          reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    PLUS            reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    MINUS           reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    LOWERTHAN       reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    MORETHAN        reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    LOWEREQ         reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    MOREEQ          reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    SAME            reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    DIFFERENT       reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    OR              reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    AND             reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    RPAREN          reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    RBRACE          reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    SEMICOLON       reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)
    COMA            reduce using rule 130 (vcall -> ID LBRACE expres RBRACE .)


state 216

    (78) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 247


state 217

    (79) escriti -> expres escrit1 .

    RPAREN          reduce using rule 79 (escriti -> expres escrit1 .)


state 218

    (80) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 248


state 219

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 249


state 220

    (85) leer -> READ pushop LPAREN ID pushid readid . RPAREN SEMICOLON

    RPAREN          shift and go to state 250


state 221

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    localvar                       shift and go to state 251
    var                            shift and go to state 225
    vector                         shift and go to state 226

state 222

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 252
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 253
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 223

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 224

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq . return1 RKEY
    (55) return1 -> . RETURN expres resreturn SEMICOLON
    (56) return1 -> . empty
    (131) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 131 (empty -> .)

    return1                        shift and go to state 254
    empty                          shift and go to state 256

state 225

    (51) localvar -> var .
    (53) localvar -> var . localvar
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 51 (localvar -> var .)
    ID              reduce using rule 51 (localvar -> var .)
    IF              reduce using rule 51 (localvar -> var .)
    PRINT           reduce using rule 51 (localvar -> var .)
    WHILE           reduce using rule 51 (localvar -> var .)
    READ            reduce using rule 51 (localvar -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 225
    localvar                       shift and go to state 257
    vector                         shift and go to state 226

state 226

    (52) localvar -> vector .
    (54) localvar -> vector . localvar
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 52 (localvar -> vector .)
    ID              reduce using rule 52 (localvar -> vector .)
    IF              reduce using rule 52 (localvar -> vector .)
    PRINT           reduce using rule 52 (localvar -> vector .)
    WHILE           reduce using rule 52 (localvar -> vector .)
    READ            reduce using rule 52 (localvar -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 226
    localvar                       shift and go to state 258
    var                            shift and go to state 225

state 227

    (43) funci -> INT ID COMA . funci
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 131 (empty -> .)

    funci                          shift and go to state 259
    empty                          shift and go to state 165

state 228

    (45) funci -> FLOAT ID COMA . funci
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 131 (empty -> .)

    funci                          shift and go to state 260
    empty                          shift and go to state 165

state 229

    (47) funci -> STRING ID COMA . funci
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 131 (empty -> .)

    funci                          shift and go to state 261
    empty                          shift and go to state 165

state 230

    (49) funci -> BOOL ID COMA . funci
    (42) funci -> . INT ID
    (43) funci -> . INT ID COMA funci
    (44) funci -> . FLOAT ID
    (45) funci -> . FLOAT ID COMA funci
    (46) funci -> . STRING ID
    (47) funci -> . STRING ID COMA funci
    (48) funci -> . BOOL ID
    (49) funci -> . BOOL ID COMA funci
    (50) funci -> . empty
    (131) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 131 (empty -> .)

    funci                          shift and go to state 262
    empty                          shift and go to state 165

state 231

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . bloq RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 263
    bloq                           shift and go to state 264
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 232

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 265
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 266
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 233

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 267


state 234

    (74) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 74 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 235

    (75) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres SEMICOLON
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 268
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 236

    (122) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

    ID              reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 122 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)


state 237

    (127) fcall1 -> expres generateparam COMA . fcall1
    (126) fcall1 -> . expres generateparam
    (127) fcall1 -> . expres generateparam COMA fcall1
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 176
    fcall1                         shift and go to state 269
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 238

    (98) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 98 (fact -> LPAREN pushop expres RPAREN popop .)


state 239

    (76) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 270


state 240

    (93) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 93 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 93 (ex -> term resterm PLUS pushop ex .)


state 241

    (94) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 94 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 94 (ex -> term resterm MINUS pushop ex .)


state 242

    (96) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 96 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 96 (term -> fact resfact TIMES pushop term .)


state 243

    (97) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 97 (term -> fact resfact DIVIDE pushop term .)


state 244

    (119) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 119 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 245

    (120) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN generateGoSub

    RPAREN          shift and go to state 271


state 246

    (121) fcall -> ID existfunc LPAREN startera RPAREN . generateGoSub
    (129) generateGoSub -> .

    TIMES           reduce using rule 129 (generateGoSub -> .)
    DIVIDE          reduce using rule 129 (generateGoSub -> .)
    PLUS            reduce using rule 129 (generateGoSub -> .)
    MINUS           reduce using rule 129 (generateGoSub -> .)
    LOWERTHAN       reduce using rule 129 (generateGoSub -> .)
    MORETHAN        reduce using rule 129 (generateGoSub -> .)
    LOWEREQ         reduce using rule 129 (generateGoSub -> .)
    MOREEQ          reduce using rule 129 (generateGoSub -> .)
    SAME            reduce using rule 129 (generateGoSub -> .)
    DIFFERENT       reduce using rule 129 (generateGoSub -> .)
    OR              reduce using rule 129 (generateGoSub -> .)
    AND             reduce using rule 129 (generateGoSub -> .)
    RPAREN          reduce using rule 129 (generateGoSub -> .)
    RBRACE          reduce using rule 129 (generateGoSub -> .)
    SEMICOLON       reduce using rule 129 (generateGoSub -> .)
    COMA            reduce using rule 129 (generateGoSub -> .)

    generateGoSub                  shift and go to state 272

state 247

    (78) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .

    ID              reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    IF              reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    READ            reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 78 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)


state 248

    (80) escriti -> expres escrit2 COMA . escriti
    (79) escriti -> . expres escrit1
    (80) escriti -> . expres escrit2 COMA escriti
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 189
    escriti                        shift and go to state 273
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 249

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 274
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 250

    (85) leer -> READ pushop LPAREN ID pushid readid RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 275


state 251

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 276
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 252

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 253

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 RKEY
    (55) return1 -> . RETURN expres resreturn SEMICOLON
    (56) return1 -> . empty
    (131) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 131 (empty -> .)

    return1                        shift and go to state 277
    empty                          shift and go to state 256

state 254

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 278


state 255

    (55) return1 -> RETURN . expres resreturn SEMICOLON
    (87) expres -> . exr
    (88) expres -> . exr log expres reslog
    (89) exr -> . ex
    (90) exr -> . ex rel exr resrel
    (92) ex -> . term resterm
    (93) ex -> . term resterm PLUS pushop ex
    (94) ex -> . term resterm MINUS pushop ex
    (95) term -> . fact resfact
    (96) term -> . fact resfact TIMES pushop term
    (97) term -> . fact resfact DIVIDE pushop term
    (98) fact -> . LPAREN pushop expres RPAREN popop
    (99) fact -> . var_cte
    (100) fact -> . PLUS var_cte
    (101) fact -> . MINUS var_cte
    (110) var_cte -> . ID pushid
    (111) var_cte -> . CTE_I pushcte
    (112) var_cte -> . CTE_F pushcte
    (113) var_cte -> . CTE_S pushcte
    (114) var_cte -> . TRUE pushcte
    (115) var_cte -> . FALSE pushcte
    (116) var_cte -> . fcall
    (117) var_cte -> . vcall
    (118) var_cte -> . asigvector
    (120) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (121) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (130) vcall -> . ID LBRACE expres RBRACE
    (119) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 279
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 256

    (56) return1 -> empty .

    RKEY            reduce using rule 56 (return1 -> empty .)


state 257

    (53) localvar -> var localvar .

    RKEY            reduce using rule 53 (localvar -> var localvar .)
    ID              reduce using rule 53 (localvar -> var localvar .)
    IF              reduce using rule 53 (localvar -> var localvar .)
    PRINT           reduce using rule 53 (localvar -> var localvar .)
    WHILE           reduce using rule 53 (localvar -> var localvar .)
    READ            reduce using rule 53 (localvar -> var localvar .)


state 258

    (54) localvar -> vector localvar .

    RKEY            reduce using rule 54 (localvar -> vector localvar .)
    ID              reduce using rule 54 (localvar -> vector localvar .)
    IF              reduce using rule 54 (localvar -> vector localvar .)
    PRINT           reduce using rule 54 (localvar -> vector localvar .)
    WHILE           reduce using rule 54 (localvar -> vector localvar .)
    READ            reduce using rule 54 (localvar -> vector localvar .)


state 259

    (43) funci -> INT ID COMA funci .

    RPAREN          reduce using rule 43 (funci -> INT ID COMA funci .)


state 260

    (45) funci -> FLOAT ID COMA funci .

    RPAREN          reduce using rule 45 (funci -> FLOAT ID COMA funci .)


state 261

    (47) funci -> STRING ID COMA funci .

    RPAREN          reduce using rule 47 (funci -> STRING ID COMA funci .)


state 262

    (49) funci -> BOOL ID COMA funci .

    RPAREN          reduce using rule 49 (funci -> BOOL ID COMA funci .)


state 263

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 280
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 264

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 281


state 265

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 266

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 282


state 267

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)


state 268

    (75) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . SEMICOLON

    SEMICOLON       shift and go to state 283


state 269

    (127) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 127 (fcall1 -> expres generateparam COMA fcall1 .)


state 270

    (76) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (142) finif -> .

    ELSE            shift and go to state 285
    ID              reduce using rule 142 (finif -> .)
    IF              reduce using rule 142 (finif -> .)
    PRINT           reduce using rule 142 (finif -> .)
    WHILE           reduce using rule 142 (finif -> .)
    READ            reduce using rule 142 (finif -> .)
    RKEY            reduce using rule 142 (finif -> .)
    RETURN          reduce using rule 142 (finif -> .)

    finif                          shift and go to state 284

state 271

    (120) fcall -> ID existfunc LPAREN startera fcall1 RPAREN . generateGoSub
    (129) generateGoSub -> .

    TIMES           reduce using rule 129 (generateGoSub -> .)
    DIVIDE          reduce using rule 129 (generateGoSub -> .)
    PLUS            reduce using rule 129 (generateGoSub -> .)
    MINUS           reduce using rule 129 (generateGoSub -> .)
    LOWERTHAN       reduce using rule 129 (generateGoSub -> .)
    MORETHAN        reduce using rule 129 (generateGoSub -> .)
    LOWEREQ         reduce using rule 129 (generateGoSub -> .)
    MOREEQ          reduce using rule 129 (generateGoSub -> .)
    SAME            reduce using rule 129 (generateGoSub -> .)
    DIFFERENT       reduce using rule 129 (generateGoSub -> .)
    OR              reduce using rule 129 (generateGoSub -> .)
    AND             reduce using rule 129 (generateGoSub -> .)
    RPAREN          reduce using rule 129 (generateGoSub -> .)
    RBRACE          reduce using rule 129 (generateGoSub -> .)
    SEMICOLON       reduce using rule 129 (generateGoSub -> .)
    COMA            reduce using rule 129 (generateGoSub -> .)

    generateGoSub                  shift and go to state 286

state 272

    (121) fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .

    TIMES           reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    DIVIDE          reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    PLUS            reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MINUS           reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    LOWERTHAN       reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MORETHAN        reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    LOWEREQ         reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MOREEQ          reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    SAME            reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    DIFFERENT       reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    OR              reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    AND             reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    RPAREN          reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    RBRACE          reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    SEMICOLON       reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    COMA            reduce using rule 121 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)


state 273

    (80) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 80 (escriti -> expres escrit2 COMA escriti .)


state 274

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 287


state 275

    (85) leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .

    ID              reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    IF              reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    PRINT           reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    WHILE           reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    READ            reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RKEY            reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RETURN          reduce using rule 85 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)


state 276

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 RKEY
    (55) return1 -> . RETURN expres resreturn SEMICOLON
    (56) return1 -> . empty
    (131) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 131 (empty -> .)

    return1                        shift and go to state 288
    empty                          shift and go to state 256

state 277

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 289


state 278

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)


state 279

    (55) return1 -> RETURN expres . resreturn SEMICOLON
    (57) resreturn -> .

    SEMICOLON       reduce using rule 57 (resreturn -> .)

    resreturn                      shift and go to state 290

state 280

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 291


state 281

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)


state 282

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 283

    (75) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .

    ID              reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    IF              reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    PRINT           reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    WHILE           reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    READ            reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RKEY            reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RETURN          reduce using rule 75 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)


state 284

    (76) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 76 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 285

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 292


state 286

    (120) fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .

    TIMES           reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIVIDE          reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    PLUS            reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MINUS           reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWERTHAN       reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MORETHAN        reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWEREQ         reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MOREEQ          reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SAME            reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIFFERENT       reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    OR              reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    AND             reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RPAREN          reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RBRACE          reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SEMICOLON       reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    COMA            reduce using rule 120 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)


state 287

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (145) while3 -> .

    ID              reduce using rule 145 (while3 -> .)
    IF              reduce using rule 145 (while3 -> .)
    PRINT           reduce using rule 145 (while3 -> .)
    WHILE           reduce using rule 145 (while3 -> .)
    READ            reduce using rule 145 (while3 -> .)
    RKEY            reduce using rule 145 (while3 -> .)
    RETURN          reduce using rule 145 (while3 -> .)

    while3                         shift and go to state 293

state 288

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 294


state 289

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)


state 290

    (55) return1 -> RETURN expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 295


state 291

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 292

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (141) reselse -> .

    ID              reduce using rule 141 (reselse -> .)
    IF              reduce using rule 141 (reselse -> .)
    PRINT           reduce using rule 141 (reselse -> .)
    WHILE           reduce using rule 141 (reselse -> .)
    READ            reduce using rule 141 (reselse -> .)

    reselse                        shift and go to state 296

state 293

    (84) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 84 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 294

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)


state 295

    (55) return1 -> RETURN expres resreturn SEMICOLON .

    RKEY            reduce using rule 55 (return1 -> RETURN expres resreturn SEMICOLON .)


state 296

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (66) bloq -> . estat
    (67) bloq -> . estat bloq
    (68) estat -> . asign
    (69) estat -> . cond
    (70) estat -> . escrit
    (71) estat -> . ciclo
    (72) estat -> . leer
    (73) estat -> . fcallvoid
    (74) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (75) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (76) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (78) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (84) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (85) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (122) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 297
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 297

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 298


state 298

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (142) finif -> .

    ID              reduce using rule 142 (finif -> .)
    IF              reduce using rule 142 (finif -> .)
    PRINT           reduce using rule 142 (finif -> .)
    WHILE           reduce using rule 142 (finif -> .)
    READ            reduce using rule 142 (finif -> .)
    RKEY            reduce using rule 142 (finif -> .)
    RETURN          reduce using rule 142 (finif -> .)

    finif                          shift and go to state 299

state 299

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 108 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 122 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 123 resolved as shift
