Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 4     gotomain -> <empty>
Rule 5     program2 -> crear program2
Rule 6     program2 -> crear
Rule 7     program3 -> function program3
Rule 8     program3 -> function
Rule 9     llenarmain -> <empty>
Rule 10    crear -> var
Rule 11    crear -> vector
Rule 12    global -> <empty>
Rule 13    finglobal -> <empty>
Rule 14    main1 -> <empty>
Rule 15    finmain -> <empty>
Rule 16    var -> VAR tipo ID SEMICOLON
Rule 17    tipo -> INT
Rule 18    tipo -> FLOAT
Rule 19    tipo -> STRING
Rule 20    tipo -> BOOL
Rule 21    vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 22    vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
Rule 24    vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
Rule 25    initvector -> <empty>
Rule 26    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
Rule 27    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 28    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
Rule 29    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 30    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 31    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
Rule 32    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 33    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
Rule 34    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
Rule 35    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 36    functype -> INT
Rule 37    functype -> FLOAT
Rule 38    functype -> STRING
Rule 39    functype -> BOOL
Rule 40    pushvoid -> VOID
Rule 41    addInTable -> <empty>
Rule 42    funci -> INT ID sumparam
Rule 43    funci -> INT ID sumparam COMA funci
Rule 44    funci -> FLOAT ID sumparam
Rule 45    funci -> FLOAT ID sumparam COMA funci
Rule 46    funci -> STRING ID sumparam
Rule 47    funci -> STRING ID sumparam COMA funci
Rule 48    funci -> BOOL ID sumparam
Rule 49    funci -> BOOL ID sumparam COMA funci
Rule 50    funci -> empty
Rule 51    localvar -> var
Rule 52    localvar -> vector
Rule 53    localvar -> var localvar
Rule 54    localvar -> vector localvar
Rule 55    sumparam -> <empty>
Rule 56    return1 -> RETURN expres resreturn SEMICOLON
Rule 57    return1 -> empty
Rule 58    resreturn -> <empty>
Rule 59    mainc -> LKEY RKEY
Rule 60    mainc -> LKEY bloq RKEY
Rule 61    mainc -> LKEY mainc2 bloq RKEY
Rule 62    mainc -> LKEY mainc2 RKEY
Rule 63    mainc2 -> var
Rule 64    mainc2 -> var mainc2
Rule 65    mainc2 -> vector
Rule 66    mainc2 -> vector mainc2
Rule 67    bloq -> estat
Rule 68    bloq -> estat bloq
Rule 69    estat -> asign
Rule 70    estat -> cond
Rule 71    estat -> escrit
Rule 72    estat -> ciclo
Rule 73    estat -> leer
Rule 74    estat -> fcallvoid
Rule 75    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 76    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
Rule 77    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 78    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 79    escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
Rule 80    escriti -> expres escrit1
Rule 81    escriti -> expres escrit2 COMA escriti
Rule 82    imprimirl -> <empty>
Rule 83    escrit1 -> <empty>
Rule 84    escrit2 -> <empty>
Rule 85    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 86    leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
Rule 87    readid -> <empty>
Rule 88    expres -> exr
Rule 89    expres -> exr log expres reslog
Rule 90    exr -> ex
Rule 91    exr -> ex rel exr resrel
Rule 92    reslog -> <empty>
Rule 93    ex -> term resterm
Rule 94    ex -> term resterm PLUS pushop ex
Rule 95    ex -> term resterm MINUS pushop ex
Rule 96    term -> fact resfact
Rule 97    term -> fact resfact TIMES pushop term
Rule 98    term -> fact resfact DIVIDE pushop term
Rule 99    fact -> LPAREN pushop expres RPAREN popop
Rule 100   fact -> var_cte
Rule 101   fact -> PLUS var_cte
Rule 102   fact -> MINUS var_cte
Rule 103   rel -> LOWERTHAN
Rule 104   rel -> MORETHAN
Rule 105   rel -> LOWEREQ
Rule 106   rel -> MOREEQ
Rule 107   rel -> SAME
Rule 108   rel -> DIFFERENT
Rule 109   log -> OR
Rule 110   log -> AND
Rule 111   var_cte -> ID pushid
Rule 112   var_cte -> CTE_I pushcte
Rule 113   var_cte -> CTE_F pushcte
Rule 114   var_cte -> CTE_S pushcte
Rule 115   var_cte -> TRUE pushcte
Rule 116   var_cte -> FALSE pushcte
Rule 117   var_cte -> fcall
Rule 118   var_cte -> vcall
Rule 119   var_cte -> asigvector
Rule 120   asigvector -> ID pushid LBRACE ex RBRACE
Rule 121   fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
Rule 122   fcall -> ID existfunc LPAREN startera RPAREN generateGoSub
Rule 123   fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 124   fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 125   existfunc -> <empty>
Rule 126   startera -> <empty>
Rule 127   fcall1 -> expres generateparam
Rule 128   fcall1 -> expres generateparam COMA fcall1
Rule 129   generateparam -> <empty>
Rule 130   generateGoSub -> <empty>
Rule 131   vcall -> ID LBRACE expres RBRACE
Rule 132   empty -> <empty>
Rule 133   pushcte -> <empty>
Rule 134   pushid -> <empty>
Rule 135   pushop -> <empty>
Rule 136   popop -> <empty>
Rule 137   resolverasignacion -> <empty>
Rule 138   resfact -> <empty>
Rule 139   resterm -> <empty>
Rule 140   resrel -> <empty>
Rule 141   resif -> <empty>
Rule 142   reselse -> <empty>
Rule 143   finif -> <empty>
Rule 144   while1 -> <empty>
Rule 145   while2 -> <empty>
Rule 146   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 110
BOOL                 : 20 24 39 48 49
COLON                : 1 2 3
COMA                 : 43 45 47 49 81 128
CTE_F                : 113
CTE_I                : 21 22 23 24 112
CTE_S                : 114
DIFFERENT            : 108
DIVIDE               : 98
ELSE                 : 78
EQUAL                : 75 76
FALSE                : 116
FLOAT                : 18 22 37 44 45
FUNCTION             : 26 27 28 29 30 31 32 33 34 35
ID                   : 16 21 22 23 24 26 27 28 29 30 31 32 33 34 35 42 43 44 45 46 47 48 49 75 76 86 111 120 121 122 123 124 131
IF                   : 77 78
INT                  : 17 21 36 42 43
LBRACE               : 21 22 23 24 76 120 131
LKEY                 : 26 27 28 29 30 31 32 33 34 35 59 60 61 62 77 78 78 85
LOWEREQ              : 105
LOWERTHAN            : 103
LPAREN               : 26 27 28 29 30 31 32 33 34 35 77 78 79 85 86 99 121 122 123 124
MAIN                 : 1 2 3
MINUS                : 95 102
MOREEQ               : 106
MORETHAN             : 104
OR                   : 109
PLUS                 : 94 101
PRINT                : 79
PROGRAM              : 1 2 3
RBRACE               : 21 22 23 24 76 120 131
READ                 : 86
RETURN               : 56
RKEY                 : 26 27 28 29 30 31 32 33 34 35 59 60 61 62 77 78 78 85
RPAREN               : 26 27 28 29 30 31 32 33 34 35 77 78 79 85 86 99 121 122 123 124
SAME                 : 107
SEMICOLON            : 16 21 22 23 24 56 75 76 79 86 123 124
STRING               : 19 23 38 46 47
TIMES                : 97
TRUE                 : 115
VAR                  : 16
VECTOR               : 21 22 23 24
VOID                 : 40
WHILE                : 85
error                : 

Nonterminals, with rules where they appear

addInTable           : 26 27 28 29 30 31 32 33 34 35
asign                : 69
asigvector           : 119
bloq                 : 26 27 28 31 32 33 34 60 61 68 77 78 78 85
ciclo                : 72
cond                 : 70
crear                : 5 6
empty                : 50 57
escrit               : 71
escrit1              : 80
escrit2              : 81
escriti              : 79 81
estat                : 67 68
ex                   : 90 91 94 95 120
existfunc            : 121 122 123 124
expres               : 56 75 76 77 78 80 81 85 89 99 127 128 131
exr                  : 76 88 89 91
fact                 : 96 97 98
fcall                : 117
fcall1               : 121 123 128
fcallvoid            : 74
finglobal            : 1 2
finif                : 77 78
finmain              : 1 2 3
funci                : 26 27 28 43 45 47 49
function             : 7 8
functype             : 26 29 31 34 35
generateGoSub        : 121 122
generateparam        : 127 128
global               : 1 2
gotomain             : 1 2 3
imprimirl            : 79
initvector           : 21 22 23 24
leer                 : 73
llenarmain           : 1 2 3
localvar             : 26 27 29 30 31 32 53 54
log                  : 89
main1                : 1 2 3
mainc                : 1 2 3
mainc2               : 61 62 64 66
popop                : 99
program              : 0
program2             : 1 2 5
program3             : 1 7
pushcte              : 112 113 114 115 116
pushid               : 75 76 86 111 120
pushop               : 75 76 79 86 94 95 97 98 99
pushvoid             : 27 28 30 32 33
readid               : 86
rel                  : 91
reselse              : 78
resfact              : 96 97 98
resif                : 77 78
reslog               : 89
resolverasignacion   : 75
resrel               : 91
resreturn            : 56
resterm              : 93 94 95
return1              : 26 31 34
startera             : 121 122 123 124
sumparam             : 42 43 44 45 46 47 48 49
term                 : 93 94 95 97 98
tipo                 : 16
var                  : 10 51 53 63 64
var_cte              : 100 101 102
vcall                : 118
vector               : 11 52 54 65 66
while1               : 85
while2               : 85
while3               : 85

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (4) gotomain -> .

    VAR             reduce using rule 4 (gotomain -> .)
    VECTOR          reduce using rule 4 (gotomain -> .)
    MAIN            reduce using rule 4 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (12) global -> .
    (9) llenarmain -> .

    VAR             reduce using rule 12 (global -> .)
    VECTOR          reduce using rule 12 (global -> .)
    MAIN            reduce using rule 9 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    program2                       shift and go to state 7
    crear                          shift and go to state 8
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 6

    (3) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 13


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (13) finglobal -> .

    FUNCTION        reduce using rule 13 (finglobal -> .)
    MAIN            reduce using rule 13 (finglobal -> .)

    finglobal                      shift and go to state 14

state 8

    (5) program2 -> crear . program2
    (6) program2 -> crear .
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 6 (program2 -> crear .)
    MAIN            reduce using rule 6 (program2 -> crear .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    crear                          shift and go to state 8
    program2                       shift and go to state 15
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 9

    (10) crear -> var .

    VAR             reduce using rule 10 (crear -> var .)
    VECTOR          reduce using rule 10 (crear -> var .)
    FUNCTION        reduce using rule 10 (crear -> var .)
    MAIN            reduce using rule 10 (crear -> var .)


state 10

    (11) crear -> vector .

    VAR             reduce using rule 11 (crear -> vector .)
    VECTOR          reduce using rule 11 (crear -> vector .)
    FUNCTION        reduce using rule 11 (crear -> vector .)
    MAIN            reduce using rule 11 (crear -> vector .)


state 11

    (16) var -> VAR . tipo ID SEMICOLON
    (17) tipo -> . INT
    (18) tipo -> . FLOAT
    (19) tipo -> . STRING
    (20) tipo -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    BOOL            shift and go to state 20

    tipo                           shift and go to state 16

state 12

    (21) vector -> VECTOR . initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR . initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR . initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR . initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (25) initvector -> .

    INT             reduce using rule 25 (initvector -> .)
    FLOAT           reduce using rule 25 (initvector -> .)
    STRING          reduce using rule 25 (initvector -> .)
    BOOL            reduce using rule 25 (initvector -> .)

    initvector                     shift and go to state 21

state 13

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 22

state 14

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (7) program3 -> . function program3
    (8) program3 -> . function
    (9) llenarmain -> .
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (llenarmain -> .)
    FUNCTION        shift and go to state 26

    program3                       shift and go to state 23
    llenarmain                     shift and go to state 24
    function                       shift and go to state 25

state 15

    (5) program2 -> crear program2 .

    FUNCTION        reduce using rule 5 (program2 -> crear program2 .)
    MAIN            reduce using rule 5 (program2 -> crear program2 .)


state 16

    (16) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 27


state 17

    (17) tipo -> INT .

    ID              reduce using rule 17 (tipo -> INT .)


state 18

    (18) tipo -> FLOAT .

    ID              reduce using rule 18 (tipo -> FLOAT .)


state 19

    (19) tipo -> STRING .

    ID              reduce using rule 19 (tipo -> STRING .)


state 20

    (20) tipo -> BOOL .

    ID              reduce using rule 20 (tipo -> BOOL .)


state 21

    (21) vector -> VECTOR initvector . INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR initvector . FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR initvector . STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR initvector . BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31


state 22

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (59) mainc -> . LKEY RKEY
    (60) mainc -> . LKEY bloq RKEY
    (61) mainc -> . LKEY mainc2 bloq RKEY
    (62) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 32

state 23

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (9) llenarmain -> .

    MAIN            reduce using rule 9 (llenarmain -> .)

    llenarmain                     shift and go to state 34

state 24

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 35


state 25

    (7) program3 -> function . program3
    (8) program3 -> function .
    (7) program3 -> . function program3
    (8) program3 -> . function
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 8 (program3 -> function .)
    FUNCTION        shift and go to state 26

    function                       shift and go to state 25
    program3                       shift and go to state 36

state 26

    (26) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (32) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (34) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (36) functype -> . INT
    (37) functype -> . FLOAT
    (38) functype -> . STRING
    (39) functype -> . BOOL
    (40) pushvoid -> . VOID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STRING          shift and go to state 41
    BOOL            shift and go to state 42
    VOID            shift and go to state 43

    functype                       shift and go to state 37
    pushvoid                       shift and go to state 38

state 27

    (16) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 44


state 28

    (21) vector -> VECTOR initvector INT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 45


state 29

    (22) vector -> VECTOR initvector FLOAT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 46


state 30

    (23) vector -> VECTOR initvector STRING . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 47


state 31

    (24) vector -> VECTOR initvector BOOL . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 48


state 32

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 49

state 33

    (59) mainc -> LKEY . RKEY
    (60) mainc -> LKEY . bloq RKEY
    (61) mainc -> LKEY . mainc2 bloq RKEY
    (62) mainc -> LKEY . mainc2 RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (63) mainc2 -> . var
    (64) mainc2 -> . var mainc2
    (65) mainc2 -> . vector
    (66) mainc2 -> . vector mainc2
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 50
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 51
    mainc2                         shift and go to state 52
    estat                          shift and go to state 53
    var                            shift and go to state 54
    vector                         shift and go to state 55
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 34

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 67


state 35

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 68

state 36

    (7) program3 -> function program3 .

    MAIN            reduce using rule 7 (program3 -> function program3 .)


state 37

    (26) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 69


state 38

    (27) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY bloq RKEY

    ID              shift and go to state 70


state 39

    (36) functype -> INT .

    ID              reduce using rule 36 (functype -> INT .)


state 40

    (37) functype -> FLOAT .

    ID              reduce using rule 37 (functype -> FLOAT .)


state 41

    (38) functype -> STRING .

    ID              reduce using rule 38 (functype -> STRING .)


state 42

    (39) functype -> BOOL .

    ID              reduce using rule 39 (functype -> BOOL .)


state 43

    (40) pushvoid -> VOID .

    ID              reduce using rule 40 (pushvoid -> VOID .)


state 44

    (16) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)


state 45

    (21) vector -> VECTOR initvector INT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 71


state 46

    (22) vector -> VECTOR initvector FLOAT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 72


state 47

    (23) vector -> VECTOR initvector STRING ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 73


state 48

    (24) vector -> VECTOR initvector BOOL ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 74


state 49

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 50

    (59) mainc -> LKEY RKEY .

    $end            reduce using rule 59 (mainc -> LKEY RKEY .)


state 51

    (60) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 75


state 52

    (61) mainc -> LKEY mainc2 . bloq RKEY
    (62) mainc -> LKEY mainc2 . RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 77
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 76
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 53

    (67) bloq -> estat .
    (68) bloq -> estat . bloq
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            reduce using rule 67 (bloq -> estat .)
    RETURN          reduce using rule 67 (bloq -> estat .)
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    estat                          shift and go to state 53
    bloq                           shift and go to state 78
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 54

    (63) mainc2 -> var .
    (64) mainc2 -> var . mainc2
    (63) mainc2 -> . var
    (64) mainc2 -> . var mainc2
    (65) mainc2 -> . vector
    (66) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 63 (mainc2 -> var .)
    ID              reduce using rule 63 (mainc2 -> var .)
    IF              reduce using rule 63 (mainc2 -> var .)
    PRINT           reduce using rule 63 (mainc2 -> var .)
    WHILE           reduce using rule 63 (mainc2 -> var .)
    READ            reduce using rule 63 (mainc2 -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 54
    mainc2                         shift and go to state 79
    vector                         shift and go to state 55

state 55

    (65) mainc2 -> vector .
    (66) mainc2 -> vector . mainc2
    (63) mainc2 -> . var
    (64) mainc2 -> . var mainc2
    (65) mainc2 -> . vector
    (66) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 65 (mainc2 -> vector .)
    ID              reduce using rule 65 (mainc2 -> vector .)
    IF              reduce using rule 65 (mainc2 -> vector .)
    PRINT           reduce using rule 65 (mainc2 -> vector .)
    WHILE           reduce using rule 65 (mainc2 -> vector .)
    READ            reduce using rule 65 (mainc2 -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 55
    mainc2                         shift and go to state 80
    var                            shift and go to state 54

state 56

    (69) estat -> asign .

    ID              reduce using rule 69 (estat -> asign .)
    IF              reduce using rule 69 (estat -> asign .)
    PRINT           reduce using rule 69 (estat -> asign .)
    WHILE           reduce using rule 69 (estat -> asign .)
    READ            reduce using rule 69 (estat -> asign .)
    RKEY            reduce using rule 69 (estat -> asign .)
    RETURN          reduce using rule 69 (estat -> asign .)


state 57

    (70) estat -> cond .

    ID              reduce using rule 70 (estat -> cond .)
    IF              reduce using rule 70 (estat -> cond .)
    PRINT           reduce using rule 70 (estat -> cond .)
    WHILE           reduce using rule 70 (estat -> cond .)
    READ            reduce using rule 70 (estat -> cond .)
    RKEY            reduce using rule 70 (estat -> cond .)
    RETURN          reduce using rule 70 (estat -> cond .)


state 58

    (71) estat -> escrit .

    ID              reduce using rule 71 (estat -> escrit .)
    IF              reduce using rule 71 (estat -> escrit .)
    PRINT           reduce using rule 71 (estat -> escrit .)
    WHILE           reduce using rule 71 (estat -> escrit .)
    READ            reduce using rule 71 (estat -> escrit .)
    RKEY            reduce using rule 71 (estat -> escrit .)
    RETURN          reduce using rule 71 (estat -> escrit .)


state 59

    (72) estat -> ciclo .

    ID              reduce using rule 72 (estat -> ciclo .)
    IF              reduce using rule 72 (estat -> ciclo .)
    PRINT           reduce using rule 72 (estat -> ciclo .)
    WHILE           reduce using rule 72 (estat -> ciclo .)
    READ            reduce using rule 72 (estat -> ciclo .)
    RKEY            reduce using rule 72 (estat -> ciclo .)
    RETURN          reduce using rule 72 (estat -> ciclo .)


state 60

    (73) estat -> leer .

    ID              reduce using rule 73 (estat -> leer .)
    IF              reduce using rule 73 (estat -> leer .)
    PRINT           reduce using rule 73 (estat -> leer .)
    WHILE           reduce using rule 73 (estat -> leer .)
    READ            reduce using rule 73 (estat -> leer .)
    RKEY            reduce using rule 73 (estat -> leer .)
    RETURN          reduce using rule 73 (estat -> leer .)


state 61

    (74) estat -> fcallvoid .

    ID              reduce using rule 74 (estat -> fcallvoid .)
    IF              reduce using rule 74 (estat -> fcallvoid .)
    PRINT           reduce using rule 74 (estat -> fcallvoid .)
    WHILE           reduce using rule 74 (estat -> fcallvoid .)
    READ            reduce using rule 74 (estat -> fcallvoid .)
    RKEY            reduce using rule 74 (estat -> fcallvoid .)
    RETURN          reduce using rule 74 (estat -> fcallvoid .)


state 62

    (75) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (123) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (134) pushid -> .
    (125) existfunc -> .

    EQUAL           reduce using rule 134 (pushid -> .)
    LBRACE          reduce using rule 134 (pushid -> .)
    LPAREN          reduce using rule 125 (existfunc -> .)

    pushid                         shift and go to state 81
    existfunc                      shift and go to state 82

state 63

    (77) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 83


state 64

    (79) escrit -> PRINT . pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 84

state 65

    (85) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (144) while1 -> .

    LPAREN          reduce using rule 144 (while1 -> .)

    while1                         shift and go to state 85

state 66

    (86) leer -> READ . pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 86

state 67

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 87

state 68

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (59) mainc -> . LKEY RKEY
    (60) mainc -> . LKEY bloq RKEY
    (61) mainc -> . LKEY mainc2 bloq RKEY
    (62) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 88

state 69

    (26) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (41) addInTable -> .

    LPAREN          reduce using rule 41 (addInTable -> .)

    addInTable                     shift and go to state 89

state 70

    (27) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY bloq RKEY
    (41) addInTable -> .

    LPAREN          reduce using rule 41 (addInTable -> .)

    addInTable                     shift and go to state 90

state 71

    (21) vector -> VECTOR initvector INT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 91


state 72

    (22) vector -> VECTOR initvector FLOAT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 92


state 73

    (23) vector -> VECTOR initvector STRING ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 93


state 74

    (24) vector -> VECTOR initvector BOOL ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 94


state 75

    (60) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 60 (mainc -> LKEY bloq RKEY .)


state 76

    (61) mainc -> LKEY mainc2 bloq . RKEY

    RKEY            shift and go to state 95


state 77

    (62) mainc -> LKEY mainc2 RKEY .

    $end            reduce using rule 62 (mainc -> LKEY mainc2 RKEY .)


state 78

    (68) bloq -> estat bloq .

    RKEY            reduce using rule 68 (bloq -> estat bloq .)
    RETURN          reduce using rule 68 (bloq -> estat bloq .)


state 79

    (64) mainc2 -> var mainc2 .

    RKEY            reduce using rule 64 (mainc2 -> var mainc2 .)
    ID              reduce using rule 64 (mainc2 -> var mainc2 .)
    IF              reduce using rule 64 (mainc2 -> var mainc2 .)
    PRINT           reduce using rule 64 (mainc2 -> var mainc2 .)
    WHILE           reduce using rule 64 (mainc2 -> var mainc2 .)
    READ            reduce using rule 64 (mainc2 -> var mainc2 .)


state 80

    (66) mainc2 -> vector mainc2 .

    RKEY            reduce using rule 66 (mainc2 -> vector mainc2 .)
    ID              reduce using rule 66 (mainc2 -> vector mainc2 .)
    IF              reduce using rule 66 (mainc2 -> vector mainc2 .)
    PRINT           reduce using rule 66 (mainc2 -> vector mainc2 .)
    WHILE           reduce using rule 66 (mainc2 -> vector mainc2 .)
    READ            reduce using rule 66 (mainc2 -> vector mainc2 .)


state 81

    (75) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 96
    LBRACE          shift and go to state 97


state 82

    (123) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 98


state 83

    (77) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 100
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 84

    (79) escrit -> PRINT pushop . LPAREN imprimirl escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 117


state 85

    (85) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 118


state 86

    (86) leer -> READ pushop . LPAREN ID pushid readid RPAREN SEMICOLON

    LPAREN          shift and go to state 119


state 87

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (59) mainc -> . LKEY RKEY
    (60) mainc -> . LKEY bloq RKEY
    (61) mainc -> . LKEY mainc2 bloq RKEY
    (62) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 120

state 88

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 121

state 89

    (26) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 122


state 90

    (27) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY bloq RKEY

    LPAREN          shift and go to state 123


state 91

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 124


state 92

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 125


state 93

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 126


state 94

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 127


state 95

    (61) mainc -> LKEY mainc2 bloq RKEY .

    $end            reduce using rule 61 (mainc -> LKEY mainc2 bloq RKEY .)


state 96

    (75) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 128

state 97

    (76) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres SEMICOLON
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 129
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 98

    (123) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (126) startera -> .

    RPAREN          reduce using rule 126 (startera -> .)
    LPAREN          reduce using rule 126 (startera -> .)
    PLUS            reduce using rule 126 (startera -> .)
    MINUS           reduce using rule 126 (startera -> .)
    ID              reduce using rule 126 (startera -> .)
    CTE_I           reduce using rule 126 (startera -> .)
    CTE_F           reduce using rule 126 (startera -> .)
    CTE_S           reduce using rule 126 (startera -> .)
    TRUE            reduce using rule 126 (startera -> .)
    FALSE           reduce using rule 126 (startera -> .)

    startera                       shift and go to state 130

state 99

    (99) fact -> LPAREN . pushop expres RPAREN popop
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 131

state 100

    (77) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (78) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 132


state 101

    (88) expres -> exr .
    (89) expres -> exr . log expres reslog
    (109) log -> . OR
    (110) log -> . AND

    RPAREN          reduce using rule 88 (expres -> exr .)
    SEMICOLON       reduce using rule 88 (expres -> exr .)
    COMA            reduce using rule 88 (expres -> exr .)
    RBRACE          reduce using rule 88 (expres -> exr .)
    OR              shift and go to state 134
    AND             shift and go to state 135

    log                            shift and go to state 133

state 102

    (90) exr -> ex .
    (91) exr -> ex . rel exr resrel
    (103) rel -> . LOWERTHAN
    (104) rel -> . MORETHAN
    (105) rel -> . LOWEREQ
    (106) rel -> . MOREEQ
    (107) rel -> . SAME
    (108) rel -> . DIFFERENT

    OR              reduce using rule 90 (exr -> ex .)
    AND             reduce using rule 90 (exr -> ex .)
    RPAREN          reduce using rule 90 (exr -> ex .)
    RBRACE          reduce using rule 90 (exr -> ex .)
    SEMICOLON       reduce using rule 90 (exr -> ex .)
    COMA            reduce using rule 90 (exr -> ex .)
    LOWERTHAN       shift and go to state 137
    MORETHAN        shift and go to state 138
    LOWEREQ         shift and go to state 139
    MOREEQ          shift and go to state 140
    SAME            shift and go to state 141
    DIFFERENT       shift and go to state 142

    rel                            shift and go to state 136

state 103

    (93) ex -> term . resterm
    (94) ex -> term . resterm PLUS pushop ex
    (95) ex -> term . resterm MINUS pushop ex
    (139) resterm -> .

    PLUS            reduce using rule 139 (resterm -> .)
    MINUS           reduce using rule 139 (resterm -> .)
    LOWERTHAN       reduce using rule 139 (resterm -> .)
    MORETHAN        reduce using rule 139 (resterm -> .)
    LOWEREQ         reduce using rule 139 (resterm -> .)
    MOREEQ          reduce using rule 139 (resterm -> .)
    SAME            reduce using rule 139 (resterm -> .)
    DIFFERENT       reduce using rule 139 (resterm -> .)
    OR              reduce using rule 139 (resterm -> .)
    AND             reduce using rule 139 (resterm -> .)
    RPAREN          reduce using rule 139 (resterm -> .)
    RBRACE          reduce using rule 139 (resterm -> .)
    SEMICOLON       reduce using rule 139 (resterm -> .)
    COMA            reduce using rule 139 (resterm -> .)

    resterm                        shift and go to state 143

state 104

    (101) fact -> PLUS . var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 144
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 105

    (102) fact -> MINUS . var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 145
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 106

    (96) term -> fact . resfact
    (97) term -> fact . resfact TIMES pushop term
    (98) term -> fact . resfact DIVIDE pushop term
    (138) resfact -> .

    TIMES           reduce using rule 138 (resfact -> .)
    DIVIDE          reduce using rule 138 (resfact -> .)
    PLUS            reduce using rule 138 (resfact -> .)
    MINUS           reduce using rule 138 (resfact -> .)
    LOWERTHAN       reduce using rule 138 (resfact -> .)
    MORETHAN        reduce using rule 138 (resfact -> .)
    LOWEREQ         reduce using rule 138 (resfact -> .)
    MOREEQ          reduce using rule 138 (resfact -> .)
    SAME            reduce using rule 138 (resfact -> .)
    DIFFERENT       reduce using rule 138 (resfact -> .)
    OR              reduce using rule 138 (resfact -> .)
    AND             reduce using rule 138 (resfact -> .)
    RPAREN          reduce using rule 138 (resfact -> .)
    RBRACE          reduce using rule 138 (resfact -> .)
    SEMICOLON       reduce using rule 138 (resfact -> .)
    COMA            reduce using rule 138 (resfact -> .)

    resfact                        shift and go to state 146

state 107

    (100) fact -> var_cte .

    TIMES           reduce using rule 100 (fact -> var_cte .)
    DIVIDE          reduce using rule 100 (fact -> var_cte .)
    PLUS            reduce using rule 100 (fact -> var_cte .)
    MINUS           reduce using rule 100 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 100 (fact -> var_cte .)
    MORETHAN        reduce using rule 100 (fact -> var_cte .)
    LOWEREQ         reduce using rule 100 (fact -> var_cte .)
    MOREEQ          reduce using rule 100 (fact -> var_cte .)
    SAME            reduce using rule 100 (fact -> var_cte .)
    DIFFERENT       reduce using rule 100 (fact -> var_cte .)
    OR              reduce using rule 100 (fact -> var_cte .)
    AND             reduce using rule 100 (fact -> var_cte .)
    RPAREN          reduce using rule 100 (fact -> var_cte .)
    RBRACE          reduce using rule 100 (fact -> var_cte .)
    SEMICOLON       reduce using rule 100 (fact -> var_cte .)
    COMA            reduce using rule 100 (fact -> var_cte .)


state 108

    (111) var_cte -> ID . pushid
    (121) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> ID . existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> ID . LBRACE expres RBRACE
    (120) asigvector -> ID . pushid LBRACE ex RBRACE
    (134) pushid -> .
    (125) existfunc -> .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 149
    TIMES           reduce using rule 134 (pushid -> .)
    DIVIDE          reduce using rule 134 (pushid -> .)
    PLUS            reduce using rule 134 (pushid -> .)
    MINUS           reduce using rule 134 (pushid -> .)
    LOWERTHAN       reduce using rule 134 (pushid -> .)
    MORETHAN        reduce using rule 134 (pushid -> .)
    LOWEREQ         reduce using rule 134 (pushid -> .)
    MOREEQ          reduce using rule 134 (pushid -> .)
    SAME            reduce using rule 134 (pushid -> .)
    DIFFERENT       reduce using rule 134 (pushid -> .)
    OR              reduce using rule 134 (pushid -> .)
    AND             reduce using rule 134 (pushid -> .)
    RPAREN          reduce using rule 134 (pushid -> .)
    RBRACE          reduce using rule 134 (pushid -> .)
    SEMICOLON       reduce using rule 134 (pushid -> .)
    COMA            reduce using rule 134 (pushid -> .)
    LPAREN          reduce using rule 125 (existfunc -> .)

  ! LBRACE          [ reduce using rule 134 (pushid -> .) ]

    pushid                         shift and go to state 147
    existfunc                      shift and go to state 148

state 109

    (112) var_cte -> CTE_I . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 150

state 110

    (113) var_cte -> CTE_F . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 151

state 111

    (114) var_cte -> CTE_S . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 152

state 112

    (115) var_cte -> TRUE . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 153

state 113

    (116) var_cte -> FALSE . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 154

state 114

    (117) var_cte -> fcall .

    TIMES           reduce using rule 117 (var_cte -> fcall .)
    DIVIDE          reduce using rule 117 (var_cte -> fcall .)
    PLUS            reduce using rule 117 (var_cte -> fcall .)
    MINUS           reduce using rule 117 (var_cte -> fcall .)
    LOWERTHAN       reduce using rule 117 (var_cte -> fcall .)
    MORETHAN        reduce using rule 117 (var_cte -> fcall .)
    LOWEREQ         reduce using rule 117 (var_cte -> fcall .)
    MOREEQ          reduce using rule 117 (var_cte -> fcall .)
    SAME            reduce using rule 117 (var_cte -> fcall .)
    DIFFERENT       reduce using rule 117 (var_cte -> fcall .)
    OR              reduce using rule 117 (var_cte -> fcall .)
    AND             reduce using rule 117 (var_cte -> fcall .)
    RPAREN          reduce using rule 117 (var_cte -> fcall .)
    RBRACE          reduce using rule 117 (var_cte -> fcall .)
    SEMICOLON       reduce using rule 117 (var_cte -> fcall .)
    COMA            reduce using rule 117 (var_cte -> fcall .)


state 115

    (118) var_cte -> vcall .

    TIMES           reduce using rule 118 (var_cte -> vcall .)
    DIVIDE          reduce using rule 118 (var_cte -> vcall .)
    PLUS            reduce using rule 118 (var_cte -> vcall .)
    MINUS           reduce using rule 118 (var_cte -> vcall .)
    LOWERTHAN       reduce using rule 118 (var_cte -> vcall .)
    MORETHAN        reduce using rule 118 (var_cte -> vcall .)
    LOWEREQ         reduce using rule 118 (var_cte -> vcall .)
    MOREEQ          reduce using rule 118 (var_cte -> vcall .)
    SAME            reduce using rule 118 (var_cte -> vcall .)
    DIFFERENT       reduce using rule 118 (var_cte -> vcall .)
    OR              reduce using rule 118 (var_cte -> vcall .)
    AND             reduce using rule 118 (var_cte -> vcall .)
    RPAREN          reduce using rule 118 (var_cte -> vcall .)
    RBRACE          reduce using rule 118 (var_cte -> vcall .)
    SEMICOLON       reduce using rule 118 (var_cte -> vcall .)
    COMA            reduce using rule 118 (var_cte -> vcall .)


state 116

    (119) var_cte -> asigvector .

    TIMES           reduce using rule 119 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 119 (var_cte -> asigvector .)
    PLUS            reduce using rule 119 (var_cte -> asigvector .)
    MINUS           reduce using rule 119 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 119 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 119 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 119 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 119 (var_cte -> asigvector .)
    SAME            reduce using rule 119 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 119 (var_cte -> asigvector .)
    OR              reduce using rule 119 (var_cte -> asigvector .)
    AND             reduce using rule 119 (var_cte -> asigvector .)
    RPAREN          reduce using rule 119 (var_cte -> asigvector .)
    RBRACE          reduce using rule 119 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 119 (var_cte -> asigvector .)
    COMA            reduce using rule 119 (var_cte -> asigvector .)


state 117

    (79) escrit -> PRINT pushop LPAREN . imprimirl escriti RPAREN SEMICOLON
    (82) imprimirl -> .

    LPAREN          reduce using rule 82 (imprimirl -> .)
    PLUS            reduce using rule 82 (imprimirl -> .)
    MINUS           reduce using rule 82 (imprimirl -> .)
    ID              reduce using rule 82 (imprimirl -> .)
    CTE_I           reduce using rule 82 (imprimirl -> .)
    CTE_F           reduce using rule 82 (imprimirl -> .)
    CTE_S           reduce using rule 82 (imprimirl -> .)
    TRUE            reduce using rule 82 (imprimirl -> .)
    FALSE           reduce using rule 82 (imprimirl -> .)

    imprimirl                      shift and go to state 155

state 118

    (85) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 156
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 119

    (86) leer -> READ pushop LPAREN . ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 157


state 120

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 158

state 121

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 122

    (26) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 160
    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164

  ! RPAREN          [ reduce using rule 132 (empty -> .) ]

    funci                          shift and go to state 159
    empty                          shift and go to state 165

state 123

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY bloq RKEY
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 167
    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164

  ! RPAREN          [ reduce using rule 132 (empty -> .) ]

    funci                          shift and go to state 166
    empty                          shift and go to state 165

state 124

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 125

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 169


state 126

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 170


state 127

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 171


state 128

    (75) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 172
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 129

    (76) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres SEMICOLON

    RBRACE          shift and go to state 173


state 130

    (123) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 175
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 174
    expres                         shift and go to state 176
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 131

    (99) fact -> LPAREN pushop . expres RPAREN popop
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 177
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 132

    (77) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (78) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 178


state 133

    (89) expres -> exr log . expres reslog
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 179
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 134

    (109) log -> OR .

    LPAREN          reduce using rule 109 (log -> OR .)
    PLUS            reduce using rule 109 (log -> OR .)
    MINUS           reduce using rule 109 (log -> OR .)
    ID              reduce using rule 109 (log -> OR .)
    CTE_I           reduce using rule 109 (log -> OR .)
    CTE_F           reduce using rule 109 (log -> OR .)
    CTE_S           reduce using rule 109 (log -> OR .)
    TRUE            reduce using rule 109 (log -> OR .)
    FALSE           reduce using rule 109 (log -> OR .)


state 135

    (110) log -> AND .

    LPAREN          reduce using rule 110 (log -> AND .)
    PLUS            reduce using rule 110 (log -> AND .)
    MINUS           reduce using rule 110 (log -> AND .)
    ID              reduce using rule 110 (log -> AND .)
    CTE_I           reduce using rule 110 (log -> AND .)
    CTE_F           reduce using rule 110 (log -> AND .)
    CTE_S           reduce using rule 110 (log -> AND .)
    TRUE            reduce using rule 110 (log -> AND .)
    FALSE           reduce using rule 110 (log -> AND .)


state 136

    (91) exr -> ex rel . exr resrel
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 102
    exr                            shift and go to state 180
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 137

    (103) rel -> LOWERTHAN .

    LPAREN          reduce using rule 103 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 103 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 103 (rel -> LOWERTHAN .)
    ID              reduce using rule 103 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 103 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 103 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 103 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 103 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 103 (rel -> LOWERTHAN .)


state 138

    (104) rel -> MORETHAN .

    LPAREN          reduce using rule 104 (rel -> MORETHAN .)
    PLUS            reduce using rule 104 (rel -> MORETHAN .)
    MINUS           reduce using rule 104 (rel -> MORETHAN .)
    ID              reduce using rule 104 (rel -> MORETHAN .)
    CTE_I           reduce using rule 104 (rel -> MORETHAN .)
    CTE_F           reduce using rule 104 (rel -> MORETHAN .)
    CTE_S           reduce using rule 104 (rel -> MORETHAN .)
    TRUE            reduce using rule 104 (rel -> MORETHAN .)
    FALSE           reduce using rule 104 (rel -> MORETHAN .)


state 139

    (105) rel -> LOWEREQ .

    LPAREN          reduce using rule 105 (rel -> LOWEREQ .)
    PLUS            reduce using rule 105 (rel -> LOWEREQ .)
    MINUS           reduce using rule 105 (rel -> LOWEREQ .)
    ID              reduce using rule 105 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 105 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 105 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 105 (rel -> LOWEREQ .)
    TRUE            reduce using rule 105 (rel -> LOWEREQ .)
    FALSE           reduce using rule 105 (rel -> LOWEREQ .)


state 140

    (106) rel -> MOREEQ .

    LPAREN          reduce using rule 106 (rel -> MOREEQ .)
    PLUS            reduce using rule 106 (rel -> MOREEQ .)
    MINUS           reduce using rule 106 (rel -> MOREEQ .)
    ID              reduce using rule 106 (rel -> MOREEQ .)
    CTE_I           reduce using rule 106 (rel -> MOREEQ .)
    CTE_F           reduce using rule 106 (rel -> MOREEQ .)
    CTE_S           reduce using rule 106 (rel -> MOREEQ .)
    TRUE            reduce using rule 106 (rel -> MOREEQ .)
    FALSE           reduce using rule 106 (rel -> MOREEQ .)


state 141

    (107) rel -> SAME .

    LPAREN          reduce using rule 107 (rel -> SAME .)
    PLUS            reduce using rule 107 (rel -> SAME .)
    MINUS           reduce using rule 107 (rel -> SAME .)
    ID              reduce using rule 107 (rel -> SAME .)
    CTE_I           reduce using rule 107 (rel -> SAME .)
    CTE_F           reduce using rule 107 (rel -> SAME .)
    CTE_S           reduce using rule 107 (rel -> SAME .)
    TRUE            reduce using rule 107 (rel -> SAME .)
    FALSE           reduce using rule 107 (rel -> SAME .)


state 142

    (108) rel -> DIFFERENT .

    LPAREN          reduce using rule 108 (rel -> DIFFERENT .)
    PLUS            reduce using rule 108 (rel -> DIFFERENT .)
    MINUS           reduce using rule 108 (rel -> DIFFERENT .)
    ID              reduce using rule 108 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 108 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 108 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 108 (rel -> DIFFERENT .)
    TRUE            reduce using rule 108 (rel -> DIFFERENT .)
    FALSE           reduce using rule 108 (rel -> DIFFERENT .)


state 143

    (93) ex -> term resterm .
    (94) ex -> term resterm . PLUS pushop ex
    (95) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 93 (ex -> term resterm .)
    MORETHAN        reduce using rule 93 (ex -> term resterm .)
    LOWEREQ         reduce using rule 93 (ex -> term resterm .)
    MOREEQ          reduce using rule 93 (ex -> term resterm .)
    SAME            reduce using rule 93 (ex -> term resterm .)
    DIFFERENT       reduce using rule 93 (ex -> term resterm .)
    OR              reduce using rule 93 (ex -> term resterm .)
    AND             reduce using rule 93 (ex -> term resterm .)
    RPAREN          reduce using rule 93 (ex -> term resterm .)
    RBRACE          reduce using rule 93 (ex -> term resterm .)
    SEMICOLON       reduce using rule 93 (ex -> term resterm .)
    COMA            reduce using rule 93 (ex -> term resterm .)
    PLUS            shift and go to state 181
    MINUS           shift and go to state 182


state 144

    (101) fact -> PLUS var_cte .

    TIMES           reduce using rule 101 (fact -> PLUS var_cte .)
    DIVIDE          reduce using rule 101 (fact -> PLUS var_cte .)
    PLUS            reduce using rule 101 (fact -> PLUS var_cte .)
    MINUS           reduce using rule 101 (fact -> PLUS var_cte .)
    LOWERTHAN       reduce using rule 101 (fact -> PLUS var_cte .)
    MORETHAN        reduce using rule 101 (fact -> PLUS var_cte .)
    LOWEREQ         reduce using rule 101 (fact -> PLUS var_cte .)
    MOREEQ          reduce using rule 101 (fact -> PLUS var_cte .)
    SAME            reduce using rule 101 (fact -> PLUS var_cte .)
    DIFFERENT       reduce using rule 101 (fact -> PLUS var_cte .)
    OR              reduce using rule 101 (fact -> PLUS var_cte .)
    AND             reduce using rule 101 (fact -> PLUS var_cte .)
    RPAREN          reduce using rule 101 (fact -> PLUS var_cte .)
    RBRACE          reduce using rule 101 (fact -> PLUS var_cte .)
    SEMICOLON       reduce using rule 101 (fact -> PLUS var_cte .)
    COMA            reduce using rule 101 (fact -> PLUS var_cte .)


state 145

    (102) fact -> MINUS var_cte .

    TIMES           reduce using rule 102 (fact -> MINUS var_cte .)
    DIVIDE          reduce using rule 102 (fact -> MINUS var_cte .)
    PLUS            reduce using rule 102 (fact -> MINUS var_cte .)
    MINUS           reduce using rule 102 (fact -> MINUS var_cte .)
    LOWERTHAN       reduce using rule 102 (fact -> MINUS var_cte .)
    MORETHAN        reduce using rule 102 (fact -> MINUS var_cte .)
    LOWEREQ         reduce using rule 102 (fact -> MINUS var_cte .)
    MOREEQ          reduce using rule 102 (fact -> MINUS var_cte .)
    SAME            reduce using rule 102 (fact -> MINUS var_cte .)
    DIFFERENT       reduce using rule 102 (fact -> MINUS var_cte .)
    OR              reduce using rule 102 (fact -> MINUS var_cte .)
    AND             reduce using rule 102 (fact -> MINUS var_cte .)
    RPAREN          reduce using rule 102 (fact -> MINUS var_cte .)
    RBRACE          reduce using rule 102 (fact -> MINUS var_cte .)
    SEMICOLON       reduce using rule 102 (fact -> MINUS var_cte .)
    COMA            reduce using rule 102 (fact -> MINUS var_cte .)


state 146

    (96) term -> fact resfact .
    (97) term -> fact resfact . TIMES pushop term
    (98) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 96 (term -> fact resfact .)
    MINUS           reduce using rule 96 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 96 (term -> fact resfact .)
    MORETHAN        reduce using rule 96 (term -> fact resfact .)
    LOWEREQ         reduce using rule 96 (term -> fact resfact .)
    MOREEQ          reduce using rule 96 (term -> fact resfact .)
    SAME            reduce using rule 96 (term -> fact resfact .)
    DIFFERENT       reduce using rule 96 (term -> fact resfact .)
    OR              reduce using rule 96 (term -> fact resfact .)
    AND             reduce using rule 96 (term -> fact resfact .)
    RPAREN          reduce using rule 96 (term -> fact resfact .)
    RBRACE          reduce using rule 96 (term -> fact resfact .)
    SEMICOLON       reduce using rule 96 (term -> fact resfact .)
    COMA            reduce using rule 96 (term -> fact resfact .)
    TIMES           shift and go to state 183
    DIVIDE          shift and go to state 184


state 147

    (111) var_cte -> ID pushid .
    (120) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 111 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 111 (var_cte -> ID pushid .)
    PLUS            reduce using rule 111 (var_cte -> ID pushid .)
    MINUS           reduce using rule 111 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 111 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 111 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 111 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 111 (var_cte -> ID pushid .)
    SAME            reduce using rule 111 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 111 (var_cte -> ID pushid .)
    OR              reduce using rule 111 (var_cte -> ID pushid .)
    AND             reduce using rule 111 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 111 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 111 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 111 (var_cte -> ID pushid .)
    COMA            reduce using rule 111 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 185


state 148

    (121) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> ID existfunc . LPAREN startera RPAREN generateGoSub

    LPAREN          shift and go to state 186


state 149

    (131) vcall -> ID LBRACE . expres RBRACE
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 187
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 150

    (112) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 112 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 112 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 112 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 112 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 112 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 112 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 112 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 112 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 112 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 112 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 112 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 112 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 112 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 112 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 112 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 112 (var_cte -> CTE_I pushcte .)


state 151

    (113) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 113 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 113 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 113 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 113 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 113 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 113 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 113 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 113 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 113 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 113 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 113 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 113 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 113 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 113 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 113 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 113 (var_cte -> CTE_F pushcte .)


state 152

    (114) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 114 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 114 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 114 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 114 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 114 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 114 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 114 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 114 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 114 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 114 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 114 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 114 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 114 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 114 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 114 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 114 (var_cte -> CTE_S pushcte .)


state 153

    (115) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 115 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 115 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 115 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 115 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 115 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 115 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 115 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 115 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 115 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 115 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 115 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 115 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 115 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 115 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 115 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 115 (var_cte -> TRUE pushcte .)


state 154

    (116) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 116 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 116 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 116 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 116 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 116 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 116 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 116 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 116 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 116 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 116 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 116 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 116 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 116 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 116 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 116 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 116 (var_cte -> FALSE pushcte .)


state 155

    (79) escrit -> PRINT pushop LPAREN imprimirl . escriti RPAREN SEMICOLON
    (80) escriti -> . expres escrit1
    (81) escriti -> . expres escrit2 COMA escriti
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    escriti                        shift and go to state 188
    expres                         shift and go to state 189
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 156

    (85) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 190


state 157

    (86) leer -> READ pushop LPAREN ID . pushid readid RPAREN SEMICOLON
    (134) pushid -> .

    RPAREN          reduce using rule 134 (pushid -> .)

    pushid                         shift and go to state 191

state 158

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 159

    (26) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 RKEY

    RPAREN          shift and go to state 192


state 160

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 193


state 161

    (42) funci -> INT . ID sumparam
    (43) funci -> INT . ID sumparam COMA funci

    ID              shift and go to state 194


state 162

    (44) funci -> FLOAT . ID sumparam
    (45) funci -> FLOAT . ID sumparam COMA funci

    ID              shift and go to state 195


state 163

    (46) funci -> STRING . ID sumparam
    (47) funci -> STRING . ID sumparam COMA funci

    ID              shift and go to state 196


state 164

    (48) funci -> BOOL . ID sumparam
    (49) funci -> BOOL . ID sumparam COMA funci

    ID              shift and go to state 197


state 165

    (50) funci -> empty .

    RPAREN          reduce using rule 50 (funci -> empty .)


state 166

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY bloq RKEY

    RPAREN          shift and go to state 198


state 167

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 199


state 168

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 169

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 170

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)


state 171

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)


state 172

    (75) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (137) resolverasignacion -> .

    SEMICOLON       reduce using rule 137 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 200

state 173

    (76) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 201


state 174

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 202


state 175

    (124) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 203


state 176

    (127) fcall1 -> expres . generateparam
    (128) fcall1 -> expres . generateparam COMA fcall1
    (129) generateparam -> .

    COMA            reduce using rule 129 (generateparam -> .)
    RPAREN          reduce using rule 129 (generateparam -> .)

    generateparam                  shift and go to state 204

state 177

    (99) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 205


state 178

    (77) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (78) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (141) resif -> .

    ID              reduce using rule 141 (resif -> .)
    IF              reduce using rule 141 (resif -> .)
    PRINT           reduce using rule 141 (resif -> .)
    WHILE           reduce using rule 141 (resif -> .)
    READ            reduce using rule 141 (resif -> .)

    resif                          shift and go to state 206

state 179

    (89) expres -> exr log expres . reslog
    (92) reslog -> .

    RPAREN          reduce using rule 92 (reslog -> .)
    SEMICOLON       reduce using rule 92 (reslog -> .)
    COMA            reduce using rule 92 (reslog -> .)
    RBRACE          reduce using rule 92 (reslog -> .)

    reslog                         shift and go to state 207

state 180

    (91) exr -> ex rel exr . resrel
    (140) resrel -> .

    OR              reduce using rule 140 (resrel -> .)
    AND             reduce using rule 140 (resrel -> .)
    RPAREN          reduce using rule 140 (resrel -> .)
    RBRACE          reduce using rule 140 (resrel -> .)
    SEMICOLON       reduce using rule 140 (resrel -> .)
    COMA            reduce using rule 140 (resrel -> .)

    resrel                         shift and go to state 208

state 181

    (94) ex -> term resterm PLUS . pushop ex
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 209

state 182

    (95) ex -> term resterm MINUS . pushop ex
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 210

state 183

    (97) term -> fact resfact TIMES . pushop term
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 211

state 184

    (98) term -> fact resfact DIVIDE . pushop term
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 212

state 185

    (120) asigvector -> ID pushid LBRACE . ex RBRACE
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 213
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 186

    (121) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN generateGoSub
    (122) fcall -> ID existfunc LPAREN . startera RPAREN generateGoSub
    (126) startera -> .

    RPAREN          reduce using rule 126 (startera -> .)
    LPAREN          reduce using rule 126 (startera -> .)
    PLUS            reduce using rule 126 (startera -> .)
    MINUS           reduce using rule 126 (startera -> .)
    ID              reduce using rule 126 (startera -> .)
    CTE_I           reduce using rule 126 (startera -> .)
    CTE_F           reduce using rule 126 (startera -> .)
    CTE_S           reduce using rule 126 (startera -> .)
    TRUE            reduce using rule 126 (startera -> .)
    FALSE           reduce using rule 126 (startera -> .)

    startera                       shift and go to state 214

state 187

    (131) vcall -> ID LBRACE expres . RBRACE

    RBRACE          shift and go to state 215


state 188

    (79) escrit -> PRINT pushop LPAREN imprimirl escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 216


state 189

    (80) escriti -> expres . escrit1
    (81) escriti -> expres . escrit2 COMA escriti
    (83) escrit1 -> .
    (84) escrit2 -> .

    RPAREN          reduce using rule 83 (escrit1 -> .)
    COMA            reduce using rule 84 (escrit2 -> .)

    escrit1                        shift and go to state 217
    escrit2                        shift and go to state 218

state 190

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (145) while2 -> .

    LKEY            reduce using rule 145 (while2 -> .)

    while2                         shift and go to state 219

state 191

    (86) leer -> READ pushop LPAREN ID pushid . readid RPAREN SEMICOLON
    (87) readid -> .

    RPAREN          reduce using rule 87 (readid -> .)

    readid                         shift and go to state 220

state 192

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 RKEY

    LKEY            shift and go to state 221


state 193

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 223
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 222
    bloq                           shift and go to state 224
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 194

    (42) funci -> INT ID . sumparam
    (43) funci -> INT ID . sumparam COMA funci
    (55) sumparam -> .

    COMA            reduce using rule 55 (sumparam -> .)
    RPAREN          reduce using rule 55 (sumparam -> .)

    sumparam                       shift and go to state 227

state 195

    (44) funci -> FLOAT ID . sumparam
    (45) funci -> FLOAT ID . sumparam COMA funci
    (55) sumparam -> .

    COMA            reduce using rule 55 (sumparam -> .)
    RPAREN          reduce using rule 55 (sumparam -> .)

    sumparam                       shift and go to state 228

state 196

    (46) funci -> STRING ID . sumparam
    (47) funci -> STRING ID . sumparam COMA funci
    (55) sumparam -> .

    COMA            reduce using rule 55 (sumparam -> .)
    RPAREN          reduce using rule 55 (sumparam -> .)

    sumparam                       shift and go to state 229

state 197

    (48) funci -> BOOL ID . sumparam
    (49) funci -> BOOL ID . sumparam COMA funci
    (55) sumparam -> .

    COMA            reduce using rule 55 (sumparam -> .)
    RPAREN          reduce using rule 55 (sumparam -> .)

    sumparam                       shift and go to state 230

state 198

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 231


state 199

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . bloq RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 232
    bloq                           shift and go to state 233
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 200

    (75) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 234


state 201

    (76) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 235

state 202

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 236


state 203

    (124) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

    ID              reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 124 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)


state 204

    (127) fcall1 -> expres generateparam .
    (128) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 127 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 237


state 205

    (99) fact -> LPAREN pushop expres RPAREN . popop
    (136) popop -> .

    TIMES           reduce using rule 136 (popop -> .)
    DIVIDE          reduce using rule 136 (popop -> .)
    PLUS            reduce using rule 136 (popop -> .)
    MINUS           reduce using rule 136 (popop -> .)
    LOWERTHAN       reduce using rule 136 (popop -> .)
    MORETHAN        reduce using rule 136 (popop -> .)
    LOWEREQ         reduce using rule 136 (popop -> .)
    MOREEQ          reduce using rule 136 (popop -> .)
    SAME            reduce using rule 136 (popop -> .)
    DIFFERENT       reduce using rule 136 (popop -> .)
    OR              reduce using rule 136 (popop -> .)
    AND             reduce using rule 136 (popop -> .)
    RPAREN          reduce using rule 136 (popop -> .)
    RBRACE          reduce using rule 136 (popop -> .)
    SEMICOLON       reduce using rule 136 (popop -> .)
    COMA            reduce using rule 136 (popop -> .)

    popop                          shift and go to state 238

state 206

    (77) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (78) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 239
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 207

    (89) expres -> exr log expres reslog .

    RPAREN          reduce using rule 89 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 89 (expres -> exr log expres reslog .)
    COMA            reduce using rule 89 (expres -> exr log expres reslog .)
    RBRACE          reduce using rule 89 (expres -> exr log expres reslog .)


state 208

    (91) exr -> ex rel exr resrel .

    OR              reduce using rule 91 (exr -> ex rel exr resrel .)
    AND             reduce using rule 91 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 91 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 91 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 91 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 91 (exr -> ex rel exr resrel .)


state 209

    (94) ex -> term resterm PLUS pushop . ex
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 240
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 210

    (95) ex -> term resterm MINUS pushop . ex
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 241
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 211

    (97) term -> fact resfact TIMES pushop . term
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 242
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 212

    (98) term -> fact resfact DIVIDE pushop . term
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 243
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 213

    (120) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 244


state 214

    (121) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN generateGoSub
    (122) fcall -> ID existfunc LPAREN startera . RPAREN generateGoSub
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 246
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 245
    expres                         shift and go to state 176
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 215

    (131) vcall -> ID LBRACE expres RBRACE .

    TIMES           reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    DIVIDE          reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    PLUS            reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    MINUS           reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    LOWERTHAN       reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    MORETHAN        reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    LOWEREQ         reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    MOREEQ          reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    SAME            reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    DIFFERENT       reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    OR              reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    AND             reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    RPAREN          reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    RBRACE          reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    SEMICOLON       reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)
    COMA            reduce using rule 131 (vcall -> ID LBRACE expres RBRACE .)


state 216

    (79) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 247


state 217

    (80) escriti -> expres escrit1 .

    RPAREN          reduce using rule 80 (escriti -> expres escrit1 .)


state 218

    (81) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 248


state 219

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 249


state 220

    (86) leer -> READ pushop LPAREN ID pushid readid . RPAREN SEMICOLON

    RPAREN          shift and go to state 250


state 221

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    localvar                       shift and go to state 251
    var                            shift and go to state 225
    vector                         shift and go to state 226

state 222

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 252
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 253
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 223

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 224

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq . return1 RKEY
    (56) return1 -> . RETURN expres resreturn SEMICOLON
    (57) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 254
    empty                          shift and go to state 256

state 225

    (51) localvar -> var .
    (53) localvar -> var . localvar
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 51 (localvar -> var .)
    ID              reduce using rule 51 (localvar -> var .)
    IF              reduce using rule 51 (localvar -> var .)
    PRINT           reduce using rule 51 (localvar -> var .)
    WHILE           reduce using rule 51 (localvar -> var .)
    READ            reduce using rule 51 (localvar -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 225
    localvar                       shift and go to state 257
    vector                         shift and go to state 226

state 226

    (52) localvar -> vector .
    (54) localvar -> vector . localvar
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 52 (localvar -> vector .)
    ID              reduce using rule 52 (localvar -> vector .)
    IF              reduce using rule 52 (localvar -> vector .)
    PRINT           reduce using rule 52 (localvar -> vector .)
    WHILE           reduce using rule 52 (localvar -> vector .)
    READ            reduce using rule 52 (localvar -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 226
    localvar                       shift and go to state 258
    var                            shift and go to state 225

state 227

    (42) funci -> INT ID sumparam .
    (43) funci -> INT ID sumparam . COMA funci

    RPAREN          reduce using rule 42 (funci -> INT ID sumparam .)
    COMA            shift and go to state 259


state 228

    (44) funci -> FLOAT ID sumparam .
    (45) funci -> FLOAT ID sumparam . COMA funci

    RPAREN          reduce using rule 44 (funci -> FLOAT ID sumparam .)
    COMA            shift and go to state 260


state 229

    (46) funci -> STRING ID sumparam .
    (47) funci -> STRING ID sumparam . COMA funci

    RPAREN          reduce using rule 46 (funci -> STRING ID sumparam .)
    COMA            shift and go to state 261


state 230

    (48) funci -> BOOL ID sumparam .
    (49) funci -> BOOL ID sumparam . COMA funci

    RPAREN          reduce using rule 48 (funci -> BOOL ID sumparam .)
    COMA            shift and go to state 262


state 231

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . bloq RKEY
    (51) localvar -> . var
    (52) localvar -> . vector
    (53) localvar -> . var localvar
    (54) localvar -> . vector localvar
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 263
    bloq                           shift and go to state 264
    var                            shift and go to state 225
    vector                         shift and go to state 226
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 232

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 265
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 266
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 233

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 267


state 234

    (75) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 75 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 235

    (76) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres SEMICOLON
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 268
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 236

    (123) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

    ID              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 123 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)


state 237

    (128) fcall1 -> expres generateparam COMA . fcall1
    (127) fcall1 -> . expres generateparam
    (128) fcall1 -> . expres generateparam COMA fcall1
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 176
    fcall1                         shift and go to state 269
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 238

    (99) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 99 (fact -> LPAREN pushop expres RPAREN popop .)


state 239

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 270


state 240

    (94) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 94 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 94 (ex -> term resterm PLUS pushop ex .)


state 241

    (95) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 95 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 95 (ex -> term resterm MINUS pushop ex .)


state 242

    (97) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 97 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 97 (term -> fact resfact TIMES pushop term .)


state 243

    (98) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 98 (term -> fact resfact DIVIDE pushop term .)


state 244

    (120) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 120 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 245

    (121) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN generateGoSub

    RPAREN          shift and go to state 271


state 246

    (122) fcall -> ID existfunc LPAREN startera RPAREN . generateGoSub
    (130) generateGoSub -> .

    TIMES           reduce using rule 130 (generateGoSub -> .)
    DIVIDE          reduce using rule 130 (generateGoSub -> .)
    PLUS            reduce using rule 130 (generateGoSub -> .)
    MINUS           reduce using rule 130 (generateGoSub -> .)
    LOWERTHAN       reduce using rule 130 (generateGoSub -> .)
    MORETHAN        reduce using rule 130 (generateGoSub -> .)
    LOWEREQ         reduce using rule 130 (generateGoSub -> .)
    MOREEQ          reduce using rule 130 (generateGoSub -> .)
    SAME            reduce using rule 130 (generateGoSub -> .)
    DIFFERENT       reduce using rule 130 (generateGoSub -> .)
    OR              reduce using rule 130 (generateGoSub -> .)
    AND             reduce using rule 130 (generateGoSub -> .)
    RPAREN          reduce using rule 130 (generateGoSub -> .)
    RBRACE          reduce using rule 130 (generateGoSub -> .)
    SEMICOLON       reduce using rule 130 (generateGoSub -> .)
    COMA            reduce using rule 130 (generateGoSub -> .)

    generateGoSub                  shift and go to state 272

state 247

    (79) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .

    ID              reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    IF              reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    READ            reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 79 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)


state 248

    (81) escriti -> expres escrit2 COMA . escriti
    (80) escriti -> . expres escrit1
    (81) escriti -> . expres escrit2 COMA escriti
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 189
    escriti                        shift and go to state 273
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 249

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 274
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 250

    (86) leer -> READ pushop LPAREN ID pushid readid RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 275


state 251

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 276
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 252

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 253

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 RKEY
    (56) return1 -> . RETURN expres resreturn SEMICOLON
    (57) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 277
    empty                          shift and go to state 256

state 254

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 278


state 255

    (56) return1 -> RETURN . expres resreturn SEMICOLON
    (88) expres -> . exr
    (89) expres -> . exr log expres reslog
    (90) exr -> . ex
    (91) exr -> . ex rel exr resrel
    (93) ex -> . term resterm
    (94) ex -> . term resterm PLUS pushop ex
    (95) ex -> . term resterm MINUS pushop ex
    (96) term -> . fact resfact
    (97) term -> . fact resfact TIMES pushop term
    (98) term -> . fact resfact DIVIDE pushop term
    (99) fact -> . LPAREN pushop expres RPAREN popop
    (100) fact -> . var_cte
    (101) fact -> . PLUS var_cte
    (102) fact -> . MINUS var_cte
    (111) var_cte -> . ID pushid
    (112) var_cte -> . CTE_I pushcte
    (113) var_cte -> . CTE_F pushcte
    (114) var_cte -> . CTE_S pushcte
    (115) var_cte -> . TRUE pushcte
    (116) var_cte -> . FALSE pushcte
    (117) var_cte -> . fcall
    (118) var_cte -> . vcall
    (119) var_cte -> . asigvector
    (121) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (122) fcall -> . ID existfunc LPAREN startera RPAREN generateGoSub
    (131) vcall -> . ID LBRACE expres RBRACE
    (120) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 279
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    vcall                          shift and go to state 115
    asigvector                     shift and go to state 116

state 256

    (57) return1 -> empty .

    RKEY            reduce using rule 57 (return1 -> empty .)


state 257

    (53) localvar -> var localvar .

    RKEY            reduce using rule 53 (localvar -> var localvar .)
    ID              reduce using rule 53 (localvar -> var localvar .)
    IF              reduce using rule 53 (localvar -> var localvar .)
    PRINT           reduce using rule 53 (localvar -> var localvar .)
    WHILE           reduce using rule 53 (localvar -> var localvar .)
    READ            reduce using rule 53 (localvar -> var localvar .)


state 258

    (54) localvar -> vector localvar .

    RKEY            reduce using rule 54 (localvar -> vector localvar .)
    ID              reduce using rule 54 (localvar -> vector localvar .)
    IF              reduce using rule 54 (localvar -> vector localvar .)
    PRINT           reduce using rule 54 (localvar -> vector localvar .)
    WHILE           reduce using rule 54 (localvar -> vector localvar .)
    READ            reduce using rule 54 (localvar -> vector localvar .)


state 259

    (43) funci -> INT ID sumparam COMA . funci
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 280
    empty                          shift and go to state 165

state 260

    (45) funci -> FLOAT ID sumparam COMA . funci
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 281
    empty                          shift and go to state 165

state 261

    (47) funci -> STRING ID sumparam COMA . funci
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 282
    empty                          shift and go to state 165

state 262

    (49) funci -> BOOL ID sumparam COMA . funci
    (42) funci -> . INT ID sumparam
    (43) funci -> . INT ID sumparam COMA funci
    (44) funci -> . FLOAT ID sumparam
    (45) funci -> . FLOAT ID sumparam COMA funci
    (46) funci -> . STRING ID sumparam
    (47) funci -> . STRING ID sumparam COMA funci
    (48) funci -> . BOOL ID sumparam
    (49) funci -> . BOOL ID sumparam COMA funci
    (50) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 161
    FLOAT           shift and go to state 162
    STRING          shift and go to state 163
    BOOL            shift and go to state 164
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 283
    empty                          shift and go to state 165

state 263

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 284
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 264

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 285


state 265

    (30) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 266

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 286


state 267

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)


state 268

    (76) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . SEMICOLON

    SEMICOLON       shift and go to state 287


state 269

    (128) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 128 (fcall1 -> expres generateparam COMA fcall1 .)


state 270

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (143) finif -> .

    ELSE            shift and go to state 289
    ID              reduce using rule 143 (finif -> .)
    IF              reduce using rule 143 (finif -> .)
    PRINT           reduce using rule 143 (finif -> .)
    WHILE           reduce using rule 143 (finif -> .)
    READ            reduce using rule 143 (finif -> .)
    RKEY            reduce using rule 143 (finif -> .)
    RETURN          reduce using rule 143 (finif -> .)

    finif                          shift and go to state 288

state 271

    (121) fcall -> ID existfunc LPAREN startera fcall1 RPAREN . generateGoSub
    (130) generateGoSub -> .

    TIMES           reduce using rule 130 (generateGoSub -> .)
    DIVIDE          reduce using rule 130 (generateGoSub -> .)
    PLUS            reduce using rule 130 (generateGoSub -> .)
    MINUS           reduce using rule 130 (generateGoSub -> .)
    LOWERTHAN       reduce using rule 130 (generateGoSub -> .)
    MORETHAN        reduce using rule 130 (generateGoSub -> .)
    LOWEREQ         reduce using rule 130 (generateGoSub -> .)
    MOREEQ          reduce using rule 130 (generateGoSub -> .)
    SAME            reduce using rule 130 (generateGoSub -> .)
    DIFFERENT       reduce using rule 130 (generateGoSub -> .)
    OR              reduce using rule 130 (generateGoSub -> .)
    AND             reduce using rule 130 (generateGoSub -> .)
    RPAREN          reduce using rule 130 (generateGoSub -> .)
    RBRACE          reduce using rule 130 (generateGoSub -> .)
    SEMICOLON       reduce using rule 130 (generateGoSub -> .)
    COMA            reduce using rule 130 (generateGoSub -> .)

    generateGoSub                  shift and go to state 290

state 272

    (122) fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .

    TIMES           reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    DIVIDE          reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    PLUS            reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MINUS           reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    LOWERTHAN       reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MORETHAN        reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    LOWEREQ         reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    MOREEQ          reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    SAME            reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    DIFFERENT       reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    OR              reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    AND             reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    RPAREN          reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    RBRACE          reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    SEMICOLON       reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)
    COMA            reduce using rule 122 (fcall -> ID existfunc LPAREN startera RPAREN generateGoSub .)


state 273

    (81) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 81 (escriti -> expres escrit2 COMA escriti .)


state 274

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 291


state 275

    (86) leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .

    ID              reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    IF              reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    PRINT           reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    WHILE           reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    READ            reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RKEY            reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RETURN          reduce using rule 86 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)


state 276

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 RKEY
    (56) return1 -> . RETURN expres resreturn SEMICOLON
    (57) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 255
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 292
    empty                          shift and go to state 256

state 277

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 293


state 278

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)


state 279

    (56) return1 -> RETURN expres . resreturn SEMICOLON
    (58) resreturn -> .

    SEMICOLON       reduce using rule 58 (resreturn -> .)

    resreturn                      shift and go to state 294

state 280

    (43) funci -> INT ID sumparam COMA funci .

    RPAREN          reduce using rule 43 (funci -> INT ID sumparam COMA funci .)


state 281

    (45) funci -> FLOAT ID sumparam COMA funci .

    RPAREN          reduce using rule 45 (funci -> FLOAT ID sumparam COMA funci .)


state 282

    (47) funci -> STRING ID sumparam COMA funci .

    RPAREN          reduce using rule 47 (funci -> STRING ID sumparam COMA funci .)


state 283

    (49) funci -> BOOL ID sumparam COMA funci .

    RPAREN          reduce using rule 49 (funci -> BOOL ID sumparam COMA funci .)


state 284

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 295


state 285

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)


state 286

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 287

    (76) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .

    ID              reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    IF              reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    PRINT           reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    WHILE           reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    READ            reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RKEY            reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RETURN          reduce using rule 76 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)


state 288

    (77) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 77 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 289

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 296


state 290

    (121) fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .

    TIMES           reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIVIDE          reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    PLUS            reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MINUS           reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWERTHAN       reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MORETHAN        reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWEREQ         reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MOREEQ          reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SAME            reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIFFERENT       reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    OR              reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    AND             reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RPAREN          reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RBRACE          reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SEMICOLON       reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    COMA            reduce using rule 121 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)


state 291

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (146) while3 -> .

    ID              reduce using rule 146 (while3 -> .)
    IF              reduce using rule 146 (while3 -> .)
    PRINT           reduce using rule 146 (while3 -> .)
    WHILE           reduce using rule 146 (while3 -> .)
    READ            reduce using rule 146 (while3 -> .)
    RKEY            reduce using rule 146 (while3 -> .)
    RETURN          reduce using rule 146 (while3 -> .)

    while3                         shift and go to state 297

state 292

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 298


state 293

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)


state 294

    (56) return1 -> RETURN expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 299


state 295

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 296

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (142) reselse -> .

    ID              reduce using rule 142 (reselse -> .)
    IF              reduce using rule 142 (reselse -> .)
    PRINT           reduce using rule 142 (reselse -> .)
    WHILE           reduce using rule 142 (reselse -> .)
    READ            reduce using rule 142 (reselse -> .)

    reselse                        shift and go to state 300

state 297

    (85) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 85 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 298

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)


state 299

    (56) return1 -> RETURN expres resreturn SEMICOLON .

    RKEY            reduce using rule 56 (return1 -> RETURN expres resreturn SEMICOLON .)


state 300

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (67) bloq -> . estat
    (68) bloq -> . estat bloq
    (69) estat -> . asign
    (70) estat -> . cond
    (71) estat -> . escrit
    (72) estat -> . ciclo
    (73) estat -> . leer
    (74) estat -> . fcallvoid
    (75) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (76) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (77) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (78) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (79) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (85) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (86) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (123) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 301
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 301

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 302


state 302

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (143) finif -> .

    ID              reduce using rule 143 (finif -> .)
    IF              reduce using rule 143 (finif -> .)
    PRINT           reduce using rule 143 (finif -> .)
    WHILE           reduce using rule 143 (finif -> .)
    READ            reduce using rule 143 (finif -> .)
    RKEY            reduce using rule 143 (finif -> .)
    RETURN          reduce using rule 143 (finif -> .)

    finif                          shift and go to state 303

state 303

    (78) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 78 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 108 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 122 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 123 resolved as shift
