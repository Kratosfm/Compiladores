Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 4     gotomain -> <empty>
Rule 5     program2 -> crear program2
Rule 6     program2 -> crear
Rule 7     program3 -> function program3
Rule 8     program3 -> function
Rule 9     llenarmain -> <empty>
Rule 10    crear -> var
Rule 11    crear -> vector
Rule 12    global -> <empty>
Rule 13    finglobal -> <empty>
Rule 14    main1 -> <empty>
Rule 15    finmain -> <empty>
Rule 16    var -> VAR tipo ID SEMICOLON
Rule 17    tipo -> INT
Rule 18    tipo -> FLOAT
Rule 19    tipo -> STRING
Rule 20    tipo -> BOOL
Rule 21    vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 22    vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
Rule 24    vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
Rule 25    initvector -> <empty>
Rule 26    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
Rule 27    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
Rule 28    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 29    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
Rule 30    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 31    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 32    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
Rule 33    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 34    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
Rule 35    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
Rule 36    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 37    functype -> INT
Rule 38    functype -> FLOAT
Rule 39    functype -> STRING
Rule 40    functype -> BOOL
Rule 41    pushvoid -> VOID
Rule 42    addInTable -> <empty>
Rule 43    funci -> INT ID sumparam
Rule 44    funci -> INT ID sumparam COMA funci
Rule 45    funci -> FLOAT ID sumparam
Rule 46    funci -> FLOAT ID sumparam COMA funci
Rule 47    funci -> STRING ID sumparam
Rule 48    funci -> STRING ID sumparam COMA funci
Rule 49    funci -> BOOL ID sumparam
Rule 50    funci -> BOOL ID sumparam COMA funci
Rule 51    funci -> empty
Rule 52    localvar -> var
Rule 53    localvar -> vector
Rule 54    localvar -> var localvar
Rule 55    localvar -> vector localvar
Rule 56    sumparam -> <empty>
Rule 57    return1 -> RETURN pushop expres resreturn SEMICOLON
Rule 58    return1 -> empty
Rule 59    resreturn -> <empty>
Rule 60    mainc -> LKEY RKEY
Rule 61    mainc -> LKEY bloq RKEY
Rule 62    mainc -> LKEY mainc2 bloq RKEY
Rule 63    mainc -> LKEY mainc2 RKEY
Rule 64    mainc2 -> var
Rule 65    mainc2 -> var mainc2
Rule 66    mainc2 -> vector
Rule 67    mainc2 -> vector mainc2
Rule 68    bloq -> estat
Rule 69    bloq -> estat bloq
Rule 70    estat -> asign
Rule 71    estat -> cond
Rule 72    estat -> escrit
Rule 73    estat -> ciclo
Rule 74    estat -> leer
Rule 75    estat -> fcallvoid
Rule 76    asign -> ID pushid EQUAL pushop fcall resolverasignacion
Rule 77    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 78    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
Rule 79    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 80    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 81    escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
Rule 82    escriti -> expres escrit1
Rule 83    escriti -> expres escrit2 COMA escriti
Rule 84    imprimirl -> <empty>
Rule 85    escrit1 -> <empty>
Rule 86    escrit2 -> <empty>
Rule 87    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 88    leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
Rule 89    readid -> <empty>
Rule 90    expres -> exr
Rule 91    expres -> exr log expres reslog
Rule 92    exr -> ex
Rule 93    exr -> ex rel exr resrel
Rule 94    reslog -> <empty>
Rule 95    ex -> term resterm
Rule 96    ex -> term resterm PLUS pushop ex
Rule 97    ex -> term resterm MINUS pushop ex
Rule 98    term -> fact resfact
Rule 99    term -> fact resfact TIMES pushop term
Rule 100   term -> fact resfact DIVIDE pushop term
Rule 101   fact -> LPAREN pushop expres RPAREN popop
Rule 102   fact -> var_cte
Rule 103   fact -> PLUS pushop var_cte
Rule 104   fact -> MINUS pushop var_cte
Rule 105   rel -> LOWERTHAN
Rule 106   rel -> MORETHAN
Rule 107   rel -> LOWEREQ
Rule 108   rel -> MOREEQ
Rule 109   rel -> SAME
Rule 110   rel -> DIFFERENT
Rule 111   log -> OR
Rule 112   log -> AND
Rule 113   var_cte -> ID pushid
Rule 114   var_cte -> CTE_I pushcte
Rule 115   var_cte -> CTE_F pushcte
Rule 116   var_cte -> CTE_S pushcte
Rule 117   var_cte -> TRUE pushcte
Rule 118   var_cte -> FALSE pushcte
Rule 119   var_cte -> fcall
Rule 120   var_cte -> fcallvoid
Rule 121   var_cte -> asigvector
Rule 122   asigvector -> ID pushid LBRACE ex RBRACE
Rule 123   fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 124   fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 125   fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 126   fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 127   existfunc -> <empty>
Rule 128   startera -> <empty>
Rule 129   fcall1 -> expres generateparam
Rule 130   fcall1 -> expres generateparam COMA fcall1
Rule 131   generateparam -> <empty>
Rule 132   empty -> <empty>
Rule 133   pushcte -> <empty>
Rule 134   pushid -> <empty>
Rule 135   pushop -> <empty>
Rule 136   popop -> <empty>
Rule 137   resolverasignacion -> <empty>
Rule 138   resfact -> <empty>
Rule 139   resterm -> <empty>
Rule 140   resrel -> <empty>
Rule 141   resif -> <empty>
Rule 142   reselse -> <empty>
Rule 143   finif -> <empty>
Rule 144   while1 -> <empty>
Rule 145   while2 -> <empty>
Rule 146   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 112
BOOL                 : 20 24 40 49 50
COLON                : 1 2 3
COMA                 : 44 46 48 50 83 130
CTE_F                : 115
CTE_I                : 21 22 23 24 114
CTE_S                : 116
DIFFERENT            : 110
DIVIDE               : 100
ELSE                 : 80
EQUAL                : 76 77 78
FALSE                : 118
FLOAT                : 18 22 38 45 46
FUNCTION             : 26 27 28 29 30 31 32 33 34 35 36
ID                   : 16 21 22 23 24 26 27 28 29 30 31 32 33 34 35 36 43 44 45 46 47 48 49 50 76 77 78 88 113 122 123 124 125 126
IF                   : 79 80
INT                  : 17 21 37 43 44
LBRACE               : 21 22 23 24 78 122
LKEY                 : 26 27 28 29 30 31 32 33 34 35 36 60 61 62 63 79 80 80 87
LOWEREQ              : 107
LOWERTHAN            : 105
LPAREN               : 26 27 28 29 30 31 32 33 34 35 36 79 80 81 87 88 101 123 124 125 126
MAIN                 : 1 2 3
MINUS                : 97 104
MOREEQ               : 108
MORETHAN             : 106
OR                   : 111
PLUS                 : 96 103
PRINT                : 81
PROGRAM              : 1 2 3
RBRACE               : 21 22 23 24 78 122
READ                 : 88
RETURN               : 57
RKEY                 : 26 27 28 29 30 31 32 33 34 35 36 60 61 62 63 79 80 80 87
RPAREN               : 26 27 28 29 30 31 32 33 34 35 36 79 80 81 87 88 101 123 124 125 126
SAME                 : 109
SEMICOLON            : 16 21 22 23 24 57 77 78 81 88 123 124 125 126
STRING               : 19 23 39 47 48
TIMES                : 99
TRUE                 : 117
VAR                  : 16
VECTOR               : 21 22 23 24
VOID                 : 41
WHILE                : 87
error                : 

Nonterminals, with rules where they appear

addInTable           : 26 27 28 29 30 31 32 33 34 35 36
asign                : 70
asigvector           : 121
bloq                 : 26 27 28 29 32 33 34 35 61 62 69 79 80 80 87
ciclo                : 73
cond                 : 71
crear                : 5 6
empty                : 51 58
escrit               : 72
escrit1              : 82
escrit2              : 83
escriti              : 81 83
estat                : 68 69
ex                   : 92 93 96 97 122
existfunc            : 123 124 125 126
expres               : 57 77 78 79 80 82 83 87 91 101 129 130
exr                  : 78 90 91 93
fact                 : 98 99 100
fcall                : 76 119
fcall1               : 123 125 130
fcallvoid            : 75 120
finglobal            : 1 2
finif                : 79 80
finmain              : 1 2 3
funci                : 26 27 28 29 44 46 48 50
function             : 7 8
functype             : 26 27 30 32 35 36
generateparam        : 129 130
global               : 1 2
gotomain             : 1 2 3
imprimirl            : 81
initvector           : 21 22 23 24
leer                 : 74
llenarmain           : 1 2 3
localvar             : 26 28 30 31 32 33 54 55
log                  : 91
main1                : 1 2 3
mainc                : 1 2 3
mainc2               : 62 63 65 67
popop                : 101
program              : 0
program2             : 1 2 5
program3             : 1 7
pushcte              : 114 115 116 117 118
pushid               : 76 77 78 88 113 122
pushop               : 57 76 77 78 81 88 96 97 99 100 101 103 104
pushvoid             : 28 29 31 33 34
readid               : 88
rel                  : 93
reselse              : 80
resfact              : 98 99 100
resif                : 79 80
reslog               : 91
resolverasignacion   : 76 77
resrel               : 93
resreturn            : 57
resterm              : 95 96 97
return1              : 26 27 32 35
startera             : 123 124 125 126
sumparam             : 43 44 45 46 47 48 49 50
term                 : 95 96 97 99 100
tipo                 : 16
var                  : 10 52 54 64 65
var_cte              : 102 103 104
vector               : 11 53 55 66 67
while1               : 87
while2               : 87
while3               : 87

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (4) gotomain -> .

    VAR             reduce using rule 4 (gotomain -> .)
    VECTOR          reduce using rule 4 (gotomain -> .)
    MAIN            reduce using rule 4 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (12) global -> .
    (9) llenarmain -> .

    VAR             reduce using rule 12 (global -> .)
    VECTOR          reduce using rule 12 (global -> .)
    MAIN            reduce using rule 9 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    program2                       shift and go to state 7
    crear                          shift and go to state 8
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 6

    (3) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 13


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (13) finglobal -> .

    FUNCTION        reduce using rule 13 (finglobal -> .)
    MAIN            reduce using rule 13 (finglobal -> .)

    finglobal                      shift and go to state 14

state 8

    (5) program2 -> crear . program2
    (6) program2 -> crear .
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 6 (program2 -> crear .)
    MAIN            reduce using rule 6 (program2 -> crear .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    crear                          shift and go to state 8
    program2                       shift and go to state 15
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 9

    (10) crear -> var .

    VAR             reduce using rule 10 (crear -> var .)
    VECTOR          reduce using rule 10 (crear -> var .)
    FUNCTION        reduce using rule 10 (crear -> var .)
    MAIN            reduce using rule 10 (crear -> var .)


state 10

    (11) crear -> vector .

    VAR             reduce using rule 11 (crear -> vector .)
    VECTOR          reduce using rule 11 (crear -> vector .)
    FUNCTION        reduce using rule 11 (crear -> vector .)
    MAIN            reduce using rule 11 (crear -> vector .)


state 11

    (16) var -> VAR . tipo ID SEMICOLON
    (17) tipo -> . INT
    (18) tipo -> . FLOAT
    (19) tipo -> . STRING
    (20) tipo -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    BOOL            shift and go to state 20

    tipo                           shift and go to state 16

state 12

    (21) vector -> VECTOR . initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR . initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR . initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR . initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (25) initvector -> .

    INT             reduce using rule 25 (initvector -> .)
    FLOAT           reduce using rule 25 (initvector -> .)
    STRING          reduce using rule 25 (initvector -> .)
    BOOL            reduce using rule 25 (initvector -> .)

    initvector                     shift and go to state 21

state 13

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 22

state 14

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (7) program3 -> . function program3
    (8) program3 -> . function
    (9) llenarmain -> .
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (llenarmain -> .)
    FUNCTION        shift and go to state 26

    program3                       shift and go to state 23
    llenarmain                     shift and go to state 24
    function                       shift and go to state 25

state 15

    (5) program2 -> crear program2 .

    FUNCTION        reduce using rule 5 (program2 -> crear program2 .)
    MAIN            reduce using rule 5 (program2 -> crear program2 .)


state 16

    (16) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 27


state 17

    (17) tipo -> INT .

    ID              reduce using rule 17 (tipo -> INT .)


state 18

    (18) tipo -> FLOAT .

    ID              reduce using rule 18 (tipo -> FLOAT .)


state 19

    (19) tipo -> STRING .

    ID              reduce using rule 19 (tipo -> STRING .)


state 20

    (20) tipo -> BOOL .

    ID              reduce using rule 20 (tipo -> BOOL .)


state 21

    (21) vector -> VECTOR initvector . INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR initvector . FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR initvector . STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR initvector . BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31


state 22

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 32

state 23

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (9) llenarmain -> .

    MAIN            reduce using rule 9 (llenarmain -> .)

    llenarmain                     shift and go to state 34

state 24

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 35


state 25

    (7) program3 -> function . program3
    (8) program3 -> function .
    (7) program3 -> . function program3
    (8) program3 -> . function
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 8 (program3 -> function .)
    FUNCTION        shift and go to state 26

    function                       shift and go to state 25
    program3                       shift and go to state 36

state 26

    (26) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (30) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (35) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (37) functype -> . INT
    (38) functype -> . FLOAT
    (39) functype -> . STRING
    (40) functype -> . BOOL
    (41) pushvoid -> . VOID

    INT             shift and go to state 39
    FLOAT           shift and go to state 40
    STRING          shift and go to state 41
    BOOL            shift and go to state 42
    VOID            shift and go to state 43

    functype                       shift and go to state 37
    pushvoid                       shift and go to state 38

state 27

    (16) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 44


state 28

    (21) vector -> VECTOR initvector INT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 45


state 29

    (22) vector -> VECTOR initvector FLOAT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 46


state 30

    (23) vector -> VECTOR initvector STRING . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 47


state 31

    (24) vector -> VECTOR initvector BOOL . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 48


state 32

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 49

state 33

    (60) mainc -> LKEY . RKEY
    (61) mainc -> LKEY . bloq RKEY
    (62) mainc -> LKEY . mainc2 bloq RKEY
    (63) mainc -> LKEY . mainc2 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 50
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 51
    mainc2                         shift and go to state 52
    estat                          shift and go to state 53
    var                            shift and go to state 54
    vector                         shift and go to state 55
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 34

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 67


state 35

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 68

state 36

    (7) program3 -> function program3 .

    MAIN            reduce using rule 7 (program3 -> function program3 .)


state 37

    (26) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 69


state 38

    (28) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY bloq RKEY

    ID              shift and go to state 70


state 39

    (37) functype -> INT .

    ID              reduce using rule 37 (functype -> INT .)


state 40

    (38) functype -> FLOAT .

    ID              reduce using rule 38 (functype -> FLOAT .)


state 41

    (39) functype -> STRING .

    ID              reduce using rule 39 (functype -> STRING .)


state 42

    (40) functype -> BOOL .

    ID              reduce using rule 40 (functype -> BOOL .)


state 43

    (41) pushvoid -> VOID .

    ID              reduce using rule 41 (pushvoid -> VOID .)


state 44

    (16) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)


state 45

    (21) vector -> VECTOR initvector INT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 71


state 46

    (22) vector -> VECTOR initvector FLOAT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 72


state 47

    (23) vector -> VECTOR initvector STRING ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 73


state 48

    (24) vector -> VECTOR initvector BOOL ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 74


state 49

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 50

    (60) mainc -> LKEY RKEY .

    $end            reduce using rule 60 (mainc -> LKEY RKEY .)


state 51

    (61) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 75


state 52

    (62) mainc -> LKEY mainc2 . bloq RKEY
    (63) mainc -> LKEY mainc2 . RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 77
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 76
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 53

    (68) bloq -> estat .
    (69) bloq -> estat . bloq
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            reduce using rule 68 (bloq -> estat .)
    RETURN          reduce using rule 68 (bloq -> estat .)
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    estat                          shift and go to state 53
    bloq                           shift and go to state 78
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 54

    (64) mainc2 -> var .
    (65) mainc2 -> var . mainc2
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 64 (mainc2 -> var .)
    ID              reduce using rule 64 (mainc2 -> var .)
    IF              reduce using rule 64 (mainc2 -> var .)
    PRINT           reduce using rule 64 (mainc2 -> var .)
    WHILE           reduce using rule 64 (mainc2 -> var .)
    READ            reduce using rule 64 (mainc2 -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 54
    mainc2                         shift and go to state 79
    vector                         shift and go to state 55

state 55

    (66) mainc2 -> vector .
    (67) mainc2 -> vector . mainc2
    (64) mainc2 -> . var
    (65) mainc2 -> . var mainc2
    (66) mainc2 -> . vector
    (67) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 66 (mainc2 -> vector .)
    ID              reduce using rule 66 (mainc2 -> vector .)
    IF              reduce using rule 66 (mainc2 -> vector .)
    PRINT           reduce using rule 66 (mainc2 -> vector .)
    WHILE           reduce using rule 66 (mainc2 -> vector .)
    READ            reduce using rule 66 (mainc2 -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 55
    mainc2                         shift and go to state 80
    var                            shift and go to state 54

state 56

    (70) estat -> asign .

    ID              reduce using rule 70 (estat -> asign .)
    IF              reduce using rule 70 (estat -> asign .)
    PRINT           reduce using rule 70 (estat -> asign .)
    WHILE           reduce using rule 70 (estat -> asign .)
    READ            reduce using rule 70 (estat -> asign .)
    RKEY            reduce using rule 70 (estat -> asign .)
    RETURN          reduce using rule 70 (estat -> asign .)


state 57

    (71) estat -> cond .

    ID              reduce using rule 71 (estat -> cond .)
    IF              reduce using rule 71 (estat -> cond .)
    PRINT           reduce using rule 71 (estat -> cond .)
    WHILE           reduce using rule 71 (estat -> cond .)
    READ            reduce using rule 71 (estat -> cond .)
    RKEY            reduce using rule 71 (estat -> cond .)
    RETURN          reduce using rule 71 (estat -> cond .)


state 58

    (72) estat -> escrit .

    ID              reduce using rule 72 (estat -> escrit .)
    IF              reduce using rule 72 (estat -> escrit .)
    PRINT           reduce using rule 72 (estat -> escrit .)
    WHILE           reduce using rule 72 (estat -> escrit .)
    READ            reduce using rule 72 (estat -> escrit .)
    RKEY            reduce using rule 72 (estat -> escrit .)
    RETURN          reduce using rule 72 (estat -> escrit .)


state 59

    (73) estat -> ciclo .

    ID              reduce using rule 73 (estat -> ciclo .)
    IF              reduce using rule 73 (estat -> ciclo .)
    PRINT           reduce using rule 73 (estat -> ciclo .)
    WHILE           reduce using rule 73 (estat -> ciclo .)
    READ            reduce using rule 73 (estat -> ciclo .)
    RKEY            reduce using rule 73 (estat -> ciclo .)
    RETURN          reduce using rule 73 (estat -> ciclo .)


state 60

    (74) estat -> leer .

    ID              reduce using rule 74 (estat -> leer .)
    IF              reduce using rule 74 (estat -> leer .)
    PRINT           reduce using rule 74 (estat -> leer .)
    WHILE           reduce using rule 74 (estat -> leer .)
    READ            reduce using rule 74 (estat -> leer .)
    RKEY            reduce using rule 74 (estat -> leer .)
    RETURN          reduce using rule 74 (estat -> leer .)


state 61

    (75) estat -> fcallvoid .

    ID              reduce using rule 75 (estat -> fcallvoid .)
    IF              reduce using rule 75 (estat -> fcallvoid .)
    PRINT           reduce using rule 75 (estat -> fcallvoid .)
    WHILE           reduce using rule 75 (estat -> fcallvoid .)
    READ            reduce using rule 75 (estat -> fcallvoid .)
    RKEY            reduce using rule 75 (estat -> fcallvoid .)
    RETURN          reduce using rule 75 (estat -> fcallvoid .)


state 62

    (76) asign -> ID . pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (125) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (134) pushid -> .
    (127) existfunc -> .

    EQUAL           reduce using rule 134 (pushid -> .)
    LBRACE          reduce using rule 134 (pushid -> .)
    LPAREN          reduce using rule 127 (existfunc -> .)

    pushid                         shift and go to state 81
    existfunc                      shift and go to state 82

state 63

    (79) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 83


state 64

    (81) escrit -> PRINT . pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 84

state 65

    (87) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (144) while1 -> .

    LPAREN          reduce using rule 144 (while1 -> .)

    while1                         shift and go to state 85

state 66

    (88) leer -> READ . pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 86

state 67

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 87

state 68

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 88

state 69

    (26) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (42) addInTable -> .

    LPAREN          reduce using rule 42 (addInTable -> .)

    addInTable                     shift and go to state 89

state 70

    (28) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY bloq RKEY
    (42) addInTable -> .

    LPAREN          reduce using rule 42 (addInTable -> .)

    addInTable                     shift and go to state 90

state 71

    (21) vector -> VECTOR initvector INT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 91


state 72

    (22) vector -> VECTOR initvector FLOAT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 92


state 73

    (23) vector -> VECTOR initvector STRING ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 93


state 74

    (24) vector -> VECTOR initvector BOOL ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 94


state 75

    (61) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 61 (mainc -> LKEY bloq RKEY .)


state 76

    (62) mainc -> LKEY mainc2 bloq . RKEY

    RKEY            shift and go to state 95


state 77

    (63) mainc -> LKEY mainc2 RKEY .

    $end            reduce using rule 63 (mainc -> LKEY mainc2 RKEY .)


state 78

    (69) bloq -> estat bloq .

    RKEY            reduce using rule 69 (bloq -> estat bloq .)
    RETURN          reduce using rule 69 (bloq -> estat bloq .)


state 79

    (65) mainc2 -> var mainc2 .

    RKEY            reduce using rule 65 (mainc2 -> var mainc2 .)
    ID              reduce using rule 65 (mainc2 -> var mainc2 .)
    IF              reduce using rule 65 (mainc2 -> var mainc2 .)
    PRINT           reduce using rule 65 (mainc2 -> var mainc2 .)
    WHILE           reduce using rule 65 (mainc2 -> var mainc2 .)
    READ            reduce using rule 65 (mainc2 -> var mainc2 .)


state 80

    (67) mainc2 -> vector mainc2 .

    RKEY            reduce using rule 67 (mainc2 -> vector mainc2 .)
    ID              reduce using rule 67 (mainc2 -> vector mainc2 .)
    IF              reduce using rule 67 (mainc2 -> vector mainc2 .)
    PRINT           reduce using rule 67 (mainc2 -> vector mainc2 .)
    WHILE           reduce using rule 67 (mainc2 -> vector mainc2 .)
    READ            reduce using rule 67 (mainc2 -> vector mainc2 .)


state 81

    (76) asign -> ID pushid . EQUAL pushop fcall resolverasignacion
    (77) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 96
    LBRACE          shift and go to state 97


state 82

    (125) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 98


state 83

    (79) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 100
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 84

    (81) escrit -> PRINT pushop . LPAREN imprimirl escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 117


state 85

    (87) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 118


state 86

    (88) leer -> READ pushop . LPAREN ID pushid readid RPAREN SEMICOLON

    LPAREN          shift and go to state 119


state 87

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (60) mainc -> . LKEY RKEY
    (61) mainc -> . LKEY bloq RKEY
    (62) mainc -> . LKEY mainc2 bloq RKEY
    (63) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 120

state 88

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 121

state 89

    (26) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 122


state 90

    (28) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY bloq RKEY

    LPAREN          shift and go to state 123


state 91

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 124


state 92

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 125


state 93

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 126


state 94

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 127


state 95

    (62) mainc -> LKEY mainc2 bloq RKEY .

    $end            reduce using rule 62 (mainc -> LKEY mainc2 bloq RKEY .)


state 96

    (76) asign -> ID pushid EQUAL . pushop fcall resolverasignacion
    (77) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (135) pushop -> .

    ID              reduce using rule 135 (pushop -> .)
    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 128

state 97

    (78) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres SEMICOLON
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 129
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 98

    (125) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (128) startera -> .

    RPAREN          reduce using rule 128 (startera -> .)
    LPAREN          reduce using rule 128 (startera -> .)
    PLUS            reduce using rule 128 (startera -> .)
    MINUS           reduce using rule 128 (startera -> .)
    ID              reduce using rule 128 (startera -> .)
    CTE_I           reduce using rule 128 (startera -> .)
    CTE_F           reduce using rule 128 (startera -> .)
    CTE_S           reduce using rule 128 (startera -> .)
    TRUE            reduce using rule 128 (startera -> .)
    FALSE           reduce using rule 128 (startera -> .)

    startera                       shift and go to state 130

state 99

    (101) fact -> LPAREN . pushop expres RPAREN popop
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 131

state 100

    (79) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 132


state 101

    (90) expres -> exr .
    (91) expres -> exr . log expres reslog
    (111) log -> . OR
    (112) log -> . AND

    RPAREN          reduce using rule 90 (expres -> exr .)
    SEMICOLON       reduce using rule 90 (expres -> exr .)
    COMA            reduce using rule 90 (expres -> exr .)
    OR              shift and go to state 134
    AND             shift and go to state 135

    log                            shift and go to state 133

state 102

    (92) exr -> ex .
    (93) exr -> ex . rel exr resrel
    (105) rel -> . LOWERTHAN
    (106) rel -> . MORETHAN
    (107) rel -> . LOWEREQ
    (108) rel -> . MOREEQ
    (109) rel -> . SAME
    (110) rel -> . DIFFERENT

    OR              reduce using rule 92 (exr -> ex .)
    AND             reduce using rule 92 (exr -> ex .)
    RPAREN          reduce using rule 92 (exr -> ex .)
    RBRACE          reduce using rule 92 (exr -> ex .)
    SEMICOLON       reduce using rule 92 (exr -> ex .)
    COMA            reduce using rule 92 (exr -> ex .)
    LOWERTHAN       shift and go to state 137
    MORETHAN        shift and go to state 138
    LOWEREQ         shift and go to state 139
    MOREEQ          shift and go to state 140
    SAME            shift and go to state 141
    DIFFERENT       shift and go to state 142

    rel                            shift and go to state 136

state 103

    (95) ex -> term . resterm
    (96) ex -> term . resterm PLUS pushop ex
    (97) ex -> term . resterm MINUS pushop ex
    (139) resterm -> .

    PLUS            reduce using rule 139 (resterm -> .)
    MINUS           reduce using rule 139 (resterm -> .)
    LOWERTHAN       reduce using rule 139 (resterm -> .)
    MORETHAN        reduce using rule 139 (resterm -> .)
    LOWEREQ         reduce using rule 139 (resterm -> .)
    MOREEQ          reduce using rule 139 (resterm -> .)
    SAME            reduce using rule 139 (resterm -> .)
    DIFFERENT       reduce using rule 139 (resterm -> .)
    OR              reduce using rule 139 (resterm -> .)
    AND             reduce using rule 139 (resterm -> .)
    RPAREN          reduce using rule 139 (resterm -> .)
    RBRACE          reduce using rule 139 (resterm -> .)
    SEMICOLON       reduce using rule 139 (resterm -> .)
    COMA            reduce using rule 139 (resterm -> .)

    resterm                        shift and go to state 143

state 104

    (103) fact -> PLUS . pushop var_cte
    (135) pushop -> .

    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 144

state 105

    (104) fact -> MINUS . pushop var_cte
    (135) pushop -> .

    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 145

state 106

    (98) term -> fact . resfact
    (99) term -> fact . resfact TIMES pushop term
    (100) term -> fact . resfact DIVIDE pushop term
    (138) resfact -> .

    TIMES           reduce using rule 138 (resfact -> .)
    DIVIDE          reduce using rule 138 (resfact -> .)
    PLUS            reduce using rule 138 (resfact -> .)
    MINUS           reduce using rule 138 (resfact -> .)
    LOWERTHAN       reduce using rule 138 (resfact -> .)
    MORETHAN        reduce using rule 138 (resfact -> .)
    LOWEREQ         reduce using rule 138 (resfact -> .)
    MOREEQ          reduce using rule 138 (resfact -> .)
    SAME            reduce using rule 138 (resfact -> .)
    DIFFERENT       reduce using rule 138 (resfact -> .)
    OR              reduce using rule 138 (resfact -> .)
    AND             reduce using rule 138 (resfact -> .)
    RPAREN          reduce using rule 138 (resfact -> .)
    RBRACE          reduce using rule 138 (resfact -> .)
    SEMICOLON       reduce using rule 138 (resfact -> .)
    COMA            reduce using rule 138 (resfact -> .)

    resfact                        shift and go to state 146

state 107

    (102) fact -> var_cte .

    TIMES           reduce using rule 102 (fact -> var_cte .)
    DIVIDE          reduce using rule 102 (fact -> var_cte .)
    PLUS            reduce using rule 102 (fact -> var_cte .)
    MINUS           reduce using rule 102 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 102 (fact -> var_cte .)
    MORETHAN        reduce using rule 102 (fact -> var_cte .)
    LOWEREQ         reduce using rule 102 (fact -> var_cte .)
    MOREEQ          reduce using rule 102 (fact -> var_cte .)
    SAME            reduce using rule 102 (fact -> var_cte .)
    DIFFERENT       reduce using rule 102 (fact -> var_cte .)
    OR              reduce using rule 102 (fact -> var_cte .)
    AND             reduce using rule 102 (fact -> var_cte .)
    RPAREN          reduce using rule 102 (fact -> var_cte .)
    RBRACE          reduce using rule 102 (fact -> var_cte .)
    SEMICOLON       reduce using rule 102 (fact -> var_cte .)
    COMA            reduce using rule 102 (fact -> var_cte .)


state 108

    (113) var_cte -> ID . pushid
    (123) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> ID . pushid LBRACE ex RBRACE
    (134) pushid -> .
    (127) existfunc -> .

    LBRACE          reduce using rule 134 (pushid -> .)
    TIMES           reduce using rule 134 (pushid -> .)
    DIVIDE          reduce using rule 134 (pushid -> .)
    PLUS            reduce using rule 134 (pushid -> .)
    MINUS           reduce using rule 134 (pushid -> .)
    LOWERTHAN       reduce using rule 134 (pushid -> .)
    MORETHAN        reduce using rule 134 (pushid -> .)
    LOWEREQ         reduce using rule 134 (pushid -> .)
    MOREEQ          reduce using rule 134 (pushid -> .)
    SAME            reduce using rule 134 (pushid -> .)
    DIFFERENT       reduce using rule 134 (pushid -> .)
    OR              reduce using rule 134 (pushid -> .)
    AND             reduce using rule 134 (pushid -> .)
    RPAREN          reduce using rule 134 (pushid -> .)
    RBRACE          reduce using rule 134 (pushid -> .)
    COMA            reduce using rule 134 (pushid -> .)
    SEMICOLON       reduce using rule 134 (pushid -> .)
    LPAREN          reduce using rule 127 (existfunc -> .)

    pushid                         shift and go to state 147
    existfunc                      shift and go to state 148

state 109

    (114) var_cte -> CTE_I . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 149

state 110

    (115) var_cte -> CTE_F . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 150

state 111

    (116) var_cte -> CTE_S . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 151

state 112

    (117) var_cte -> TRUE . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 152

state 113

    (118) var_cte -> FALSE . pushcte
    (133) pushcte -> .

    TIMES           reduce using rule 133 (pushcte -> .)
    DIVIDE          reduce using rule 133 (pushcte -> .)
    PLUS            reduce using rule 133 (pushcte -> .)
    MINUS           reduce using rule 133 (pushcte -> .)
    LOWERTHAN       reduce using rule 133 (pushcte -> .)
    MORETHAN        reduce using rule 133 (pushcte -> .)
    LOWEREQ         reduce using rule 133 (pushcte -> .)
    MOREEQ          reduce using rule 133 (pushcte -> .)
    SAME            reduce using rule 133 (pushcte -> .)
    DIFFERENT       reduce using rule 133 (pushcte -> .)
    OR              reduce using rule 133 (pushcte -> .)
    AND             reduce using rule 133 (pushcte -> .)
    RPAREN          reduce using rule 133 (pushcte -> .)
    RBRACE          reduce using rule 133 (pushcte -> .)
    SEMICOLON       reduce using rule 133 (pushcte -> .)
    COMA            reduce using rule 133 (pushcte -> .)

    pushcte                        shift and go to state 153

state 114

    (119) var_cte -> fcall .

    TIMES           reduce using rule 119 (var_cte -> fcall .)
    DIVIDE          reduce using rule 119 (var_cte -> fcall .)
    PLUS            reduce using rule 119 (var_cte -> fcall .)
    MINUS           reduce using rule 119 (var_cte -> fcall .)
    LOWERTHAN       reduce using rule 119 (var_cte -> fcall .)
    MORETHAN        reduce using rule 119 (var_cte -> fcall .)
    LOWEREQ         reduce using rule 119 (var_cte -> fcall .)
    MOREEQ          reduce using rule 119 (var_cte -> fcall .)
    SAME            reduce using rule 119 (var_cte -> fcall .)
    DIFFERENT       reduce using rule 119 (var_cte -> fcall .)
    OR              reduce using rule 119 (var_cte -> fcall .)
    AND             reduce using rule 119 (var_cte -> fcall .)
    RPAREN          reduce using rule 119 (var_cte -> fcall .)
    RBRACE          reduce using rule 119 (var_cte -> fcall .)
    COMA            reduce using rule 119 (var_cte -> fcall .)
    SEMICOLON       reduce using rule 119 (var_cte -> fcall .)


state 115

    (120) var_cte -> fcallvoid .

    TIMES           reduce using rule 120 (var_cte -> fcallvoid .)
    DIVIDE          reduce using rule 120 (var_cte -> fcallvoid .)
    PLUS            reduce using rule 120 (var_cte -> fcallvoid .)
    MINUS           reduce using rule 120 (var_cte -> fcallvoid .)
    LOWERTHAN       reduce using rule 120 (var_cte -> fcallvoid .)
    MORETHAN        reduce using rule 120 (var_cte -> fcallvoid .)
    LOWEREQ         reduce using rule 120 (var_cte -> fcallvoid .)
    MOREEQ          reduce using rule 120 (var_cte -> fcallvoid .)
    SAME            reduce using rule 120 (var_cte -> fcallvoid .)
    DIFFERENT       reduce using rule 120 (var_cte -> fcallvoid .)
    OR              reduce using rule 120 (var_cte -> fcallvoid .)
    AND             reduce using rule 120 (var_cte -> fcallvoid .)
    RPAREN          reduce using rule 120 (var_cte -> fcallvoid .)
    RBRACE          reduce using rule 120 (var_cte -> fcallvoid .)
    SEMICOLON       reduce using rule 120 (var_cte -> fcallvoid .)
    COMA            reduce using rule 120 (var_cte -> fcallvoid .)


state 116

    (121) var_cte -> asigvector .

    TIMES           reduce using rule 121 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 121 (var_cte -> asigvector .)
    PLUS            reduce using rule 121 (var_cte -> asigvector .)
    MINUS           reduce using rule 121 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 121 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 121 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 121 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 121 (var_cte -> asigvector .)
    SAME            reduce using rule 121 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 121 (var_cte -> asigvector .)
    OR              reduce using rule 121 (var_cte -> asigvector .)
    AND             reduce using rule 121 (var_cte -> asigvector .)
    RPAREN          reduce using rule 121 (var_cte -> asigvector .)
    RBRACE          reduce using rule 121 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 121 (var_cte -> asigvector .)
    COMA            reduce using rule 121 (var_cte -> asigvector .)


state 117

    (81) escrit -> PRINT pushop LPAREN . imprimirl escriti RPAREN SEMICOLON
    (84) imprimirl -> .

    LPAREN          reduce using rule 84 (imprimirl -> .)
    PLUS            reduce using rule 84 (imprimirl -> .)
    MINUS           reduce using rule 84 (imprimirl -> .)
    ID              reduce using rule 84 (imprimirl -> .)
    CTE_I           reduce using rule 84 (imprimirl -> .)
    CTE_F           reduce using rule 84 (imprimirl -> .)
    CTE_S           reduce using rule 84 (imprimirl -> .)
    TRUE            reduce using rule 84 (imprimirl -> .)
    FALSE           reduce using rule 84 (imprimirl -> .)

    imprimirl                      shift and go to state 154

state 118

    (87) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 155
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 119

    (88) leer -> READ pushop LPAREN . ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 156


state 120

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 157

state 121

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 122

    (26) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY bloq return1 RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 159
    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163

  ! RPAREN          [ reduce using rule 132 (empty -> .) ]

    funci                          shift and go to state 158
    empty                          shift and go to state 164

state 123

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY bloq RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY bloq RKEY
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 166
    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163

  ! RPAREN          [ reduce using rule 132 (empty -> .) ]

    funci                          shift and go to state 165
    empty                          shift and go to state 164

state 124

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 167


state 125

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 126

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 169


state 127

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 170


state 128

    (76) asign -> ID pushid EQUAL pushop . fcall resolverasignacion
    (77) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 171
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall                          shift and go to state 172
    expres                         shift and go to state 173
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 129

    (78) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres SEMICOLON

    RBRACE          shift and go to state 174


state 130

    (125) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (129) fcall1 -> . expres generateparam
    (130) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 176
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 175
    expres                         shift and go to state 177
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 131

    (101) fact -> LPAREN pushop . expres RPAREN popop
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 178
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 132

    (79) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 179


state 133

    (91) expres -> exr log . expres reslog
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 180
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 134

    (111) log -> OR .

    LPAREN          reduce using rule 111 (log -> OR .)
    PLUS            reduce using rule 111 (log -> OR .)
    MINUS           reduce using rule 111 (log -> OR .)
    ID              reduce using rule 111 (log -> OR .)
    CTE_I           reduce using rule 111 (log -> OR .)
    CTE_F           reduce using rule 111 (log -> OR .)
    CTE_S           reduce using rule 111 (log -> OR .)
    TRUE            reduce using rule 111 (log -> OR .)
    FALSE           reduce using rule 111 (log -> OR .)


state 135

    (112) log -> AND .

    LPAREN          reduce using rule 112 (log -> AND .)
    PLUS            reduce using rule 112 (log -> AND .)
    MINUS           reduce using rule 112 (log -> AND .)
    ID              reduce using rule 112 (log -> AND .)
    CTE_I           reduce using rule 112 (log -> AND .)
    CTE_F           reduce using rule 112 (log -> AND .)
    CTE_S           reduce using rule 112 (log -> AND .)
    TRUE            reduce using rule 112 (log -> AND .)
    FALSE           reduce using rule 112 (log -> AND .)


state 136

    (93) exr -> ex rel . exr resrel
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 102
    exr                            shift and go to state 181
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 137

    (105) rel -> LOWERTHAN .

    LPAREN          reduce using rule 105 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 105 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 105 (rel -> LOWERTHAN .)
    ID              reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 105 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 105 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 105 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 105 (rel -> LOWERTHAN .)


state 138

    (106) rel -> MORETHAN .

    LPAREN          reduce using rule 106 (rel -> MORETHAN .)
    PLUS            reduce using rule 106 (rel -> MORETHAN .)
    MINUS           reduce using rule 106 (rel -> MORETHAN .)
    ID              reduce using rule 106 (rel -> MORETHAN .)
    CTE_I           reduce using rule 106 (rel -> MORETHAN .)
    CTE_F           reduce using rule 106 (rel -> MORETHAN .)
    CTE_S           reduce using rule 106 (rel -> MORETHAN .)
    TRUE            reduce using rule 106 (rel -> MORETHAN .)
    FALSE           reduce using rule 106 (rel -> MORETHAN .)


state 139

    (107) rel -> LOWEREQ .

    LPAREN          reduce using rule 107 (rel -> LOWEREQ .)
    PLUS            reduce using rule 107 (rel -> LOWEREQ .)
    MINUS           reduce using rule 107 (rel -> LOWEREQ .)
    ID              reduce using rule 107 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 107 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 107 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 107 (rel -> LOWEREQ .)
    TRUE            reduce using rule 107 (rel -> LOWEREQ .)
    FALSE           reduce using rule 107 (rel -> LOWEREQ .)


state 140

    (108) rel -> MOREEQ .

    LPAREN          reduce using rule 108 (rel -> MOREEQ .)
    PLUS            reduce using rule 108 (rel -> MOREEQ .)
    MINUS           reduce using rule 108 (rel -> MOREEQ .)
    ID              reduce using rule 108 (rel -> MOREEQ .)
    CTE_I           reduce using rule 108 (rel -> MOREEQ .)
    CTE_F           reduce using rule 108 (rel -> MOREEQ .)
    CTE_S           reduce using rule 108 (rel -> MOREEQ .)
    TRUE            reduce using rule 108 (rel -> MOREEQ .)
    FALSE           reduce using rule 108 (rel -> MOREEQ .)


state 141

    (109) rel -> SAME .

    LPAREN          reduce using rule 109 (rel -> SAME .)
    PLUS            reduce using rule 109 (rel -> SAME .)
    MINUS           reduce using rule 109 (rel -> SAME .)
    ID              reduce using rule 109 (rel -> SAME .)
    CTE_I           reduce using rule 109 (rel -> SAME .)
    CTE_F           reduce using rule 109 (rel -> SAME .)
    CTE_S           reduce using rule 109 (rel -> SAME .)
    TRUE            reduce using rule 109 (rel -> SAME .)
    FALSE           reduce using rule 109 (rel -> SAME .)


state 142

    (110) rel -> DIFFERENT .

    LPAREN          reduce using rule 110 (rel -> DIFFERENT .)
    PLUS            reduce using rule 110 (rel -> DIFFERENT .)
    MINUS           reduce using rule 110 (rel -> DIFFERENT .)
    ID              reduce using rule 110 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 110 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 110 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 110 (rel -> DIFFERENT .)
    TRUE            reduce using rule 110 (rel -> DIFFERENT .)
    FALSE           reduce using rule 110 (rel -> DIFFERENT .)


state 143

    (95) ex -> term resterm .
    (96) ex -> term resterm . PLUS pushop ex
    (97) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 95 (ex -> term resterm .)
    MORETHAN        reduce using rule 95 (ex -> term resterm .)
    LOWEREQ         reduce using rule 95 (ex -> term resterm .)
    MOREEQ          reduce using rule 95 (ex -> term resterm .)
    SAME            reduce using rule 95 (ex -> term resterm .)
    DIFFERENT       reduce using rule 95 (ex -> term resterm .)
    OR              reduce using rule 95 (ex -> term resterm .)
    AND             reduce using rule 95 (ex -> term resterm .)
    RPAREN          reduce using rule 95 (ex -> term resterm .)
    RBRACE          reduce using rule 95 (ex -> term resterm .)
    SEMICOLON       reduce using rule 95 (ex -> term resterm .)
    COMA            reduce using rule 95 (ex -> term resterm .)
    PLUS            shift and go to state 182
    MINUS           shift and go to state 183


state 144

    (103) fact -> PLUS pushop . var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 184
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 145

    (104) fact -> MINUS pushop . var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    var_cte                        shift and go to state 185
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 146

    (98) term -> fact resfact .
    (99) term -> fact resfact . TIMES pushop term
    (100) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 98 (term -> fact resfact .)
    MINUS           reduce using rule 98 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 98 (term -> fact resfact .)
    MORETHAN        reduce using rule 98 (term -> fact resfact .)
    LOWEREQ         reduce using rule 98 (term -> fact resfact .)
    MOREEQ          reduce using rule 98 (term -> fact resfact .)
    SAME            reduce using rule 98 (term -> fact resfact .)
    DIFFERENT       reduce using rule 98 (term -> fact resfact .)
    OR              reduce using rule 98 (term -> fact resfact .)
    AND             reduce using rule 98 (term -> fact resfact .)
    RPAREN          reduce using rule 98 (term -> fact resfact .)
    RBRACE          reduce using rule 98 (term -> fact resfact .)
    SEMICOLON       reduce using rule 98 (term -> fact resfact .)
    COMA            reduce using rule 98 (term -> fact resfact .)
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187


state 147

    (113) var_cte -> ID pushid .
    (122) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 113 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 113 (var_cte -> ID pushid .)
    PLUS            reduce using rule 113 (var_cte -> ID pushid .)
    MINUS           reduce using rule 113 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 113 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 113 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 113 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 113 (var_cte -> ID pushid .)
    SAME            reduce using rule 113 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 113 (var_cte -> ID pushid .)
    OR              reduce using rule 113 (var_cte -> ID pushid .)
    AND             reduce using rule 113 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 113 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 113 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 113 (var_cte -> ID pushid .)
    COMA            reduce using rule 113 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 188


state 148

    (123) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> ID existfunc . LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 189


state 149

    (114) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 114 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 114 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 114 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 114 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 114 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 114 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 114 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 114 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 114 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 114 (var_cte -> CTE_I pushcte .)


state 150

    (115) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 115 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 115 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 115 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 115 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 115 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 115 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 115 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 115 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 115 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 115 (var_cte -> CTE_F pushcte .)


state 151

    (116) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 116 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 116 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 116 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 116 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 116 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 116 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 116 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 116 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 116 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 116 (var_cte -> CTE_S pushcte .)


state 152

    (117) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 117 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 117 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 117 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 117 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 117 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 117 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 117 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 117 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 117 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 117 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 117 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 117 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 117 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 117 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 117 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 117 (var_cte -> TRUE pushcte .)


state 153

    (118) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 118 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 118 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 118 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 118 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 118 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 118 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 118 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 118 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 118 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 118 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 118 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 118 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 118 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 118 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 118 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 118 (var_cte -> FALSE pushcte .)


state 154

    (81) escrit -> PRINT pushop LPAREN imprimirl . escriti RPAREN SEMICOLON
    (82) escriti -> . expres escrit1
    (83) escriti -> . expres escrit2 COMA escriti
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    escriti                        shift and go to state 190
    expres                         shift and go to state 191
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 155

    (87) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 192


state 156

    (88) leer -> READ pushop LPAREN ID . pushid readid RPAREN SEMICOLON
    (134) pushid -> .

    RPAREN          reduce using rule 134 (pushid -> .)

    pushid                         shift and go to state 193

state 157

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 158

    (26) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY bloq return1 RKEY

    RPAREN          shift and go to state 194


state 159

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 195


state 160

    (43) funci -> INT . ID sumparam
    (44) funci -> INT . ID sumparam COMA funci

    ID              shift and go to state 196


state 161

    (45) funci -> FLOAT . ID sumparam
    (46) funci -> FLOAT . ID sumparam COMA funci

    ID              shift and go to state 197


state 162

    (47) funci -> STRING . ID sumparam
    (48) funci -> STRING . ID sumparam COMA funci

    ID              shift and go to state 198


state 163

    (49) funci -> BOOL . ID sumparam
    (50) funci -> BOOL . ID sumparam COMA funci

    ID              shift and go to state 199


state 164

    (51) funci -> empty .

    RPAREN          reduce using rule 51 (funci -> empty .)


state 165

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY bloq RKEY

    RPAREN          shift and go to state 200


state 166

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 201


state 167

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 168

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 169

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)


state 170

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)


state 171

    (123) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (113) var_cte -> ID . pushid
    (125) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> ID . pushid LBRACE ex RBRACE
    (127) existfunc -> .
    (134) pushid -> .

    LPAREN          reduce using rule 127 (existfunc -> .)
    LBRACE          reduce using rule 134 (pushid -> .)
    TIMES           reduce using rule 134 (pushid -> .)
    DIVIDE          reduce using rule 134 (pushid -> .)
    PLUS            reduce using rule 134 (pushid -> .)
    MINUS           reduce using rule 134 (pushid -> .)
    LOWERTHAN       reduce using rule 134 (pushid -> .)
    MORETHAN        reduce using rule 134 (pushid -> .)
    LOWEREQ         reduce using rule 134 (pushid -> .)
    MOREEQ          reduce using rule 134 (pushid -> .)
    SAME            reduce using rule 134 (pushid -> .)
    DIFFERENT       reduce using rule 134 (pushid -> .)
    OR              reduce using rule 134 (pushid -> .)
    AND             reduce using rule 134 (pushid -> .)
    SEMICOLON       reduce using rule 134 (pushid -> .)

    existfunc                      shift and go to state 148
    pushid                         shift and go to state 147

state 172

    (76) asign -> ID pushid EQUAL pushop fcall . resolverasignacion
    (119) var_cte -> fcall .
    (137) resolverasignacion -> .

    TIMES           reduce using rule 119 (var_cte -> fcall .)
    DIVIDE          reduce using rule 119 (var_cte -> fcall .)
    PLUS            reduce using rule 119 (var_cte -> fcall .)
    MINUS           reduce using rule 119 (var_cte -> fcall .)
    LOWERTHAN       reduce using rule 119 (var_cte -> fcall .)
    MORETHAN        reduce using rule 119 (var_cte -> fcall .)
    LOWEREQ         reduce using rule 119 (var_cte -> fcall .)
    MOREEQ          reduce using rule 119 (var_cte -> fcall .)
    SAME            reduce using rule 119 (var_cte -> fcall .)
    DIFFERENT       reduce using rule 119 (var_cte -> fcall .)
    OR              reduce using rule 119 (var_cte -> fcall .)
    AND             reduce using rule 119 (var_cte -> fcall .)
    SEMICOLON       reduce using rule 119 (var_cte -> fcall .)
    ID              reduce using rule 137 (resolverasignacion -> .)
    IF              reduce using rule 137 (resolverasignacion -> .)
    PRINT           reduce using rule 137 (resolverasignacion -> .)
    WHILE           reduce using rule 137 (resolverasignacion -> .)
    READ            reduce using rule 137 (resolverasignacion -> .)
    RKEY            reduce using rule 137 (resolverasignacion -> .)
    RETURN          reduce using rule 137 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 202

state 173

    (77) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (137) resolverasignacion -> .

    SEMICOLON       reduce using rule 137 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 203

state 174

    (78) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 204


state 175

    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 205


state 176

    (126) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 177

    (129) fcall1 -> expres . generateparam
    (130) fcall1 -> expres . generateparam COMA fcall1
    (131) generateparam -> .

    COMA            reduce using rule 131 (generateparam -> .)
    RPAREN          reduce using rule 131 (generateparam -> .)

    generateparam                  shift and go to state 207

state 178

    (101) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 208


state 179

    (79) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (141) resif -> .

    ID              reduce using rule 141 (resif -> .)
    IF              reduce using rule 141 (resif -> .)
    PRINT           reduce using rule 141 (resif -> .)
    WHILE           reduce using rule 141 (resif -> .)
    READ            reduce using rule 141 (resif -> .)

    resif                          shift and go to state 209

state 180

    (91) expres -> exr log expres . reslog
    (94) reslog -> .

    RPAREN          reduce using rule 94 (reslog -> .)
    SEMICOLON       reduce using rule 94 (reslog -> .)
    COMA            reduce using rule 94 (reslog -> .)

    reslog                         shift and go to state 210

state 181

    (93) exr -> ex rel exr . resrel
    (140) resrel -> .

    OR              reduce using rule 140 (resrel -> .)
    AND             reduce using rule 140 (resrel -> .)
    RPAREN          reduce using rule 140 (resrel -> .)
    RBRACE          reduce using rule 140 (resrel -> .)
    SEMICOLON       reduce using rule 140 (resrel -> .)
    COMA            reduce using rule 140 (resrel -> .)

    resrel                         shift and go to state 211

state 182

    (96) ex -> term resterm PLUS . pushop ex
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 212

state 183

    (97) ex -> term resterm MINUS . pushop ex
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 213

state 184

    (103) fact -> PLUS pushop var_cte .

    TIMES           reduce using rule 103 (fact -> PLUS pushop var_cte .)
    DIVIDE          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    PLUS            reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MINUS           reduce using rule 103 (fact -> PLUS pushop var_cte .)
    LOWERTHAN       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MORETHAN        reduce using rule 103 (fact -> PLUS pushop var_cte .)
    LOWEREQ         reduce using rule 103 (fact -> PLUS pushop var_cte .)
    MOREEQ          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    SAME            reduce using rule 103 (fact -> PLUS pushop var_cte .)
    DIFFERENT       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    OR              reduce using rule 103 (fact -> PLUS pushop var_cte .)
    AND             reduce using rule 103 (fact -> PLUS pushop var_cte .)
    RPAREN          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    RBRACE          reduce using rule 103 (fact -> PLUS pushop var_cte .)
    SEMICOLON       reduce using rule 103 (fact -> PLUS pushop var_cte .)
    COMA            reduce using rule 103 (fact -> PLUS pushop var_cte .)


state 185

    (104) fact -> MINUS pushop var_cte .

    TIMES           reduce using rule 104 (fact -> MINUS pushop var_cte .)
    DIVIDE          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    PLUS            reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MINUS           reduce using rule 104 (fact -> MINUS pushop var_cte .)
    LOWERTHAN       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MORETHAN        reduce using rule 104 (fact -> MINUS pushop var_cte .)
    LOWEREQ         reduce using rule 104 (fact -> MINUS pushop var_cte .)
    MOREEQ          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    SAME            reduce using rule 104 (fact -> MINUS pushop var_cte .)
    DIFFERENT       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    OR              reduce using rule 104 (fact -> MINUS pushop var_cte .)
    AND             reduce using rule 104 (fact -> MINUS pushop var_cte .)
    RPAREN          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    RBRACE          reduce using rule 104 (fact -> MINUS pushop var_cte .)
    SEMICOLON       reduce using rule 104 (fact -> MINUS pushop var_cte .)
    COMA            reduce using rule 104 (fact -> MINUS pushop var_cte .)


state 186

    (99) term -> fact resfact TIMES . pushop term
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 214

state 187

    (100) term -> fact resfact DIVIDE . pushop term
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 215

state 188

    (122) asigvector -> ID pushid LBRACE . ex RBRACE
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    ex                             shift and go to state 216
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 189

    (123) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (124) fcall -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (125) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (128) startera -> .

    RPAREN          reduce using rule 128 (startera -> .)
    LPAREN          reduce using rule 128 (startera -> .)
    PLUS            reduce using rule 128 (startera -> .)
    MINUS           reduce using rule 128 (startera -> .)
    ID              reduce using rule 128 (startera -> .)
    CTE_I           reduce using rule 128 (startera -> .)
    CTE_F           reduce using rule 128 (startera -> .)
    CTE_S           reduce using rule 128 (startera -> .)
    TRUE            reduce using rule 128 (startera -> .)
    FALSE           reduce using rule 128 (startera -> .)

    startera                       shift and go to state 217

state 190

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 218


state 191

    (82) escriti -> expres . escrit1
    (83) escriti -> expres . escrit2 COMA escriti
    (85) escrit1 -> .
    (86) escrit2 -> .

    RPAREN          reduce using rule 85 (escrit1 -> .)
    COMA            reduce using rule 86 (escrit2 -> .)

    escrit1                        shift and go to state 219
    escrit2                        shift and go to state 220

state 192

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (145) while2 -> .

    LKEY            reduce using rule 145 (while2 -> .)

    while2                         shift and go to state 221

state 193

    (88) leer -> READ pushop LPAREN ID pushid . readid RPAREN SEMICOLON
    (89) readid -> .

    RPAREN          reduce using rule 89 (readid -> .)

    readid                         shift and go to state 222

state 194

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY bloq return1 RKEY

    LKEY            shift and go to state 223


state 195

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 RKEY
    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . bloq return1 RKEY
    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 225
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 224
    bloq                           shift and go to state 226
    var                            shift and go to state 227
    vector                         shift and go to state 228
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 196

    (43) funci -> INT ID . sumparam
    (44) funci -> INT ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 229

state 197

    (45) funci -> FLOAT ID . sumparam
    (46) funci -> FLOAT ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 230

state 198

    (47) funci -> STRING ID . sumparam
    (48) funci -> STRING ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 231

state 199

    (49) funci -> BOOL ID . sumparam
    (50) funci -> BOOL ID . sumparam COMA funci
    (56) sumparam -> .

    COMA            reduce using rule 56 (sumparam -> .)
    RPAREN          reduce using rule 56 (sumparam -> .)

    sumparam                       shift and go to state 232

state 200

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 233


state 201

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . bloq RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 234
    bloq                           shift and go to state 235
    var                            shift and go to state 227
    vector                         shift and go to state 228
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 202

    (76) asign -> ID pushid EQUAL pushop fcall resolverasignacion .

    ID              reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    IF              reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    PRINT           reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    WHILE           reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    READ            reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    RKEY            reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)
    RETURN          reduce using rule 76 (asign -> ID pushid EQUAL pushop fcall resolverasignacion .)


state 203

    (77) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 236


state 204

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 237

state 205

    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 238


state 206

    (126) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

    ID              reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)


state 207

    (129) fcall1 -> expres generateparam .
    (130) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 129 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 239


state 208

    (101) fact -> LPAREN pushop expres RPAREN . popop
    (136) popop -> .

    TIMES           reduce using rule 136 (popop -> .)
    DIVIDE          reduce using rule 136 (popop -> .)
    PLUS            reduce using rule 136 (popop -> .)
    MINUS           reduce using rule 136 (popop -> .)
    LOWERTHAN       reduce using rule 136 (popop -> .)
    MORETHAN        reduce using rule 136 (popop -> .)
    LOWEREQ         reduce using rule 136 (popop -> .)
    MOREEQ          reduce using rule 136 (popop -> .)
    SAME            reduce using rule 136 (popop -> .)
    DIFFERENT       reduce using rule 136 (popop -> .)
    OR              reduce using rule 136 (popop -> .)
    AND             reduce using rule 136 (popop -> .)
    RPAREN          reduce using rule 136 (popop -> .)
    RBRACE          reduce using rule 136 (popop -> .)
    SEMICOLON       reduce using rule 136 (popop -> .)
    COMA            reduce using rule 136 (popop -> .)

    popop                          shift and go to state 240

state 209

    (79) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 241
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 210

    (91) expres -> exr log expres reslog .

    RPAREN          reduce using rule 91 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 91 (expres -> exr log expres reslog .)
    COMA            reduce using rule 91 (expres -> exr log expres reslog .)


state 211

    (93) exr -> ex rel exr resrel .

    OR              reduce using rule 93 (exr -> ex rel exr resrel .)
    AND             reduce using rule 93 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 93 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 93 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 93 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 93 (exr -> ex rel exr resrel .)


state 212

    (96) ex -> term resterm PLUS pushop . ex
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 242
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 213

    (97) ex -> term resterm MINUS pushop . ex
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    term                           shift and go to state 103
    ex                             shift and go to state 243
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 214

    (99) term -> fact resfact TIMES pushop . term
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 244
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 215

    (100) term -> fact resfact DIVIDE pushop . term
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fact                           shift and go to state 106
    term                           shift and go to state 245
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 216

    (122) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 246


state 217

    (123) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (124) fcall -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (125) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (129) fcall1 -> . expres generateparam
    (130) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 248
    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    fcall1                         shift and go to state 247
    expres                         shift and go to state 177
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 218

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 249


state 219

    (82) escriti -> expres escrit1 .

    RPAREN          reduce using rule 82 (escriti -> expres escrit1 .)


state 220

    (83) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 250


state 221

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 251


state 222

    (88) leer -> READ pushop LPAREN ID pushid readid . RPAREN SEMICOLON

    RPAREN          shift and go to state 252


state 223

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . bloq return1 RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 253
    bloq                           shift and go to state 254
    var                            shift and go to state 227
    vector                         shift and go to state 228
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 224

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 255
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 256
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 225

    (36) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 36 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 36 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 226

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 258
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 257
    empty                          shift and go to state 259

state 227

    (52) localvar -> var .
    (54) localvar -> var . localvar
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 52 (localvar -> var .)
    ID              reduce using rule 52 (localvar -> var .)
    IF              reduce using rule 52 (localvar -> var .)
    PRINT           reduce using rule 52 (localvar -> var .)
    WHILE           reduce using rule 52 (localvar -> var .)
    READ            reduce using rule 52 (localvar -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 227
    localvar                       shift and go to state 260
    vector                         shift and go to state 228

state 228

    (53) localvar -> vector .
    (55) localvar -> vector . localvar
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 53 (localvar -> vector .)
    ID              reduce using rule 53 (localvar -> vector .)
    IF              reduce using rule 53 (localvar -> vector .)
    PRINT           reduce using rule 53 (localvar -> vector .)
    WHILE           reduce using rule 53 (localvar -> vector .)
    READ            reduce using rule 53 (localvar -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 228
    localvar                       shift and go to state 261
    var                            shift and go to state 227

state 229

    (43) funci -> INT ID sumparam .
    (44) funci -> INT ID sumparam . COMA funci

    RPAREN          reduce using rule 43 (funci -> INT ID sumparam .)
    COMA            shift and go to state 262


state 230

    (45) funci -> FLOAT ID sumparam .
    (46) funci -> FLOAT ID sumparam . COMA funci

    RPAREN          reduce using rule 45 (funci -> FLOAT ID sumparam .)
    COMA            shift and go to state 263


state 231

    (47) funci -> STRING ID sumparam .
    (48) funci -> STRING ID sumparam . COMA funci

    RPAREN          reduce using rule 47 (funci -> STRING ID sumparam .)
    COMA            shift and go to state 264


state 232

    (49) funci -> BOOL ID sumparam .
    (50) funci -> BOOL ID sumparam . COMA funci

    RPAREN          reduce using rule 49 (funci -> BOOL ID sumparam .)
    COMA            shift and go to state 265


state 233

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . bloq RKEY
    (52) localvar -> . var
    (53) localvar -> . vector
    (54) localvar -> . var localvar
    (55) localvar -> . vector localvar
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 266
    bloq                           shift and go to state 267
    var                            shift and go to state 227
    vector                         shift and go to state 228
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 234

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 268
    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 269
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 235

    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 270


state 236

    (77) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 77 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 237

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres SEMICOLON
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    exr                            shift and go to state 101
    expres                         shift and go to state 271
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 238

    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

    ID              reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)


state 239

    (130) fcall1 -> expres generateparam COMA . fcall1
    (129) fcall1 -> . expres generateparam
    (130) fcall1 -> . expres generateparam COMA fcall1
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 177
    fcall1                         shift and go to state 272
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 240

    (101) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 101 (fact -> LPAREN pushop expres RPAREN popop .)


state 241

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 273


state 242

    (96) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 96 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 96 (ex -> term resterm PLUS pushop ex .)


state 243

    (97) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 97 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 97 (ex -> term resterm MINUS pushop ex .)


state 244

    (99) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 99 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 99 (term -> fact resfact TIMES pushop term .)


state 245

    (100) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 100 (term -> fact resfact DIVIDE pushop term .)


state 246

    (122) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 122 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 247

    (123) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON
    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 274


state 248

    (124) fcall -> ID existfunc LPAREN startera RPAREN . SEMICOLON
    (126) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 275


state 249

    (81) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .

    ID              reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    IF              reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    READ            reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 81 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)


state 250

    (83) escriti -> expres escrit2 COMA . escriti
    (82) escriti -> . expres escrit1
    (83) escriti -> . expres escrit2 COMA escriti
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 191
    escriti                        shift and go to state 276
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 251

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 277
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 252

    (88) leer -> READ pushop LPAREN ID pushid readid RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 278


state 253

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 279
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 254

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 258
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 280
    empty                          shift and go to state 259

state 255

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 256

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 258
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 281
    empty                          shift and go to state 259

state 257

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 282


state 258

    (57) return1 -> RETURN . pushop expres resreturn SEMICOLON
    (135) pushop -> .

    LPAREN          reduce using rule 135 (pushop -> .)
    PLUS            reduce using rule 135 (pushop -> .)
    MINUS           reduce using rule 135 (pushop -> .)
    ID              reduce using rule 135 (pushop -> .)
    CTE_I           reduce using rule 135 (pushop -> .)
    CTE_F           reduce using rule 135 (pushop -> .)
    CTE_S           reduce using rule 135 (pushop -> .)
    TRUE            reduce using rule 135 (pushop -> .)
    FALSE           reduce using rule 135 (pushop -> .)

    pushop                         shift and go to state 283

state 259

    (58) return1 -> empty .

    RKEY            reduce using rule 58 (return1 -> empty .)


state 260

    (54) localvar -> var localvar .

    RKEY            reduce using rule 54 (localvar -> var localvar .)
    ID              reduce using rule 54 (localvar -> var localvar .)
    IF              reduce using rule 54 (localvar -> var localvar .)
    PRINT           reduce using rule 54 (localvar -> var localvar .)
    WHILE           reduce using rule 54 (localvar -> var localvar .)
    READ            reduce using rule 54 (localvar -> var localvar .)


state 261

    (55) localvar -> vector localvar .

    RKEY            reduce using rule 55 (localvar -> vector localvar .)
    ID              reduce using rule 55 (localvar -> vector localvar .)
    IF              reduce using rule 55 (localvar -> vector localvar .)
    PRINT           reduce using rule 55 (localvar -> vector localvar .)
    WHILE           reduce using rule 55 (localvar -> vector localvar .)
    READ            reduce using rule 55 (localvar -> vector localvar .)


state 262

    (44) funci -> INT ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 284
    empty                          shift and go to state 164

state 263

    (46) funci -> FLOAT ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 285
    empty                          shift and go to state 164

state 264

    (48) funci -> STRING ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 286
    empty                          shift and go to state 164

state 265

    (50) funci -> BOOL ID sumparam COMA . funci
    (43) funci -> . INT ID sumparam
    (44) funci -> . INT ID sumparam COMA funci
    (45) funci -> . FLOAT ID sumparam
    (46) funci -> . FLOAT ID sumparam COMA funci
    (47) funci -> . STRING ID sumparam
    (48) funci -> . STRING ID sumparam COMA funci
    (49) funci -> . BOOL ID sumparam
    (50) funci -> . BOOL ID sumparam COMA funci
    (51) funci -> . empty
    (132) empty -> .

    INT             shift and go to state 160
    FLOAT           shift and go to state 161
    STRING          shift and go to state 162
    BOOL            shift and go to state 163
    RPAREN          reduce using rule 132 (empty -> .)

    funci                          shift and go to state 287
    empty                          shift and go to state 164

state 266

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 288
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 267

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 289


state 268

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 269

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 290


state 270

    (34) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 34 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 34 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)


state 271

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . SEMICOLON

    SEMICOLON       shift and go to state 291


state 272

    (130) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 130 (fcall1 -> expres generateparam COMA fcall1 .)


state 273

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (143) finif -> .

    ELSE            shift and go to state 293
    ID              reduce using rule 143 (finif -> .)
    IF              reduce using rule 143 (finif -> .)
    PRINT           reduce using rule 143 (finif -> .)
    WHILE           reduce using rule 143 (finif -> .)
    READ            reduce using rule 143 (finif -> .)
    RKEY            reduce using rule 143 (finif -> .)
    RETURN          reduce using rule 143 (finif -> .)

    finif                          shift and go to state 292

state 274

    (123) fcall -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON
    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 294


state 275

    (124) fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .
    (126) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

  ! reduce/reduce conflict for TIMES resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PLUS resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MINUS resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LOWERTHAN resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LOWEREQ resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MOREEQ resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SAME resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for OR resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for AND resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RPAREN resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
  ! reduce/reduce conflict for COMA resolved using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    TIMES           reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PLUS            reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    MINUS           reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    LOWERTHAN       reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    MORETHAN        reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    LOWEREQ         reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    MOREEQ          reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    SAME            reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    DIFFERENT       reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    OR              reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    AND             reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RPAREN          reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RBRACE          reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    ID              reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    COMA            reduce using rule 124 (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON .)

  ! TIMES           [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! DIVIDE          [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! PLUS            [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! MINUS           [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! LOWERTHAN       [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! MORETHAN        [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! LOWEREQ         [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! MOREEQ          [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! SAME            [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! DIFFERENT       [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! OR              [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! AND             [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! RPAREN          [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]
  ! COMA            [ reduce using rule 126 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .) ]


state 276

    (83) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 83 (escriti -> expres escrit2 COMA escriti .)


state 277

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 295


state 278

    (88) leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .

    ID              reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    IF              reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    PRINT           reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    WHILE           reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    READ            reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RKEY            reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RETURN          reduce using rule 88 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)


state 279

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 RKEY
    (57) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (58) return1 -> . empty
    (132) empty -> .

    RETURN          shift and go to state 258
    RKEY            reduce using rule 132 (empty -> .)

    return1                        shift and go to state 296
    empty                          shift and go to state 259

state 280

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 297


state 281

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 298


state 282

    (35) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 35 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)


state 283

    (57) return1 -> RETURN pushop . expres resreturn SEMICOLON
    (90) expres -> . exr
    (91) expres -> . exr log expres reslog
    (92) exr -> . ex
    (93) exr -> . ex rel exr resrel
    (95) ex -> . term resterm
    (96) ex -> . term resterm PLUS pushop ex
    (97) ex -> . term resterm MINUS pushop ex
    (98) term -> . fact resfact
    (99) term -> . fact resfact TIMES pushop term
    (100) term -> . fact resfact DIVIDE pushop term
    (101) fact -> . LPAREN pushop expres RPAREN popop
    (102) fact -> . var_cte
    (103) fact -> . PLUS pushop var_cte
    (104) fact -> . MINUS pushop var_cte
    (113) var_cte -> . ID pushid
    (114) var_cte -> . CTE_I pushcte
    (115) var_cte -> . CTE_F pushcte
    (116) var_cte -> . CTE_S pushcte
    (117) var_cte -> . TRUE pushcte
    (118) var_cte -> . FALSE pushcte
    (119) var_cte -> . fcall
    (120) var_cte -> . fcallvoid
    (121) var_cte -> . asigvector
    (123) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (124) fcall -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON
    (122) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 99
    PLUS            shift and go to state 104
    MINUS           shift and go to state 105
    ID              shift and go to state 108
    CTE_I           shift and go to state 109
    CTE_F           shift and go to state 110
    CTE_S           shift and go to state 111
    TRUE            shift and go to state 112
    FALSE           shift and go to state 113

    expres                         shift and go to state 299
    exr                            shift and go to state 101
    ex                             shift and go to state 102
    term                           shift and go to state 103
    fact                           shift and go to state 106
    var_cte                        shift and go to state 107
    fcall                          shift and go to state 114
    fcallvoid                      shift and go to state 115
    asigvector                     shift and go to state 116

state 284

    (44) funci -> INT ID sumparam COMA funci .

    RPAREN          reduce using rule 44 (funci -> INT ID sumparam COMA funci .)


state 285

    (46) funci -> FLOAT ID sumparam COMA funci .

    RPAREN          reduce using rule 46 (funci -> FLOAT ID sumparam COMA funci .)


state 286

    (48) funci -> STRING ID sumparam COMA funci .

    RPAREN          reduce using rule 48 (funci -> STRING ID sumparam COMA funci .)


state 287

    (50) funci -> BOOL ID sumparam COMA funci .

    RPAREN          reduce using rule 50 (funci -> BOOL ID sumparam COMA funci .)


state 288

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 300


state 289

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)


state 290

    (33) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 33 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 291

    (78) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .

    ID              reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    IF              reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    PRINT           reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    WHILE           reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    READ            reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RKEY            reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RETURN          reduce using rule 78 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)


state 292

    (79) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 79 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 293

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 301


state 294

    (123) fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .
    (125) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

  ! reduce/reduce conflict for TIMES resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for PLUS resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MINUS resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LOWERTHAN resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MORETHAN resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for LOWEREQ resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for MOREEQ resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SAME resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for OR resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for AND resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RPAREN resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for RBRACE resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
  ! reduce/reduce conflict for COMA resolved using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    TIMES           reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    DIVIDE          reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PLUS            reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    MINUS           reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    LOWERTHAN       reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    MORETHAN        reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    LOWEREQ         reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    MOREEQ          reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    SAME            reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    DIFFERENT       reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    OR              reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    AND             reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RPAREN          reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RBRACE          reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    ID              reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    COMA            reduce using rule 123 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)

  ! TIMES           [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! DIVIDE          [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! PLUS            [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! MINUS           [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! LOWERTHAN       [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! MORETHAN        [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! LOWEREQ         [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! MOREEQ          [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! SAME            [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! DIFFERENT       [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! OR              [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! AND             [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! RPAREN          [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! RBRACE          [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! SEMICOLON       [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]
  ! COMA            [ reduce using rule 125 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .) ]


state 295

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (146) while3 -> .

    ID              reduce using rule 146 (while3 -> .)
    IF              reduce using rule 146 (while3 -> .)
    PRINT           reduce using rule 146 (while3 -> .)
    WHILE           reduce using rule 146 (while3 -> .)
    READ            reduce using rule 146 (while3 -> .)
    RKEY            reduce using rule 146 (while3 -> .)
    RETURN          reduce using rule 146 (while3 -> .)

    while3                         shift and go to state 302

state 296

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 303


state 297

    (27) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)


state 298

    (32) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 32 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 32 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)


state 299

    (57) return1 -> RETURN pushop expres . resreturn SEMICOLON
    (59) resreturn -> .

    SEMICOLON       reduce using rule 59 (resreturn -> .)

    resreturn                      shift and go to state 304

state 300

    (28) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 301

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (142) reselse -> .

    ID              reduce using rule 142 (reselse -> .)
    IF              reduce using rule 142 (reselse -> .)
    PRINT           reduce using rule 142 (reselse -> .)
    WHILE           reduce using rule 142 (reselse -> .)
    READ            reduce using rule 142 (reselse -> .)

    reselse                        shift and go to state 305

state 302

    (87) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 87 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 303

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)


state 304

    (57) return1 -> RETURN pushop expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 306


state 305

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (68) bloq -> . estat
    (69) bloq -> . estat bloq
    (70) estat -> . asign
    (71) estat -> . cond
    (72) estat -> . escrit
    (73) estat -> . ciclo
    (74) estat -> . leer
    (75) estat -> . fcallvoid
    (76) asign -> . ID pushid EQUAL pushop fcall resolverasignacion
    (77) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (78) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (79) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (80) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (81) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (87) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (88) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (125) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (126) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 62
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 307
    estat                          shift and go to state 53
    asign                          shift and go to state 56
    cond                           shift and go to state 57
    escrit                         shift and go to state 58
    ciclo                          shift and go to state 59
    leer                           shift and go to state 60
    fcallvoid                      shift and go to state 61

state 306

    (57) return1 -> RETURN pushop expres resreturn SEMICOLON .

    RKEY            reduce using rule 57 (return1 -> RETURN pushop expres resreturn SEMICOLON .)


state 307

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 308


state 308

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (143) finif -> .

    ID              reduce using rule 143 (finif -> .)
    IF              reduce using rule 143 (finif -> .)
    PRINT           reduce using rule 143 (finif -> .)
    WHILE           reduce using rule 143 (finif -> .)
    READ            reduce using rule 143 (finif -> .)
    RKEY            reduce using rule 143 (finif -> .)
    RETURN          reduce using rule 143 (finif -> .)

    finif                          shift and go to state 309

state 309

    (80) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 80 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 122 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 123 resolved as shift
WARNING: reduce/reduce conflict in state 275 resolved using rule (fcall -> ID existfunc LPAREN startera RPAREN SEMICOLON)
WARNING: rejected rule (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON) in state 275
WARNING: reduce/reduce conflict in state 294 resolved using rule (fcall -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON)
WARNING: rejected rule (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON) in state 294
