Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 4     gotomain -> <empty>
Rule 5     program2 -> crear program2
Rule 6     program2 -> crear
Rule 7     program3 -> function program3
Rule 8     program3 -> function
Rule 9     llenarmain -> <empty>
Rule 10    crear -> var
Rule 11    crear -> vector
Rule 12    global -> <empty>
Rule 13    finglobal -> <empty>
Rule 14    main1 -> <empty>
Rule 15    finmain -> <empty>
Rule 16    var -> VAR tipo ID SEMICOLON
Rule 17    tipo -> INT
Rule 18    tipo -> FLOAT
Rule 19    tipo -> STRING
Rule 20    tipo -> BOOL
Rule 21    vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 22    vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
Rule 24    vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
Rule 25    initvector -> <empty>
Rule 26    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
Rule 27    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 28    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 29    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
Rule 30    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 31    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 32    functype -> INT
Rule 33    functype -> FLOAT
Rule 34    functype -> STRING
Rule 35    functype -> BOOL
Rule 36    functype -> VOID
Rule 37    addInTable -> <empty>
Rule 38    funci -> INT ID
Rule 39    funci -> INT ID COMA funci
Rule 40    funci -> FLOAT ID
Rule 41    funci -> FLOAT ID COMA funci
Rule 42    funci -> STRING ID
Rule 43    funci -> STRING ID COMA funci
Rule 44    funci -> BOOL ID
Rule 45    funci -> BOOL ID COMA funci
Rule 46    funci -> empty
Rule 47    localvar -> var
Rule 48    localvar -> vector
Rule 49    localvar -> var localvar
Rule 50    localvar -> vector localvar
Rule 51    return1 -> RETURN expres resreturn SEMICOLON
Rule 52    return1 -> empty
Rule 53    resreturn -> <empty>
Rule 54    mainc -> LKEY RKEY
Rule 55    mainc -> LKEY bloq RKEY
Rule 56    mainc -> LKEY mainc2 bloq RKEY
Rule 57    mainc -> LKEY mainc2 RKEY
Rule 58    mainc2 -> var
Rule 59    mainc2 -> var mainc2
Rule 60    mainc2 -> vector
Rule 61    mainc2 -> vector mainc2
Rule 62    bloq -> estat
Rule 63    bloq -> estat bloq
Rule 64    estat -> asign
Rule 65    estat -> cond
Rule 66    estat -> escrit
Rule 67    estat -> ciclo
Rule 68    estat -> leer
Rule 69    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 70    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
Rule 71    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 72    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 73    escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
Rule 74    escriti -> expres escrit1
Rule 75    escriti -> expres escrit2 COMA escriti
Rule 76    imprimirl -> <empty>
Rule 77    escrit1 -> <empty>
Rule 78    escrit2 -> <empty>
Rule 79    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 80    leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON
Rule 81    readid -> <empty>
Rule 82    expres -> exr
Rule 83    expres -> exr log expres reslog
Rule 84    exr -> ex
Rule 85    exr -> ex rel exr resrel
Rule 86    reslog -> <empty>
Rule 87    ex -> term resterm
Rule 88    ex -> term resterm PLUS pushop ex
Rule 89    ex -> term resterm MINUS pushop ex
Rule 90    term -> fact resfact
Rule 91    term -> fact resfact TIMES pushop term
Rule 92    term -> fact resfact DIVIDE pushop term
Rule 93    fact -> LPAREN pushop expres RPAREN popop
Rule 94    fact -> var_cte
Rule 95    fact -> PLUS var_cte
Rule 96    fact -> MINUS var_cte
Rule 97    rel -> LOWERTHAN
Rule 98    rel -> MORETHAN
Rule 99    rel -> LOWEREQ
Rule 100   rel -> MOREEQ
Rule 101   rel -> SAME
Rule 102   rel -> DIFFERENT
Rule 103   log -> OR
Rule 104   log -> AND
Rule 105   var_cte -> ID pushid
Rule 106   var_cte -> CTE_I pushcte
Rule 107   var_cte -> CTE_F pushcte
Rule 108   var_cte -> CTE_S pushcte
Rule 109   var_cte -> TRUE pushcte
Rule 110   var_cte -> FALSE pushcte
Rule 111   var_cte -> fcall
Rule 112   var_cte -> vcall
Rule 113   var_cte -> asigvector
Rule 114   asigvector -> ID pushid LBRACE ex RBRACE
Rule 115   fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
Rule 116   fcall -> ID existfunc LPAREN RPAREN
Rule 117   existfunc -> <empty>
Rule 118   startera -> <empty>
Rule 119   fcall1 -> expres generateparam
Rule 120   fcall1 -> expres generateparam COMA fcall1
Rule 121   generateparam -> <empty>
Rule 122   generateGoSub -> <empty>
Rule 123   vcall -> ID LBRACE expres RBRACE
Rule 124   empty -> <empty>
Rule 125   pushcte -> <empty>
Rule 126   pushid -> <empty>
Rule 127   pushop -> <empty>
Rule 128   popop -> <empty>
Rule 129   resolverasignacion -> <empty>
Rule 130   resfact -> <empty>
Rule 131   resterm -> <empty>
Rule 132   resrel -> <empty>
Rule 133   resif -> <empty>
Rule 134   reselse -> <empty>
Rule 135   finif -> <empty>
Rule 136   while1 -> <empty>
Rule 137   while2 -> <empty>
Rule 138   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 104
BOOL                 : 20 24 35 44 45
COLON                : 1 2 3
COMA                 : 39 41 43 45 75 120
CTE_F                : 107
CTE_I                : 21 22 23 24 106
CTE_S                : 108
DIFFERENT            : 102
DIVIDE               : 92
ELSE                 : 72
EQUAL                : 69 70
FALSE                : 110
FLOAT                : 18 22 33 40 41
FUNCTION             : 26 27 28 29 30 31
ID                   : 16 21 22 23 24 26 27 28 29 30 31 38 39 40 41 42 43 44 45 69 70 80 105 114 115 116 123
IF                   : 71 72
INT                  : 17 21 32 38 39
LBRACE               : 21 22 23 24 70 114 123
LKEY                 : 26 27 28 29 30 31 54 55 56 57 71 72 72 79
LOWEREQ              : 99
LOWERTHAN            : 97
LPAREN               : 26 27 28 29 30 31 71 72 73 79 80 93 115 116
MAIN                 : 1 2 3
MINUS                : 89 96
MOREEQ               : 100
MORETHAN             : 98
OR                   : 103
PLUS                 : 88 95
PRINT                : 73
PROGRAM              : 1 2 3
RBRACE               : 21 22 23 24 70 114 123
READ                 : 80
RETURN               : 51
RKEY                 : 26 27 28 29 30 31 54 55 56 57 71 72 72 79
RPAREN               : 26 27 28 29 30 31 71 72 73 79 80 93 115 116
SAME                 : 101
SEMICOLON            : 16 21 22 23 24 51 69 70 73 80
STRING               : 19 23 34 42 43
TIMES                : 91
TRUE                 : 109
VAR                  : 16
VECTOR               : 21 22 23 24
VOID                 : 36
WHILE                : 79
error                : 

Nonterminals, with rules where they appear

addInTable           : 26 27 28 29 30 31
asign                : 64
asigvector           : 113
bloq                 : 26 28 29 30 55 56 63 71 72 72 79
ciclo                : 67
cond                 : 65
crear                : 5 6
empty                : 46 52
escrit               : 66
escrit1              : 74
escrit2              : 75
escriti              : 73 75
estat                : 62 63
ex                   : 84 85 88 89 114
existfunc            : 115 116
expres               : 26 29 51 69 70 71 72 74 75 79 83 93 119 120 123
exr                  : 70 82 83 85
fact                 : 90 91 92
fcall                : 111
fcall1               : 115 120
finglobal            : 1 2
finif                : 71 72
finmain              : 1 2 3
funci                : 26 28 39 41 43 45
function             : 7 8
functype             : 26 27 28 29 30 31
generateGoSub        : 115
generateparam        : 119 120
global               : 1 2
gotomain             : 1 2 3
imprimirl            : 73
initvector           : 21 22 23 24
leer                 : 68
llenarmain           : 1 2 3
localvar             : 26 27 28 29 30 49 50
log                  : 83
main1                : 1 2 3
mainc                : 1 2 3
mainc2               : 56 57 59 61
popop                : 93
program              : 0
program2             : 1 2 5
program3             : 1 7
pushcte              : 106 107 108 109 110
pushid               : 69 70 80 105 114
pushop               : 69 70 73 80 88 89 91 92 93
readid               : 80
rel                  : 85
reselse              : 72
resfact              : 90 91 92
resif                : 71 72
reslog               : 83
resolverasignacion   : 69
resrel               : 85
resreturn            : 51
resterm              : 87 88 89
return1              : 26 29
startera             : 115
term                 : 87 88 89 91 92
tipo                 : 16
var                  : 10 47 49 58 59
var_cte              : 94 95 96
vcall                : 112
vector               : 11 48 50 60 61
while1               : 79
while2               : 79
while3               : 79

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (4) gotomain -> .

    VAR             reduce using rule 4 (gotomain -> .)
    VECTOR          reduce using rule 4 (gotomain -> .)
    MAIN            reduce using rule 4 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (12) global -> .
    (9) llenarmain -> .

    VAR             reduce using rule 12 (global -> .)
    VECTOR          reduce using rule 12 (global -> .)
    MAIN            reduce using rule 9 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    program2                       shift and go to state 7
    crear                          shift and go to state 8
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 6

    (3) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 13


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (13) finglobal -> .

    FUNCTION        reduce using rule 13 (finglobal -> .)
    MAIN            reduce using rule 13 (finglobal -> .)

    finglobal                      shift and go to state 14

state 8

    (5) program2 -> crear . program2
    (6) program2 -> crear .
    (5) program2 -> . crear program2
    (6) program2 -> . crear
    (10) crear -> . var
    (11) crear -> . vector
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 6 (program2 -> crear .)
    MAIN            reduce using rule 6 (program2 -> crear .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    crear                          shift and go to state 8
    program2                       shift and go to state 15
    var                            shift and go to state 9
    vector                         shift and go to state 10

state 9

    (10) crear -> var .

    VAR             reduce using rule 10 (crear -> var .)
    VECTOR          reduce using rule 10 (crear -> var .)
    FUNCTION        reduce using rule 10 (crear -> var .)
    MAIN            reduce using rule 10 (crear -> var .)


state 10

    (11) crear -> vector .

    VAR             reduce using rule 11 (crear -> vector .)
    VECTOR          reduce using rule 11 (crear -> vector .)
    FUNCTION        reduce using rule 11 (crear -> vector .)
    MAIN            reduce using rule 11 (crear -> vector .)


state 11

    (16) var -> VAR . tipo ID SEMICOLON
    (17) tipo -> . INT
    (18) tipo -> . FLOAT
    (19) tipo -> . STRING
    (20) tipo -> . BOOL

    INT             shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    BOOL            shift and go to state 20

    tipo                           shift and go to state 16

state 12

    (21) vector -> VECTOR . initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR . initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR . initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR . initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (25) initvector -> .

    INT             reduce using rule 25 (initvector -> .)
    FLOAT           reduce using rule 25 (initvector -> .)
    STRING          reduce using rule 25 (initvector -> .)
    BOOL            reduce using rule 25 (initvector -> .)

    initvector                     shift and go to state 21

state 13

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 22

state 14

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (7) program3 -> . function program3
    (8) program3 -> . function
    (9) llenarmain -> .
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (28) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (llenarmain -> .)
    FUNCTION        shift and go to state 26

    program3                       shift and go to state 23
    llenarmain                     shift and go to state 24
    function                       shift and go to state 25

state 15

    (5) program2 -> crear program2 .

    FUNCTION        reduce using rule 5 (program2 -> crear program2 .)
    MAIN            reduce using rule 5 (program2 -> crear program2 .)


state 16

    (16) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 27


state 17

    (17) tipo -> INT .

    ID              reduce using rule 17 (tipo -> INT .)


state 18

    (18) tipo -> FLOAT .

    ID              reduce using rule 18 (tipo -> FLOAT .)


state 19

    (19) tipo -> STRING .

    ID              reduce using rule 19 (tipo -> STRING .)


state 20

    (20) tipo -> BOOL .

    ID              reduce using rule 20 (tipo -> BOOL .)


state 21

    (21) vector -> VECTOR initvector . INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> VECTOR initvector . FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> VECTOR initvector . STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> VECTOR initvector . BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    STRING          shift and go to state 30
    BOOL            shift and go to state 31


state 22

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (54) mainc -> . LKEY RKEY
    (55) mainc -> . LKEY bloq RKEY
    (56) mainc -> . LKEY mainc2 bloq RKEY
    (57) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 32

state 23

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (9) llenarmain -> .

    MAIN            reduce using rule 9 (llenarmain -> .)

    llenarmain                     shift and go to state 34

state 24

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 35


state 25

    (7) program3 -> function . program3
    (8) program3 -> function .
    (7) program3 -> . function program3
    (8) program3 -> . function
    (26) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (28) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 8 (program3 -> function .)
    FUNCTION        shift and go to state 26

    function                       shift and go to state 25
    program3                       shift and go to state 36

state 26

    (26) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (28) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (32) functype -> . INT
    (33) functype -> . FLOAT
    (34) functype -> . STRING
    (35) functype -> . BOOL
    (36) functype -> . VOID

    INT             shift and go to state 38
    FLOAT           shift and go to state 39
    STRING          shift and go to state 40
    BOOL            shift and go to state 41
    VOID            shift and go to state 42

    functype                       shift and go to state 37

state 27

    (16) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 43


state 28

    (21) vector -> VECTOR initvector INT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 44


state 29

    (22) vector -> VECTOR initvector FLOAT . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 45


state 30

    (23) vector -> VECTOR initvector STRING . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 46


state 31

    (24) vector -> VECTOR initvector BOOL . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 47


state 32

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 48

state 33

    (54) mainc -> LKEY . RKEY
    (55) mainc -> LKEY . bloq RKEY
    (56) mainc -> LKEY . mainc2 bloq RKEY
    (57) mainc -> LKEY . mainc2 RKEY
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (58) mainc2 -> . var
    (59) mainc2 -> . var mainc2
    (60) mainc2 -> . vector
    (61) mainc2 -> . vector mainc2
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    RKEY            shift and go to state 49
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12
    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 50
    mainc2                         shift and go to state 51
    estat                          shift and go to state 52
    var                            shift and go to state 53
    vector                         shift and go to state 54
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 34

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 65


state 35

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 66

state 36

    (7) program3 -> function program3 .

    MAIN            reduce using rule 7 (program3 -> function program3 .)


state 37

    (26) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (28) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 67


state 38

    (32) functype -> INT .

    ID              reduce using rule 32 (functype -> INT .)


state 39

    (33) functype -> FLOAT .

    ID              reduce using rule 33 (functype -> FLOAT .)


state 40

    (34) functype -> STRING .

    ID              reduce using rule 34 (functype -> STRING .)


state 41

    (35) functype -> BOOL .

    ID              reduce using rule 35 (functype -> BOOL .)


state 42

    (36) functype -> VOID .

    ID              reduce using rule 36 (functype -> VOID .)


state 43

    (16) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 16 (var -> VAR tipo ID SEMICOLON .)


state 44

    (21) vector -> VECTOR initvector INT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 68


state 45

    (22) vector -> VECTOR initvector FLOAT ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 69


state 46

    (23) vector -> VECTOR initvector STRING ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 70


state 47

    (24) vector -> VECTOR initvector BOOL ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 71


state 48

    (3) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 49

    (54) mainc -> LKEY RKEY .

    $end            reduce using rule 54 (mainc -> LKEY RKEY .)


state 50

    (55) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 72


state 51

    (56) mainc -> LKEY mainc2 . bloq RKEY
    (57) mainc -> LKEY mainc2 . RKEY
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    RKEY            shift and go to state 74
    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 73
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 52

    (62) bloq -> estat .
    (63) bloq -> estat . bloq
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

  ! shift/reduce conflict for ID resolved as shift
    RKEY            reduce using rule 62 (bloq -> estat .)
    RETURN          reduce using rule 62 (bloq -> estat .)
    LPAREN          reduce using rule 62 (bloq -> estat .)
    PLUS            reduce using rule 62 (bloq -> estat .)
    MINUS           reduce using rule 62 (bloq -> estat .)
    CTE_I           reduce using rule 62 (bloq -> estat .)
    CTE_F           reduce using rule 62 (bloq -> estat .)
    CTE_S           reduce using rule 62 (bloq -> estat .)
    TRUE            reduce using rule 62 (bloq -> estat .)
    FALSE           reduce using rule 62 (bloq -> estat .)
    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

  ! ID              [ reduce using rule 62 (bloq -> estat .) ]

    estat                          shift and go to state 52
    bloq                           shift and go to state 75
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 53

    (58) mainc2 -> var .
    (59) mainc2 -> var . mainc2
    (58) mainc2 -> . var
    (59) mainc2 -> . var mainc2
    (60) mainc2 -> . vector
    (61) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 58 (mainc2 -> var .)
    ID              reduce using rule 58 (mainc2 -> var .)
    IF              reduce using rule 58 (mainc2 -> var .)
    PRINT           reduce using rule 58 (mainc2 -> var .)
    WHILE           reduce using rule 58 (mainc2 -> var .)
    READ            reduce using rule 58 (mainc2 -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 53
    mainc2                         shift and go to state 76
    vector                         shift and go to state 54

state 54

    (60) mainc2 -> vector .
    (61) mainc2 -> vector . mainc2
    (58) mainc2 -> . var
    (59) mainc2 -> . var mainc2
    (60) mainc2 -> . vector
    (61) mainc2 -> . vector mainc2
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 60 (mainc2 -> vector .)
    ID              reduce using rule 60 (mainc2 -> vector .)
    IF              reduce using rule 60 (mainc2 -> vector .)
    PRINT           reduce using rule 60 (mainc2 -> vector .)
    WHILE           reduce using rule 60 (mainc2 -> vector .)
    READ            reduce using rule 60 (mainc2 -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 54
    mainc2                         shift and go to state 77
    var                            shift and go to state 53

state 55

    (64) estat -> asign .

    ID              reduce using rule 64 (estat -> asign .)
    IF              reduce using rule 64 (estat -> asign .)
    PRINT           reduce using rule 64 (estat -> asign .)
    WHILE           reduce using rule 64 (estat -> asign .)
    READ            reduce using rule 64 (estat -> asign .)
    RKEY            reduce using rule 64 (estat -> asign .)
    RETURN          reduce using rule 64 (estat -> asign .)
    LPAREN          reduce using rule 64 (estat -> asign .)
    PLUS            reduce using rule 64 (estat -> asign .)
    MINUS           reduce using rule 64 (estat -> asign .)
    CTE_I           reduce using rule 64 (estat -> asign .)
    CTE_F           reduce using rule 64 (estat -> asign .)
    CTE_S           reduce using rule 64 (estat -> asign .)
    TRUE            reduce using rule 64 (estat -> asign .)
    FALSE           reduce using rule 64 (estat -> asign .)


state 56

    (65) estat -> cond .

    ID              reduce using rule 65 (estat -> cond .)
    IF              reduce using rule 65 (estat -> cond .)
    PRINT           reduce using rule 65 (estat -> cond .)
    WHILE           reduce using rule 65 (estat -> cond .)
    READ            reduce using rule 65 (estat -> cond .)
    RKEY            reduce using rule 65 (estat -> cond .)
    RETURN          reduce using rule 65 (estat -> cond .)
    LPAREN          reduce using rule 65 (estat -> cond .)
    PLUS            reduce using rule 65 (estat -> cond .)
    MINUS           reduce using rule 65 (estat -> cond .)
    CTE_I           reduce using rule 65 (estat -> cond .)
    CTE_F           reduce using rule 65 (estat -> cond .)
    CTE_S           reduce using rule 65 (estat -> cond .)
    TRUE            reduce using rule 65 (estat -> cond .)
    FALSE           reduce using rule 65 (estat -> cond .)


state 57

    (66) estat -> escrit .

    ID              reduce using rule 66 (estat -> escrit .)
    IF              reduce using rule 66 (estat -> escrit .)
    PRINT           reduce using rule 66 (estat -> escrit .)
    WHILE           reduce using rule 66 (estat -> escrit .)
    READ            reduce using rule 66 (estat -> escrit .)
    RKEY            reduce using rule 66 (estat -> escrit .)
    RETURN          reduce using rule 66 (estat -> escrit .)
    LPAREN          reduce using rule 66 (estat -> escrit .)
    PLUS            reduce using rule 66 (estat -> escrit .)
    MINUS           reduce using rule 66 (estat -> escrit .)
    CTE_I           reduce using rule 66 (estat -> escrit .)
    CTE_F           reduce using rule 66 (estat -> escrit .)
    CTE_S           reduce using rule 66 (estat -> escrit .)
    TRUE            reduce using rule 66 (estat -> escrit .)
    FALSE           reduce using rule 66 (estat -> escrit .)


state 58

    (67) estat -> ciclo .

    ID              reduce using rule 67 (estat -> ciclo .)
    IF              reduce using rule 67 (estat -> ciclo .)
    PRINT           reduce using rule 67 (estat -> ciclo .)
    WHILE           reduce using rule 67 (estat -> ciclo .)
    READ            reduce using rule 67 (estat -> ciclo .)
    RKEY            reduce using rule 67 (estat -> ciclo .)
    RETURN          reduce using rule 67 (estat -> ciclo .)
    LPAREN          reduce using rule 67 (estat -> ciclo .)
    PLUS            reduce using rule 67 (estat -> ciclo .)
    MINUS           reduce using rule 67 (estat -> ciclo .)
    CTE_I           reduce using rule 67 (estat -> ciclo .)
    CTE_F           reduce using rule 67 (estat -> ciclo .)
    CTE_S           reduce using rule 67 (estat -> ciclo .)
    TRUE            reduce using rule 67 (estat -> ciclo .)
    FALSE           reduce using rule 67 (estat -> ciclo .)


state 59

    (68) estat -> leer .

    ID              reduce using rule 68 (estat -> leer .)
    IF              reduce using rule 68 (estat -> leer .)
    PRINT           reduce using rule 68 (estat -> leer .)
    WHILE           reduce using rule 68 (estat -> leer .)
    READ            reduce using rule 68 (estat -> leer .)
    RKEY            reduce using rule 68 (estat -> leer .)
    RETURN          reduce using rule 68 (estat -> leer .)
    LPAREN          reduce using rule 68 (estat -> leer .)
    PLUS            reduce using rule 68 (estat -> leer .)
    MINUS           reduce using rule 68 (estat -> leer .)
    CTE_I           reduce using rule 68 (estat -> leer .)
    CTE_F           reduce using rule 68 (estat -> leer .)
    CTE_S           reduce using rule 68 (estat -> leer .)
    TRUE            reduce using rule 68 (estat -> leer .)
    FALSE           reduce using rule 68 (estat -> leer .)


state 60

    (69) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (126) pushid -> .

    EQUAL           reduce using rule 126 (pushid -> .)
    LBRACE          reduce using rule 126 (pushid -> .)

    pushid                         shift and go to state 78

state 61

    (71) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 79


state 62

    (73) escrit -> PRINT . pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 80

state 63

    (79) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (136) while1 -> .

    LPAREN          reduce using rule 136 (while1 -> .)

    while1                         shift and go to state 81

state 64

    (80) leer -> READ . pushop LPAREN ID pushid readid RPAREN SEMICOLON
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 82

state 65

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (14) main1 -> .

    LKEY            reduce using rule 14 (main1 -> .)

    main1                          shift and go to state 83

state 66

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (54) mainc -> . LKEY RKEY
    (55) mainc -> . LKEY bloq RKEY
    (56) mainc -> . LKEY mainc2 bloq RKEY
    (57) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 84

state 67

    (26) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (28) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (37) addInTable -> .

    LPAREN          reduce using rule 37 (addInTable -> .)

    addInTable                     shift and go to state 85

state 68

    (21) vector -> VECTOR initvector INT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 86


state 69

    (22) vector -> VECTOR initvector FLOAT ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 87


state 70

    (23) vector -> VECTOR initvector STRING ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 88


state 71

    (24) vector -> VECTOR initvector BOOL ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 89


state 72

    (55) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 55 (mainc -> LKEY bloq RKEY .)


state 73

    (56) mainc -> LKEY mainc2 bloq . RKEY

    RKEY            shift and go to state 90


state 74

    (57) mainc -> LKEY mainc2 RKEY .

    $end            reduce using rule 57 (mainc -> LKEY mainc2 RKEY .)


state 75

    (63) bloq -> estat bloq .

    RKEY            reduce using rule 63 (bloq -> estat bloq .)
    RETURN          reduce using rule 63 (bloq -> estat bloq .)
    LPAREN          reduce using rule 63 (bloq -> estat bloq .)
    PLUS            reduce using rule 63 (bloq -> estat bloq .)
    MINUS           reduce using rule 63 (bloq -> estat bloq .)
    ID              reduce using rule 63 (bloq -> estat bloq .)
    CTE_I           reduce using rule 63 (bloq -> estat bloq .)
    CTE_F           reduce using rule 63 (bloq -> estat bloq .)
    CTE_S           reduce using rule 63 (bloq -> estat bloq .)
    TRUE            reduce using rule 63 (bloq -> estat bloq .)
    FALSE           reduce using rule 63 (bloq -> estat bloq .)


state 76

    (59) mainc2 -> var mainc2 .

    RKEY            reduce using rule 59 (mainc2 -> var mainc2 .)
    ID              reduce using rule 59 (mainc2 -> var mainc2 .)
    IF              reduce using rule 59 (mainc2 -> var mainc2 .)
    PRINT           reduce using rule 59 (mainc2 -> var mainc2 .)
    WHILE           reduce using rule 59 (mainc2 -> var mainc2 .)
    READ            reduce using rule 59 (mainc2 -> var mainc2 .)


state 77

    (61) mainc2 -> vector mainc2 .

    RKEY            reduce using rule 61 (mainc2 -> vector mainc2 .)
    ID              reduce using rule 61 (mainc2 -> vector mainc2 .)
    IF              reduce using rule 61 (mainc2 -> vector mainc2 .)
    PRINT           reduce using rule 61 (mainc2 -> vector mainc2 .)
    WHILE           reduce using rule 61 (mainc2 -> vector mainc2 .)
    READ            reduce using rule 61 (mainc2 -> vector mainc2 .)


state 78

    (69) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 91
    LBRACE          shift and go to state 92


state 79

    (71) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 94
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 80

    (73) escrit -> PRINT pushop . LPAREN imprimirl escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 111


state 81

    (79) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 112


state 82

    (80) leer -> READ pushop . LPAREN ID pushid readid RPAREN SEMICOLON

    LPAREN          shift and go to state 113


state 83

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (54) mainc -> . LKEY RKEY
    (55) mainc -> . LKEY bloq RKEY
    (56) mainc -> . LKEY mainc2 bloq RKEY
    (57) mainc -> . LKEY mainc2 RKEY

    LKEY            shift and go to state 33

    mainc                          shift and go to state 114

state 84

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 115

state 85

    (26) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (28) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (31) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 116


state 86

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 117


state 87

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 118


state 88

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 119


state 89

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 120


state 90

    (56) mainc -> LKEY mainc2 bloq RKEY .

    $end            reduce using rule 56 (mainc -> LKEY mainc2 bloq RKEY .)


state 91

    (69) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 121

state 92

    (70) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres SEMICOLON
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    exr                            shift and go to state 122
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 93

    (93) fact -> LPAREN . pushop expres RPAREN popop
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 123

state 94

    (71) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (72) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 124


state 95

    (82) expres -> exr .
    (83) expres -> exr . log expres reslog
    (103) log -> . OR
    (104) log -> . AND

    RPAREN          reduce using rule 82 (expres -> exr .)
    SEMICOLON       reduce using rule 82 (expres -> exr .)
    RBRACE          reduce using rule 82 (expres -> exr .)
    COMA            reduce using rule 82 (expres -> exr .)
    RKEY            reduce using rule 82 (expres -> exr .)
    OR              shift and go to state 126
    AND             shift and go to state 127

    log                            shift and go to state 125

state 96

    (84) exr -> ex .
    (85) exr -> ex . rel exr resrel
    (97) rel -> . LOWERTHAN
    (98) rel -> . MORETHAN
    (99) rel -> . LOWEREQ
    (100) rel -> . MOREEQ
    (101) rel -> . SAME
    (102) rel -> . DIFFERENT

    OR              reduce using rule 84 (exr -> ex .)
    AND             reduce using rule 84 (exr -> ex .)
    RPAREN          reduce using rule 84 (exr -> ex .)
    RBRACE          reduce using rule 84 (exr -> ex .)
    SEMICOLON       reduce using rule 84 (exr -> ex .)
    COMA            reduce using rule 84 (exr -> ex .)
    RKEY            reduce using rule 84 (exr -> ex .)
    LOWERTHAN       shift and go to state 129
    MORETHAN        shift and go to state 130
    LOWEREQ         shift and go to state 131
    MOREEQ          shift and go to state 132
    SAME            shift and go to state 133
    DIFFERENT       shift and go to state 134

    rel                            shift and go to state 128

state 97

    (87) ex -> term . resterm
    (88) ex -> term . resterm PLUS pushop ex
    (89) ex -> term . resterm MINUS pushop ex
    (131) resterm -> .

    PLUS            reduce using rule 131 (resterm -> .)
    MINUS           reduce using rule 131 (resterm -> .)
    LOWERTHAN       reduce using rule 131 (resterm -> .)
    MORETHAN        reduce using rule 131 (resterm -> .)
    LOWEREQ         reduce using rule 131 (resterm -> .)
    MOREEQ          reduce using rule 131 (resterm -> .)
    SAME            reduce using rule 131 (resterm -> .)
    DIFFERENT       reduce using rule 131 (resterm -> .)
    OR              reduce using rule 131 (resterm -> .)
    AND             reduce using rule 131 (resterm -> .)
    RPAREN          reduce using rule 131 (resterm -> .)
    RBRACE          reduce using rule 131 (resterm -> .)
    SEMICOLON       reduce using rule 131 (resterm -> .)
    COMA            reduce using rule 131 (resterm -> .)
    RKEY            reduce using rule 131 (resterm -> .)

    resterm                        shift and go to state 135

state 98

    (95) fact -> PLUS . var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    var_cte                        shift and go to state 136
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 99

    (96) fact -> MINUS . var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    var_cte                        shift and go to state 137
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 100

    (90) term -> fact . resfact
    (91) term -> fact . resfact TIMES pushop term
    (92) term -> fact . resfact DIVIDE pushop term
    (130) resfact -> .

    TIMES           reduce using rule 130 (resfact -> .)
    DIVIDE          reduce using rule 130 (resfact -> .)
    PLUS            reduce using rule 130 (resfact -> .)
    MINUS           reduce using rule 130 (resfact -> .)
    LOWERTHAN       reduce using rule 130 (resfact -> .)
    MORETHAN        reduce using rule 130 (resfact -> .)
    LOWEREQ         reduce using rule 130 (resfact -> .)
    MOREEQ          reduce using rule 130 (resfact -> .)
    SAME            reduce using rule 130 (resfact -> .)
    DIFFERENT       reduce using rule 130 (resfact -> .)
    OR              reduce using rule 130 (resfact -> .)
    AND             reduce using rule 130 (resfact -> .)
    RPAREN          reduce using rule 130 (resfact -> .)
    RBRACE          reduce using rule 130 (resfact -> .)
    SEMICOLON       reduce using rule 130 (resfact -> .)
    COMA            reduce using rule 130 (resfact -> .)
    RKEY            reduce using rule 130 (resfact -> .)

    resfact                        shift and go to state 138

state 101

    (94) fact -> var_cte .

    TIMES           reduce using rule 94 (fact -> var_cte .)
    DIVIDE          reduce using rule 94 (fact -> var_cte .)
    PLUS            reduce using rule 94 (fact -> var_cte .)
    MINUS           reduce using rule 94 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 94 (fact -> var_cte .)
    MORETHAN        reduce using rule 94 (fact -> var_cte .)
    LOWEREQ         reduce using rule 94 (fact -> var_cte .)
    MOREEQ          reduce using rule 94 (fact -> var_cte .)
    SAME            reduce using rule 94 (fact -> var_cte .)
    DIFFERENT       reduce using rule 94 (fact -> var_cte .)
    OR              reduce using rule 94 (fact -> var_cte .)
    AND             reduce using rule 94 (fact -> var_cte .)
    RPAREN          reduce using rule 94 (fact -> var_cte .)
    RBRACE          reduce using rule 94 (fact -> var_cte .)
    SEMICOLON       reduce using rule 94 (fact -> var_cte .)
    COMA            reduce using rule 94 (fact -> var_cte .)
    RKEY            reduce using rule 94 (fact -> var_cte .)


state 102

    (105) var_cte -> ID . pushid
    (115) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> ID . existfunc LPAREN RPAREN
    (123) vcall -> ID . LBRACE expres RBRACE
    (114) asigvector -> ID . pushid LBRACE ex RBRACE
    (126) pushid -> .
    (117) existfunc -> .

  ! shift/reduce conflict for LBRACE resolved as shift
    LBRACE          shift and go to state 141
    TIMES           reduce using rule 126 (pushid -> .)
    DIVIDE          reduce using rule 126 (pushid -> .)
    PLUS            reduce using rule 126 (pushid -> .)
    MINUS           reduce using rule 126 (pushid -> .)
    LOWERTHAN       reduce using rule 126 (pushid -> .)
    MORETHAN        reduce using rule 126 (pushid -> .)
    LOWEREQ         reduce using rule 126 (pushid -> .)
    MOREEQ          reduce using rule 126 (pushid -> .)
    SAME            reduce using rule 126 (pushid -> .)
    DIFFERENT       reduce using rule 126 (pushid -> .)
    OR              reduce using rule 126 (pushid -> .)
    AND             reduce using rule 126 (pushid -> .)
    RPAREN          reduce using rule 126 (pushid -> .)
    RBRACE          reduce using rule 126 (pushid -> .)
    SEMICOLON       reduce using rule 126 (pushid -> .)
    COMA            reduce using rule 126 (pushid -> .)
    RKEY            reduce using rule 126 (pushid -> .)
    LPAREN          reduce using rule 117 (existfunc -> .)

  ! LBRACE          [ reduce using rule 126 (pushid -> .) ]

    pushid                         shift and go to state 139
    existfunc                      shift and go to state 140

state 103

    (106) var_cte -> CTE_I . pushcte
    (125) pushcte -> .

    TIMES           reduce using rule 125 (pushcte -> .)
    DIVIDE          reduce using rule 125 (pushcte -> .)
    PLUS            reduce using rule 125 (pushcte -> .)
    MINUS           reduce using rule 125 (pushcte -> .)
    LOWERTHAN       reduce using rule 125 (pushcte -> .)
    MORETHAN        reduce using rule 125 (pushcte -> .)
    LOWEREQ         reduce using rule 125 (pushcte -> .)
    MOREEQ          reduce using rule 125 (pushcte -> .)
    SAME            reduce using rule 125 (pushcte -> .)
    DIFFERENT       reduce using rule 125 (pushcte -> .)
    OR              reduce using rule 125 (pushcte -> .)
    AND             reduce using rule 125 (pushcte -> .)
    RPAREN          reduce using rule 125 (pushcte -> .)
    RBRACE          reduce using rule 125 (pushcte -> .)
    SEMICOLON       reduce using rule 125 (pushcte -> .)
    COMA            reduce using rule 125 (pushcte -> .)
    RKEY            reduce using rule 125 (pushcte -> .)

    pushcte                        shift and go to state 142

state 104

    (107) var_cte -> CTE_F . pushcte
    (125) pushcte -> .

    TIMES           reduce using rule 125 (pushcte -> .)
    DIVIDE          reduce using rule 125 (pushcte -> .)
    PLUS            reduce using rule 125 (pushcte -> .)
    MINUS           reduce using rule 125 (pushcte -> .)
    LOWERTHAN       reduce using rule 125 (pushcte -> .)
    MORETHAN        reduce using rule 125 (pushcte -> .)
    LOWEREQ         reduce using rule 125 (pushcte -> .)
    MOREEQ          reduce using rule 125 (pushcte -> .)
    SAME            reduce using rule 125 (pushcte -> .)
    DIFFERENT       reduce using rule 125 (pushcte -> .)
    OR              reduce using rule 125 (pushcte -> .)
    AND             reduce using rule 125 (pushcte -> .)
    RPAREN          reduce using rule 125 (pushcte -> .)
    RBRACE          reduce using rule 125 (pushcte -> .)
    SEMICOLON       reduce using rule 125 (pushcte -> .)
    COMA            reduce using rule 125 (pushcte -> .)
    RKEY            reduce using rule 125 (pushcte -> .)

    pushcte                        shift and go to state 143

state 105

    (108) var_cte -> CTE_S . pushcte
    (125) pushcte -> .

    TIMES           reduce using rule 125 (pushcte -> .)
    DIVIDE          reduce using rule 125 (pushcte -> .)
    PLUS            reduce using rule 125 (pushcte -> .)
    MINUS           reduce using rule 125 (pushcte -> .)
    LOWERTHAN       reduce using rule 125 (pushcte -> .)
    MORETHAN        reduce using rule 125 (pushcte -> .)
    LOWEREQ         reduce using rule 125 (pushcte -> .)
    MOREEQ          reduce using rule 125 (pushcte -> .)
    SAME            reduce using rule 125 (pushcte -> .)
    DIFFERENT       reduce using rule 125 (pushcte -> .)
    OR              reduce using rule 125 (pushcte -> .)
    AND             reduce using rule 125 (pushcte -> .)
    RPAREN          reduce using rule 125 (pushcte -> .)
    RBRACE          reduce using rule 125 (pushcte -> .)
    SEMICOLON       reduce using rule 125 (pushcte -> .)
    COMA            reduce using rule 125 (pushcte -> .)
    RKEY            reduce using rule 125 (pushcte -> .)

    pushcte                        shift and go to state 144

state 106

    (109) var_cte -> TRUE . pushcte
    (125) pushcte -> .

    TIMES           reduce using rule 125 (pushcte -> .)
    DIVIDE          reduce using rule 125 (pushcte -> .)
    PLUS            reduce using rule 125 (pushcte -> .)
    MINUS           reduce using rule 125 (pushcte -> .)
    LOWERTHAN       reduce using rule 125 (pushcte -> .)
    MORETHAN        reduce using rule 125 (pushcte -> .)
    LOWEREQ         reduce using rule 125 (pushcte -> .)
    MOREEQ          reduce using rule 125 (pushcte -> .)
    SAME            reduce using rule 125 (pushcte -> .)
    DIFFERENT       reduce using rule 125 (pushcte -> .)
    OR              reduce using rule 125 (pushcte -> .)
    AND             reduce using rule 125 (pushcte -> .)
    RPAREN          reduce using rule 125 (pushcte -> .)
    RBRACE          reduce using rule 125 (pushcte -> .)
    SEMICOLON       reduce using rule 125 (pushcte -> .)
    COMA            reduce using rule 125 (pushcte -> .)
    RKEY            reduce using rule 125 (pushcte -> .)

    pushcte                        shift and go to state 145

state 107

    (110) var_cte -> FALSE . pushcte
    (125) pushcte -> .

    TIMES           reduce using rule 125 (pushcte -> .)
    DIVIDE          reduce using rule 125 (pushcte -> .)
    PLUS            reduce using rule 125 (pushcte -> .)
    MINUS           reduce using rule 125 (pushcte -> .)
    LOWERTHAN       reduce using rule 125 (pushcte -> .)
    MORETHAN        reduce using rule 125 (pushcte -> .)
    LOWEREQ         reduce using rule 125 (pushcte -> .)
    MOREEQ          reduce using rule 125 (pushcte -> .)
    SAME            reduce using rule 125 (pushcte -> .)
    DIFFERENT       reduce using rule 125 (pushcte -> .)
    OR              reduce using rule 125 (pushcte -> .)
    AND             reduce using rule 125 (pushcte -> .)
    RPAREN          reduce using rule 125 (pushcte -> .)
    RBRACE          reduce using rule 125 (pushcte -> .)
    SEMICOLON       reduce using rule 125 (pushcte -> .)
    COMA            reduce using rule 125 (pushcte -> .)
    RKEY            reduce using rule 125 (pushcte -> .)

    pushcte                        shift and go to state 146

state 108

    (111) var_cte -> fcall .

    TIMES           reduce using rule 111 (var_cte -> fcall .)
    DIVIDE          reduce using rule 111 (var_cte -> fcall .)
    PLUS            reduce using rule 111 (var_cte -> fcall .)
    MINUS           reduce using rule 111 (var_cte -> fcall .)
    LOWERTHAN       reduce using rule 111 (var_cte -> fcall .)
    MORETHAN        reduce using rule 111 (var_cte -> fcall .)
    LOWEREQ         reduce using rule 111 (var_cte -> fcall .)
    MOREEQ          reduce using rule 111 (var_cte -> fcall .)
    SAME            reduce using rule 111 (var_cte -> fcall .)
    DIFFERENT       reduce using rule 111 (var_cte -> fcall .)
    OR              reduce using rule 111 (var_cte -> fcall .)
    AND             reduce using rule 111 (var_cte -> fcall .)
    RPAREN          reduce using rule 111 (var_cte -> fcall .)
    RBRACE          reduce using rule 111 (var_cte -> fcall .)
    SEMICOLON       reduce using rule 111 (var_cte -> fcall .)
    COMA            reduce using rule 111 (var_cte -> fcall .)
    RKEY            reduce using rule 111 (var_cte -> fcall .)


state 109

    (112) var_cte -> vcall .

    TIMES           reduce using rule 112 (var_cte -> vcall .)
    DIVIDE          reduce using rule 112 (var_cte -> vcall .)
    PLUS            reduce using rule 112 (var_cte -> vcall .)
    MINUS           reduce using rule 112 (var_cte -> vcall .)
    LOWERTHAN       reduce using rule 112 (var_cte -> vcall .)
    MORETHAN        reduce using rule 112 (var_cte -> vcall .)
    LOWEREQ         reduce using rule 112 (var_cte -> vcall .)
    MOREEQ          reduce using rule 112 (var_cte -> vcall .)
    SAME            reduce using rule 112 (var_cte -> vcall .)
    DIFFERENT       reduce using rule 112 (var_cte -> vcall .)
    OR              reduce using rule 112 (var_cte -> vcall .)
    AND             reduce using rule 112 (var_cte -> vcall .)
    RPAREN          reduce using rule 112 (var_cte -> vcall .)
    RBRACE          reduce using rule 112 (var_cte -> vcall .)
    SEMICOLON       reduce using rule 112 (var_cte -> vcall .)
    COMA            reduce using rule 112 (var_cte -> vcall .)
    RKEY            reduce using rule 112 (var_cte -> vcall .)


state 110

    (113) var_cte -> asigvector .

    TIMES           reduce using rule 113 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 113 (var_cte -> asigvector .)
    PLUS            reduce using rule 113 (var_cte -> asigvector .)
    MINUS           reduce using rule 113 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 113 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 113 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 113 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 113 (var_cte -> asigvector .)
    SAME            reduce using rule 113 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 113 (var_cte -> asigvector .)
    OR              reduce using rule 113 (var_cte -> asigvector .)
    AND             reduce using rule 113 (var_cte -> asigvector .)
    RPAREN          reduce using rule 113 (var_cte -> asigvector .)
    RBRACE          reduce using rule 113 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 113 (var_cte -> asigvector .)
    COMA            reduce using rule 113 (var_cte -> asigvector .)
    RKEY            reduce using rule 113 (var_cte -> asigvector .)


state 111

    (73) escrit -> PRINT pushop LPAREN . imprimirl escriti RPAREN SEMICOLON
    (76) imprimirl -> .

    LPAREN          reduce using rule 76 (imprimirl -> .)
    PLUS            reduce using rule 76 (imprimirl -> .)
    MINUS           reduce using rule 76 (imprimirl -> .)
    ID              reduce using rule 76 (imprimirl -> .)
    CTE_I           reduce using rule 76 (imprimirl -> .)
    CTE_F           reduce using rule 76 (imprimirl -> .)
    CTE_S           reduce using rule 76 (imprimirl -> .)
    TRUE            reduce using rule 76 (imprimirl -> .)
    FALSE           reduce using rule 76 (imprimirl -> .)

    imprimirl                      shift and go to state 147

state 112

    (79) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 148
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 113

    (80) leer -> READ pushop LPAREN . ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 149


state 114

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (15) finmain -> .

    $end            reduce using rule 15 (finmain -> .)

    finmain                        shift and go to state 150

state 115

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 116

    (26) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 expres RKEY
    (27) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (38) funci -> . INT ID
    (39) funci -> . INT ID COMA funci
    (40) funci -> . FLOAT ID
    (41) funci -> . FLOAT ID COMA funci
    (42) funci -> . STRING ID
    (43) funci -> . STRING ID COMA funci
    (44) funci -> . BOOL ID
    (45) funci -> . BOOL ID COMA funci
    (46) funci -> . empty
    (124) empty -> .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 152
    INT             shift and go to state 153
    FLOAT           shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156

  ! RPAREN          [ reduce using rule 124 (empty -> .) ]

    funci                          shift and go to state 151
    empty                          shift and go to state 157

state 117

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 158


state 118

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 159


state 119

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 160


state 120

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 161


state 121

    (69) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 162
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 122

    (70) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres SEMICOLON

    RBRACE          shift and go to state 163


state 123

    (93) fact -> LPAREN pushop . expres RPAREN popop
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 164
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 124

    (71) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (72) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 165


state 125

    (83) expres -> exr log . expres reslog
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    exr                            shift and go to state 95
    expres                         shift and go to state 166
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 126

    (103) log -> OR .

    LPAREN          reduce using rule 103 (log -> OR .)
    PLUS            reduce using rule 103 (log -> OR .)
    MINUS           reduce using rule 103 (log -> OR .)
    ID              reduce using rule 103 (log -> OR .)
    CTE_I           reduce using rule 103 (log -> OR .)
    CTE_F           reduce using rule 103 (log -> OR .)
    CTE_S           reduce using rule 103 (log -> OR .)
    TRUE            reduce using rule 103 (log -> OR .)
    FALSE           reduce using rule 103 (log -> OR .)


state 127

    (104) log -> AND .

    LPAREN          reduce using rule 104 (log -> AND .)
    PLUS            reduce using rule 104 (log -> AND .)
    MINUS           reduce using rule 104 (log -> AND .)
    ID              reduce using rule 104 (log -> AND .)
    CTE_I           reduce using rule 104 (log -> AND .)
    CTE_F           reduce using rule 104 (log -> AND .)
    CTE_S           reduce using rule 104 (log -> AND .)
    TRUE            reduce using rule 104 (log -> AND .)
    FALSE           reduce using rule 104 (log -> AND .)


state 128

    (85) exr -> ex rel . exr resrel
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    ex                             shift and go to state 96
    exr                            shift and go to state 167
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 129

    (97) rel -> LOWERTHAN .

    LPAREN          reduce using rule 97 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 97 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 97 (rel -> LOWERTHAN .)
    ID              reduce using rule 97 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 97 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 97 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 97 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 97 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 97 (rel -> LOWERTHAN .)


state 130

    (98) rel -> MORETHAN .

    LPAREN          reduce using rule 98 (rel -> MORETHAN .)
    PLUS            reduce using rule 98 (rel -> MORETHAN .)
    MINUS           reduce using rule 98 (rel -> MORETHAN .)
    ID              reduce using rule 98 (rel -> MORETHAN .)
    CTE_I           reduce using rule 98 (rel -> MORETHAN .)
    CTE_F           reduce using rule 98 (rel -> MORETHAN .)
    CTE_S           reduce using rule 98 (rel -> MORETHAN .)
    TRUE            reduce using rule 98 (rel -> MORETHAN .)
    FALSE           reduce using rule 98 (rel -> MORETHAN .)


state 131

    (99) rel -> LOWEREQ .

    LPAREN          reduce using rule 99 (rel -> LOWEREQ .)
    PLUS            reduce using rule 99 (rel -> LOWEREQ .)
    MINUS           reduce using rule 99 (rel -> LOWEREQ .)
    ID              reduce using rule 99 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 99 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 99 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 99 (rel -> LOWEREQ .)
    TRUE            reduce using rule 99 (rel -> LOWEREQ .)
    FALSE           reduce using rule 99 (rel -> LOWEREQ .)


state 132

    (100) rel -> MOREEQ .

    LPAREN          reduce using rule 100 (rel -> MOREEQ .)
    PLUS            reduce using rule 100 (rel -> MOREEQ .)
    MINUS           reduce using rule 100 (rel -> MOREEQ .)
    ID              reduce using rule 100 (rel -> MOREEQ .)
    CTE_I           reduce using rule 100 (rel -> MOREEQ .)
    CTE_F           reduce using rule 100 (rel -> MOREEQ .)
    CTE_S           reduce using rule 100 (rel -> MOREEQ .)
    TRUE            reduce using rule 100 (rel -> MOREEQ .)
    FALSE           reduce using rule 100 (rel -> MOREEQ .)


state 133

    (101) rel -> SAME .

    LPAREN          reduce using rule 101 (rel -> SAME .)
    PLUS            reduce using rule 101 (rel -> SAME .)
    MINUS           reduce using rule 101 (rel -> SAME .)
    ID              reduce using rule 101 (rel -> SAME .)
    CTE_I           reduce using rule 101 (rel -> SAME .)
    CTE_F           reduce using rule 101 (rel -> SAME .)
    CTE_S           reduce using rule 101 (rel -> SAME .)
    TRUE            reduce using rule 101 (rel -> SAME .)
    FALSE           reduce using rule 101 (rel -> SAME .)


state 134

    (102) rel -> DIFFERENT .

    LPAREN          reduce using rule 102 (rel -> DIFFERENT .)
    PLUS            reduce using rule 102 (rel -> DIFFERENT .)
    MINUS           reduce using rule 102 (rel -> DIFFERENT .)
    ID              reduce using rule 102 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 102 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 102 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 102 (rel -> DIFFERENT .)
    TRUE            reduce using rule 102 (rel -> DIFFERENT .)
    FALSE           reduce using rule 102 (rel -> DIFFERENT .)


state 135

    (87) ex -> term resterm .
    (88) ex -> term resterm . PLUS pushop ex
    (89) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 87 (ex -> term resterm .)
    MORETHAN        reduce using rule 87 (ex -> term resterm .)
    LOWEREQ         reduce using rule 87 (ex -> term resterm .)
    MOREEQ          reduce using rule 87 (ex -> term resterm .)
    SAME            reduce using rule 87 (ex -> term resterm .)
    DIFFERENT       reduce using rule 87 (ex -> term resterm .)
    OR              reduce using rule 87 (ex -> term resterm .)
    AND             reduce using rule 87 (ex -> term resterm .)
    RPAREN          reduce using rule 87 (ex -> term resterm .)
    RBRACE          reduce using rule 87 (ex -> term resterm .)
    SEMICOLON       reduce using rule 87 (ex -> term resterm .)
    COMA            reduce using rule 87 (ex -> term resterm .)
    RKEY            reduce using rule 87 (ex -> term resterm .)
    PLUS            shift and go to state 168
    MINUS           shift and go to state 169


state 136

    (95) fact -> PLUS var_cte .

    TIMES           reduce using rule 95 (fact -> PLUS var_cte .)
    DIVIDE          reduce using rule 95 (fact -> PLUS var_cte .)
    PLUS            reduce using rule 95 (fact -> PLUS var_cte .)
    MINUS           reduce using rule 95 (fact -> PLUS var_cte .)
    LOWERTHAN       reduce using rule 95 (fact -> PLUS var_cte .)
    MORETHAN        reduce using rule 95 (fact -> PLUS var_cte .)
    LOWEREQ         reduce using rule 95 (fact -> PLUS var_cte .)
    MOREEQ          reduce using rule 95 (fact -> PLUS var_cte .)
    SAME            reduce using rule 95 (fact -> PLUS var_cte .)
    DIFFERENT       reduce using rule 95 (fact -> PLUS var_cte .)
    OR              reduce using rule 95 (fact -> PLUS var_cte .)
    AND             reduce using rule 95 (fact -> PLUS var_cte .)
    RPAREN          reduce using rule 95 (fact -> PLUS var_cte .)
    RBRACE          reduce using rule 95 (fact -> PLUS var_cte .)
    SEMICOLON       reduce using rule 95 (fact -> PLUS var_cte .)
    COMA            reduce using rule 95 (fact -> PLUS var_cte .)
    RKEY            reduce using rule 95 (fact -> PLUS var_cte .)


state 137

    (96) fact -> MINUS var_cte .

    TIMES           reduce using rule 96 (fact -> MINUS var_cte .)
    DIVIDE          reduce using rule 96 (fact -> MINUS var_cte .)
    PLUS            reduce using rule 96 (fact -> MINUS var_cte .)
    MINUS           reduce using rule 96 (fact -> MINUS var_cte .)
    LOWERTHAN       reduce using rule 96 (fact -> MINUS var_cte .)
    MORETHAN        reduce using rule 96 (fact -> MINUS var_cte .)
    LOWEREQ         reduce using rule 96 (fact -> MINUS var_cte .)
    MOREEQ          reduce using rule 96 (fact -> MINUS var_cte .)
    SAME            reduce using rule 96 (fact -> MINUS var_cte .)
    DIFFERENT       reduce using rule 96 (fact -> MINUS var_cte .)
    OR              reduce using rule 96 (fact -> MINUS var_cte .)
    AND             reduce using rule 96 (fact -> MINUS var_cte .)
    RPAREN          reduce using rule 96 (fact -> MINUS var_cte .)
    RBRACE          reduce using rule 96 (fact -> MINUS var_cte .)
    SEMICOLON       reduce using rule 96 (fact -> MINUS var_cte .)
    COMA            reduce using rule 96 (fact -> MINUS var_cte .)
    RKEY            reduce using rule 96 (fact -> MINUS var_cte .)


state 138

    (90) term -> fact resfact .
    (91) term -> fact resfact . TIMES pushop term
    (92) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 90 (term -> fact resfact .)
    MINUS           reduce using rule 90 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 90 (term -> fact resfact .)
    MORETHAN        reduce using rule 90 (term -> fact resfact .)
    LOWEREQ         reduce using rule 90 (term -> fact resfact .)
    MOREEQ          reduce using rule 90 (term -> fact resfact .)
    SAME            reduce using rule 90 (term -> fact resfact .)
    DIFFERENT       reduce using rule 90 (term -> fact resfact .)
    OR              reduce using rule 90 (term -> fact resfact .)
    AND             reduce using rule 90 (term -> fact resfact .)
    RPAREN          reduce using rule 90 (term -> fact resfact .)
    RBRACE          reduce using rule 90 (term -> fact resfact .)
    SEMICOLON       reduce using rule 90 (term -> fact resfact .)
    COMA            reduce using rule 90 (term -> fact resfact .)
    RKEY            reduce using rule 90 (term -> fact resfact .)
    TIMES           shift and go to state 170
    DIVIDE          shift and go to state 171


state 139

    (105) var_cte -> ID pushid .
    (114) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 105 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 105 (var_cte -> ID pushid .)
    PLUS            reduce using rule 105 (var_cte -> ID pushid .)
    MINUS           reduce using rule 105 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 105 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 105 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 105 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 105 (var_cte -> ID pushid .)
    SAME            reduce using rule 105 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 105 (var_cte -> ID pushid .)
    OR              reduce using rule 105 (var_cte -> ID pushid .)
    AND             reduce using rule 105 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 105 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 105 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 105 (var_cte -> ID pushid .)
    COMA            reduce using rule 105 (var_cte -> ID pushid .)
    RKEY            reduce using rule 105 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 172


state 140

    (115) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> ID existfunc . LPAREN RPAREN

    LPAREN          shift and go to state 173


state 141

    (123) vcall -> ID LBRACE . expres RBRACE
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 174
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 142

    (106) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 106 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 106 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 106 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 106 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 106 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 106 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 106 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 106 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 106 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 106 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 106 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 106 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 106 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 106 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 106 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 106 (var_cte -> CTE_I pushcte .)
    RKEY            reduce using rule 106 (var_cte -> CTE_I pushcte .)


state 143

    (107) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 107 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 107 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 107 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 107 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 107 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 107 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 107 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 107 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 107 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 107 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 107 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 107 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 107 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 107 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 107 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 107 (var_cte -> CTE_F pushcte .)
    RKEY            reduce using rule 107 (var_cte -> CTE_F pushcte .)


state 144

    (108) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 108 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 108 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 108 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 108 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 108 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 108 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 108 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 108 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 108 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 108 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 108 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 108 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 108 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 108 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 108 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 108 (var_cte -> CTE_S pushcte .)
    RKEY            reduce using rule 108 (var_cte -> CTE_S pushcte .)


state 145

    (109) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 109 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 109 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 109 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 109 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 109 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 109 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 109 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 109 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 109 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 109 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 109 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 109 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 109 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 109 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 109 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 109 (var_cte -> TRUE pushcte .)
    RKEY            reduce using rule 109 (var_cte -> TRUE pushcte .)


state 146

    (110) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 110 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 110 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 110 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 110 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 110 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 110 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 110 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 110 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 110 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 110 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 110 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 110 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 110 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 110 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 110 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 110 (var_cte -> FALSE pushcte .)
    RKEY            reduce using rule 110 (var_cte -> FALSE pushcte .)


state 147

    (73) escrit -> PRINT pushop LPAREN imprimirl . escriti RPAREN SEMICOLON
    (74) escriti -> . expres escrit1
    (75) escriti -> . expres escrit2 COMA escriti
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    escriti                        shift and go to state 175
    expres                         shift and go to state 176
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 148

    (79) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 177


state 149

    (80) leer -> READ pushop LPAREN ID . pushid readid RPAREN SEMICOLON
    (126) pushid -> .

    RPAREN          reduce using rule 126 (pushid -> .)

    pushid                         shift and go to state 178

state 150

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 151

    (26) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 expres RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY

    RPAREN          shift and go to state 179


state 152

    (27) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 180


state 153

    (38) funci -> INT . ID
    (39) funci -> INT . ID COMA funci

    ID              shift and go to state 181


state 154

    (40) funci -> FLOAT . ID
    (41) funci -> FLOAT . ID COMA funci

    ID              shift and go to state 182


state 155

    (42) funci -> STRING . ID
    (43) funci -> STRING . ID COMA funci

    ID              shift and go to state 183


state 156

    (44) funci -> BOOL . ID
    (45) funci -> BOOL . ID COMA funci

    ID              shift and go to state 184


state 157

    (46) funci -> empty .

    RPAREN          reduce using rule 46 (funci -> empty .)


state 158

    (21) vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 21 (vector -> VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 159

    (22) vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON .)


state 160

    (23) vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 23 (vector -> VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON .)


state 161

    (24) vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 24 (vector -> VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON .)


state 162

    (69) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (129) resolverasignacion -> .

    SEMICOLON       reduce using rule 129 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 185

state 163

    (70) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres SEMICOLON

    EQUAL           shift and go to state 186


state 164

    (93) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 187


state 165

    (71) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (72) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (133) resif -> .

    ID              reduce using rule 133 (resif -> .)
    IF              reduce using rule 133 (resif -> .)
    PRINT           reduce using rule 133 (resif -> .)
    WHILE           reduce using rule 133 (resif -> .)
    READ            reduce using rule 133 (resif -> .)

    resif                          shift and go to state 188

state 166

    (83) expres -> exr log expres . reslog
    (86) reslog -> .

    RPAREN          reduce using rule 86 (reslog -> .)
    SEMICOLON       reduce using rule 86 (reslog -> .)
    RBRACE          reduce using rule 86 (reslog -> .)
    COMA            reduce using rule 86 (reslog -> .)
    RKEY            reduce using rule 86 (reslog -> .)

    reslog                         shift and go to state 189

state 167

    (85) exr -> ex rel exr . resrel
    (132) resrel -> .

    OR              reduce using rule 132 (resrel -> .)
    AND             reduce using rule 132 (resrel -> .)
    RPAREN          reduce using rule 132 (resrel -> .)
    RBRACE          reduce using rule 132 (resrel -> .)
    SEMICOLON       reduce using rule 132 (resrel -> .)
    COMA            reduce using rule 132 (resrel -> .)
    RKEY            reduce using rule 132 (resrel -> .)

    resrel                         shift and go to state 190

state 168

    (88) ex -> term resterm PLUS . pushop ex
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 191

state 169

    (89) ex -> term resterm MINUS . pushop ex
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 192

state 170

    (91) term -> fact resfact TIMES . pushop term
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 193

state 171

    (92) term -> fact resfact DIVIDE . pushop term
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 194

state 172

    (114) asigvector -> ID pushid LBRACE . ex RBRACE
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    ex                             shift and go to state 195
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 173

    (115) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN generateGoSub
    (116) fcall -> ID existfunc LPAREN . RPAREN
    (118) startera -> .

    RPAREN          shift and go to state 197
    LPAREN          reduce using rule 118 (startera -> .)
    PLUS            reduce using rule 118 (startera -> .)
    MINUS           reduce using rule 118 (startera -> .)
    ID              reduce using rule 118 (startera -> .)
    CTE_I           reduce using rule 118 (startera -> .)
    CTE_F           reduce using rule 118 (startera -> .)
    CTE_S           reduce using rule 118 (startera -> .)
    TRUE            reduce using rule 118 (startera -> .)
    FALSE           reduce using rule 118 (startera -> .)

    startera                       shift and go to state 196

state 174

    (123) vcall -> ID LBRACE expres . RBRACE

    RBRACE          shift and go to state 198


state 175

    (73) escrit -> PRINT pushop LPAREN imprimirl escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 199


state 176

    (74) escriti -> expres . escrit1
    (75) escriti -> expres . escrit2 COMA escriti
    (77) escrit1 -> .
    (78) escrit2 -> .

    RPAREN          reduce using rule 77 (escrit1 -> .)
    COMA            reduce using rule 78 (escrit2 -> .)

    escrit1                        shift and go to state 200
    escrit2                        shift and go to state 201

state 177

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (137) while2 -> .

    LKEY            reduce using rule 137 (while2 -> .)

    while2                         shift and go to state 202

state 178

    (80) leer -> READ pushop LPAREN ID pushid . readid RPAREN SEMICOLON
    (81) readid -> .

    RPAREN          reduce using rule 81 (readid -> .)

    readid                         shift and go to state 203

state 179

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 expres RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY

    LKEY            shift and go to state 204


state 180

    (27) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (47) localvar -> . var
    (48) localvar -> . vector
    (49) localvar -> . var localvar
    (50) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            shift and go to state 206
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    localvar                       shift and go to state 205
    var                            shift and go to state 207
    vector                         shift and go to state 208

state 181

    (38) funci -> INT ID .
    (39) funci -> INT ID . COMA funci

    RPAREN          reduce using rule 38 (funci -> INT ID .)
    COMA            shift and go to state 209


state 182

    (40) funci -> FLOAT ID .
    (41) funci -> FLOAT ID . COMA funci

    RPAREN          reduce using rule 40 (funci -> FLOAT ID .)
    COMA            shift and go to state 210


state 183

    (42) funci -> STRING ID .
    (43) funci -> STRING ID . COMA funci

    RPAREN          reduce using rule 42 (funci -> STRING ID .)
    COMA            shift and go to state 211


state 184

    (44) funci -> BOOL ID .
    (45) funci -> BOOL ID . COMA funci

    RPAREN          reduce using rule 44 (funci -> BOOL ID .)
    COMA            shift and go to state 212


state 185

    (69) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 213


state 186

    (70) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres SEMICOLON
    (127) pushop -> .

    LPAREN          reduce using rule 127 (pushop -> .)
    PLUS            reduce using rule 127 (pushop -> .)
    MINUS           reduce using rule 127 (pushop -> .)
    ID              reduce using rule 127 (pushop -> .)
    CTE_I           reduce using rule 127 (pushop -> .)
    CTE_F           reduce using rule 127 (pushop -> .)
    CTE_S           reduce using rule 127 (pushop -> .)
    TRUE            reduce using rule 127 (pushop -> .)
    FALSE           reduce using rule 127 (pushop -> .)

    pushop                         shift and go to state 214

state 187

    (93) fact -> LPAREN pushop expres RPAREN . popop
    (128) popop -> .

    TIMES           reduce using rule 128 (popop -> .)
    DIVIDE          reduce using rule 128 (popop -> .)
    PLUS            reduce using rule 128 (popop -> .)
    MINUS           reduce using rule 128 (popop -> .)
    LOWERTHAN       reduce using rule 128 (popop -> .)
    MORETHAN        reduce using rule 128 (popop -> .)
    LOWEREQ         reduce using rule 128 (popop -> .)
    MOREEQ          reduce using rule 128 (popop -> .)
    SAME            reduce using rule 128 (popop -> .)
    DIFFERENT       reduce using rule 128 (popop -> .)
    OR              reduce using rule 128 (popop -> .)
    AND             reduce using rule 128 (popop -> .)
    RPAREN          reduce using rule 128 (popop -> .)
    RBRACE          reduce using rule 128 (popop -> .)
    SEMICOLON       reduce using rule 128 (popop -> .)
    COMA            reduce using rule 128 (popop -> .)
    RKEY            reduce using rule 128 (popop -> .)

    popop                          shift and go to state 215

state 188

    (71) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (72) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 216
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 189

    (83) expres -> exr log expres reslog .

    RPAREN          reduce using rule 83 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 83 (expres -> exr log expres reslog .)
    RBRACE          reduce using rule 83 (expres -> exr log expres reslog .)
    COMA            reduce using rule 83 (expres -> exr log expres reslog .)
    RKEY            reduce using rule 83 (expres -> exr log expres reslog .)


state 190

    (85) exr -> ex rel exr resrel .

    OR              reduce using rule 85 (exr -> ex rel exr resrel .)
    AND             reduce using rule 85 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 85 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 85 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 85 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 85 (exr -> ex rel exr resrel .)
    RKEY            reduce using rule 85 (exr -> ex rel exr resrel .)


state 191

    (88) ex -> term resterm PLUS pushop . ex
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    term                           shift and go to state 97
    ex                             shift and go to state 217
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 192

    (89) ex -> term resterm MINUS pushop . ex
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    term                           shift and go to state 97
    ex                             shift and go to state 218
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 193

    (91) term -> fact resfact TIMES pushop . term
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    fact                           shift and go to state 100
    term                           shift and go to state 219
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 194

    (92) term -> fact resfact DIVIDE pushop . term
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    fact                           shift and go to state 100
    term                           shift and go to state 220
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 195

    (114) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 221


state 196

    (115) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN generateGoSub
    (119) fcall1 -> . expres generateparam
    (120) fcall1 -> . expres generateparam COMA fcall1
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    fcall1                         shift and go to state 222
    expres                         shift and go to state 223
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 197

    (116) fcall -> ID existfunc LPAREN RPAREN .

    TIMES           reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    DIVIDE          reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    PLUS            reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    MINUS           reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    LOWERTHAN       reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    MORETHAN        reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    LOWEREQ         reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    MOREEQ          reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    SAME            reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    DIFFERENT       reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    OR              reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    AND             reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    RPAREN          reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    RBRACE          reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    SEMICOLON       reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    COMA            reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)
    RKEY            reduce using rule 116 (fcall -> ID existfunc LPAREN RPAREN .)


state 198

    (123) vcall -> ID LBRACE expres RBRACE .

    TIMES           reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    DIVIDE          reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    PLUS            reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    MINUS           reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    LOWERTHAN       reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    MORETHAN        reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    LOWEREQ         reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    MOREEQ          reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    SAME            reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    DIFFERENT       reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    OR              reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    AND             reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    RPAREN          reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    RBRACE          reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    SEMICOLON       reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    COMA            reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)
    RKEY            reduce using rule 123 (vcall -> ID LBRACE expres RBRACE .)


state 199

    (73) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 224


state 200

    (74) escriti -> expres escrit1 .

    RPAREN          reduce using rule 74 (escriti -> expres escrit1 .)


state 201

    (75) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 225


state 202

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 226


state 203

    (80) leer -> READ pushop LPAREN ID pushid readid . RPAREN SEMICOLON

    RPAREN          shift and go to state 227


state 204

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 expres RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (47) localvar -> . var
    (48) localvar -> . vector
    (49) localvar -> . var localvar
    (50) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    localvar                       shift and go to state 228
    var                            shift and go to state 207
    vector                         shift and go to state 208

state 205

    (27) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    RKEY            shift and go to state 229
    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 230
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 206

    (31) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 207

    (47) localvar -> var .
    (49) localvar -> var . localvar
    (47) localvar -> . var
    (48) localvar -> . vector
    (49) localvar -> . var localvar
    (50) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 47 (localvar -> var .)
    ID              reduce using rule 47 (localvar -> var .)
    IF              reduce using rule 47 (localvar -> var .)
    PRINT           reduce using rule 47 (localvar -> var .)
    WHILE           reduce using rule 47 (localvar -> var .)
    READ            reduce using rule 47 (localvar -> var .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    var                            shift and go to state 207
    localvar                       shift and go to state 231
    vector                         shift and go to state 208

state 208

    (48) localvar -> vector .
    (50) localvar -> vector . localvar
    (47) localvar -> . var
    (48) localvar -> . vector
    (49) localvar -> . var localvar
    (50) localvar -> . vector localvar
    (16) var -> . VAR tipo ID SEMICOLON
    (21) vector -> . VECTOR initvector INT ID LBRACE CTE_I RBRACE SEMICOLON
    (22) vector -> . VECTOR initvector FLOAT ID LBRACE CTE_I RBRACE SEMICOLON
    (23) vector -> . VECTOR initvector STRING ID LBRACE CTE_I RBRACE SEMICOLON
    (24) vector -> . VECTOR initvector BOOL ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 48 (localvar -> vector .)
    ID              reduce using rule 48 (localvar -> vector .)
    IF              reduce using rule 48 (localvar -> vector .)
    PRINT           reduce using rule 48 (localvar -> vector .)
    WHILE           reduce using rule 48 (localvar -> vector .)
    READ            reduce using rule 48 (localvar -> vector .)
    VAR             shift and go to state 11
    VECTOR          shift and go to state 12

    vector                         shift and go to state 208
    localvar                       shift and go to state 232
    var                            shift and go to state 207

state 209

    (39) funci -> INT ID COMA . funci
    (38) funci -> . INT ID
    (39) funci -> . INT ID COMA funci
    (40) funci -> . FLOAT ID
    (41) funci -> . FLOAT ID COMA funci
    (42) funci -> . STRING ID
    (43) funci -> . STRING ID COMA funci
    (44) funci -> . BOOL ID
    (45) funci -> . BOOL ID COMA funci
    (46) funci -> . empty
    (124) empty -> .

    INT             shift and go to state 153
    FLOAT           shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156
    RPAREN          reduce using rule 124 (empty -> .)

    funci                          shift and go to state 233
    empty                          shift and go to state 157

state 210

    (41) funci -> FLOAT ID COMA . funci
    (38) funci -> . INT ID
    (39) funci -> . INT ID COMA funci
    (40) funci -> . FLOAT ID
    (41) funci -> . FLOAT ID COMA funci
    (42) funci -> . STRING ID
    (43) funci -> . STRING ID COMA funci
    (44) funci -> . BOOL ID
    (45) funci -> . BOOL ID COMA funci
    (46) funci -> . empty
    (124) empty -> .

    INT             shift and go to state 153
    FLOAT           shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156
    RPAREN          reduce using rule 124 (empty -> .)

    funci                          shift and go to state 234
    empty                          shift and go to state 157

state 211

    (43) funci -> STRING ID COMA . funci
    (38) funci -> . INT ID
    (39) funci -> . INT ID COMA funci
    (40) funci -> . FLOAT ID
    (41) funci -> . FLOAT ID COMA funci
    (42) funci -> . STRING ID
    (43) funci -> . STRING ID COMA funci
    (44) funci -> . BOOL ID
    (45) funci -> . BOOL ID COMA funci
    (46) funci -> . empty
    (124) empty -> .

    INT             shift and go to state 153
    FLOAT           shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156
    RPAREN          reduce using rule 124 (empty -> .)

    funci                          shift and go to state 235
    empty                          shift and go to state 157

state 212

    (45) funci -> BOOL ID COMA . funci
    (38) funci -> . INT ID
    (39) funci -> . INT ID COMA funci
    (40) funci -> . FLOAT ID
    (41) funci -> . FLOAT ID COMA funci
    (42) funci -> . STRING ID
    (43) funci -> . STRING ID COMA funci
    (44) funci -> . BOOL ID
    (45) funci -> . BOOL ID COMA funci
    (46) funci -> . empty
    (124) empty -> .

    INT             shift and go to state 153
    FLOAT           shift and go to state 154
    STRING          shift and go to state 155
    BOOL            shift and go to state 156
    RPAREN          reduce using rule 124 (empty -> .)

    funci                          shift and go to state 236
    empty                          shift and go to state 157

state 213

    (69) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    LPAREN          reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PLUS            reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    MINUS           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    CTE_I           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    CTE_F           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    CTE_S           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    TRUE            reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    FALSE           reduce using rule 69 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 214

    (70) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres SEMICOLON
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    exr                            shift and go to state 95
    expres                         shift and go to state 237
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 215

    (93) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)
    RKEY            reduce using rule 93 (fact -> LPAREN pushop expres RPAREN popop .)


state 216

    (71) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 238


state 217

    (88) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 88 (ex -> term resterm PLUS pushop ex .)
    RKEY            reduce using rule 88 (ex -> term resterm PLUS pushop ex .)


state 218

    (89) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 89 (ex -> term resterm MINUS pushop ex .)
    RKEY            reduce using rule 89 (ex -> term resterm MINUS pushop ex .)


state 219

    (91) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 91 (term -> fact resfact TIMES pushop term .)
    RKEY            reduce using rule 91 (term -> fact resfact TIMES pushop term .)


state 220

    (92) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)
    RKEY            reduce using rule 92 (term -> fact resfact DIVIDE pushop term .)


state 221

    (114) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RKEY            reduce using rule 114 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 222

    (115) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN generateGoSub

    RPAREN          shift and go to state 239


state 223

    (119) fcall1 -> expres . generateparam
    (120) fcall1 -> expres . generateparam COMA fcall1
    (121) generateparam -> .

    COMA            reduce using rule 121 (generateparam -> .)
    RPAREN          reduce using rule 121 (generateparam -> .)

    generateparam                  shift and go to state 240

state 224

    (73) escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .

    ID              reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    IF              reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    READ            reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    LPAREN          reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    PLUS            reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    MINUS           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    CTE_I           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    CTE_F           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    CTE_S           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    TRUE            reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)
    FALSE           reduce using rule 73 (escrit -> PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON .)


state 225

    (75) escriti -> expres escrit2 COMA . escriti
    (74) escriti -> . expres escrit1
    (75) escriti -> . expres escrit2 COMA escriti
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 176
    escriti                        shift and go to state 241
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 226

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 242
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 227

    (80) leer -> READ pushop LPAREN ID pushid readid RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 243


state 228

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 expres RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 244
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 229

    (27) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 230

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 expres RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY
    (51) return1 -> . RETURN expres resreturn SEMICOLON
    (52) return1 -> . empty
    (124) empty -> .

    RKEY            shift and go to state 246
    RETURN          shift and go to state 247
    LPAREN          reduce using rule 124 (empty -> .)
    PLUS            reduce using rule 124 (empty -> .)
    MINUS           reduce using rule 124 (empty -> .)
    ID              reduce using rule 124 (empty -> .)
    CTE_I           reduce using rule 124 (empty -> .)
    CTE_F           reduce using rule 124 (empty -> .)
    CTE_S           reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    return1                        shift and go to state 245
    empty                          shift and go to state 248

state 231

    (49) localvar -> var localvar .

    RKEY            reduce using rule 49 (localvar -> var localvar .)
    ID              reduce using rule 49 (localvar -> var localvar .)
    IF              reduce using rule 49 (localvar -> var localvar .)
    PRINT           reduce using rule 49 (localvar -> var localvar .)
    WHILE           reduce using rule 49 (localvar -> var localvar .)
    READ            reduce using rule 49 (localvar -> var localvar .)


state 232

    (50) localvar -> vector localvar .

    RKEY            reduce using rule 50 (localvar -> vector localvar .)
    ID              reduce using rule 50 (localvar -> vector localvar .)
    IF              reduce using rule 50 (localvar -> vector localvar .)
    PRINT           reduce using rule 50 (localvar -> vector localvar .)
    WHILE           reduce using rule 50 (localvar -> vector localvar .)
    READ            reduce using rule 50 (localvar -> vector localvar .)


state 233

    (39) funci -> INT ID COMA funci .

    RPAREN          reduce using rule 39 (funci -> INT ID COMA funci .)


state 234

    (41) funci -> FLOAT ID COMA funci .

    RPAREN          reduce using rule 41 (funci -> FLOAT ID COMA funci .)


state 235

    (43) funci -> STRING ID COMA funci .

    RPAREN          reduce using rule 43 (funci -> STRING ID COMA funci .)


state 236

    (45) funci -> BOOL ID COMA funci .

    RPAREN          reduce using rule 45 (funci -> BOOL ID COMA funci .)


state 237

    (70) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . SEMICOLON

    SEMICOLON       shift and go to state 249


state 238

    (71) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (135) finif -> .

    ELSE            shift and go to state 251
    ID              reduce using rule 135 (finif -> .)
    IF              reduce using rule 135 (finif -> .)
    PRINT           reduce using rule 135 (finif -> .)
    WHILE           reduce using rule 135 (finif -> .)
    READ            reduce using rule 135 (finif -> .)
    RKEY            reduce using rule 135 (finif -> .)
    RETURN          reduce using rule 135 (finif -> .)
    LPAREN          reduce using rule 135 (finif -> .)
    PLUS            reduce using rule 135 (finif -> .)
    MINUS           reduce using rule 135 (finif -> .)
    CTE_I           reduce using rule 135 (finif -> .)
    CTE_F           reduce using rule 135 (finif -> .)
    CTE_S           reduce using rule 135 (finif -> .)
    TRUE            reduce using rule 135 (finif -> .)
    FALSE           reduce using rule 135 (finif -> .)

    finif                          shift and go to state 250

state 239

    (115) fcall -> ID existfunc LPAREN startera fcall1 RPAREN . generateGoSub
    (122) generateGoSub -> .

    TIMES           reduce using rule 122 (generateGoSub -> .)
    DIVIDE          reduce using rule 122 (generateGoSub -> .)
    PLUS            reduce using rule 122 (generateGoSub -> .)
    MINUS           reduce using rule 122 (generateGoSub -> .)
    LOWERTHAN       reduce using rule 122 (generateGoSub -> .)
    MORETHAN        reduce using rule 122 (generateGoSub -> .)
    LOWEREQ         reduce using rule 122 (generateGoSub -> .)
    MOREEQ          reduce using rule 122 (generateGoSub -> .)
    SAME            reduce using rule 122 (generateGoSub -> .)
    DIFFERENT       reduce using rule 122 (generateGoSub -> .)
    OR              reduce using rule 122 (generateGoSub -> .)
    AND             reduce using rule 122 (generateGoSub -> .)
    RPAREN          reduce using rule 122 (generateGoSub -> .)
    RBRACE          reduce using rule 122 (generateGoSub -> .)
    SEMICOLON       reduce using rule 122 (generateGoSub -> .)
    COMA            reduce using rule 122 (generateGoSub -> .)
    RKEY            reduce using rule 122 (generateGoSub -> .)

    generateGoSub                  shift and go to state 252

state 240

    (119) fcall1 -> expres generateparam .
    (120) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 119 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 253


state 241

    (75) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 75 (escriti -> expres escrit2 COMA escriti .)


state 242

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 254


state 243

    (80) leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .

    ID              reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    IF              reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    PRINT           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    WHILE           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    READ            reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RKEY            reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    RETURN          reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    LPAREN          reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    PLUS            reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    MINUS           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    CTE_I           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    CTE_F           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    CTE_S           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    TRUE            reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)
    FALSE           reduce using rule 80 (leer -> READ pushop LPAREN ID pushid readid RPAREN SEMICOLON .)


state 244

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 expres RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY
    (51) return1 -> . RETURN expres resreturn SEMICOLON
    (52) return1 -> . empty
    (124) empty -> .

    RKEY            shift and go to state 256
    RETURN          shift and go to state 247
    LPAREN          reduce using rule 124 (empty -> .)
    PLUS            reduce using rule 124 (empty -> .)
    MINUS           reduce using rule 124 (empty -> .)
    ID              reduce using rule 124 (empty -> .)
    CTE_I           reduce using rule 124 (empty -> .)
    CTE_F           reduce using rule 124 (empty -> .)
    CTE_S           reduce using rule 124 (empty -> .)
    TRUE            reduce using rule 124 (empty -> .)
    FALSE           reduce using rule 124 (empty -> .)

    return1                        shift and go to state 255
    empty                          shift and go to state 248

state 245

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . expres RKEY
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 257
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 246

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 247

    (51) return1 -> RETURN . expres resreturn SEMICOLON
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 258
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 248

    (52) return1 -> empty .

    LPAREN          reduce using rule 52 (return1 -> empty .)
    PLUS            reduce using rule 52 (return1 -> empty .)
    MINUS           reduce using rule 52 (return1 -> empty .)
    ID              reduce using rule 52 (return1 -> empty .)
    CTE_I           reduce using rule 52 (return1 -> empty .)
    CTE_F           reduce using rule 52 (return1 -> empty .)
    CTE_S           reduce using rule 52 (return1 -> empty .)
    TRUE            reduce using rule 52 (return1 -> empty .)
    FALSE           reduce using rule 52 (return1 -> empty .)


state 249

    (70) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .

    ID              reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    IF              reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    PRINT           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    WHILE           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    READ            reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RKEY            reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    RETURN          reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    LPAREN          reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    PLUS            reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    MINUS           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    CTE_I           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    CTE_F           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    CTE_S           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    TRUE            reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)
    FALSE           reduce using rule 70 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON .)


state 250

    (71) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    LPAREN          reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PLUS            reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    MINUS           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    CTE_I           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    CTE_F           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    CTE_S           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    TRUE            reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    FALSE           reduce using rule 71 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 251

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 259


state 252

    (115) fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .

    TIMES           reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIVIDE          reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    PLUS            reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MINUS           reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWERTHAN       reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MORETHAN        reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    LOWEREQ         reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    MOREEQ          reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SAME            reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    DIFFERENT       reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    OR              reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    AND             reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RPAREN          reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RBRACE          reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    SEMICOLON       reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    COMA            reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)
    RKEY            reduce using rule 115 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN generateGoSub .)


state 253

    (120) fcall1 -> expres generateparam COMA . fcall1
    (119) fcall1 -> . expres generateparam
    (120) fcall1 -> . expres generateparam COMA fcall1
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 223
    fcall1                         shift and go to state 260
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 254

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (138) while3 -> .

    ID              reduce using rule 138 (while3 -> .)
    IF              reduce using rule 138 (while3 -> .)
    PRINT           reduce using rule 138 (while3 -> .)
    WHILE           reduce using rule 138 (while3 -> .)
    READ            reduce using rule 138 (while3 -> .)
    RKEY            reduce using rule 138 (while3 -> .)
    RETURN          reduce using rule 138 (while3 -> .)
    LPAREN          reduce using rule 138 (while3 -> .)
    PLUS            reduce using rule 138 (while3 -> .)
    MINUS           reduce using rule 138 (while3 -> .)
    CTE_I           reduce using rule 138 (while3 -> .)
    CTE_F           reduce using rule 138 (while3 -> .)
    CTE_S           reduce using rule 138 (while3 -> .)
    TRUE            reduce using rule 138 (while3 -> .)
    FALSE           reduce using rule 138 (while3 -> .)

    while3                         shift and go to state 261

state 255

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . expres RKEY
    (82) expres -> . exr
    (83) expres -> . exr log expres reslog
    (84) exr -> . ex
    (85) exr -> . ex rel exr resrel
    (87) ex -> . term resterm
    (88) ex -> . term resterm PLUS pushop ex
    (89) ex -> . term resterm MINUS pushop ex
    (90) term -> . fact resfact
    (91) term -> . fact resfact TIMES pushop term
    (92) term -> . fact resfact DIVIDE pushop term
    (93) fact -> . LPAREN pushop expres RPAREN popop
    (94) fact -> . var_cte
    (95) fact -> . PLUS var_cte
    (96) fact -> . MINUS var_cte
    (105) var_cte -> . ID pushid
    (106) var_cte -> . CTE_I pushcte
    (107) var_cte -> . CTE_F pushcte
    (108) var_cte -> . CTE_S pushcte
    (109) var_cte -> . TRUE pushcte
    (110) var_cte -> . FALSE pushcte
    (111) var_cte -> . fcall
    (112) var_cte -> . vcall
    (113) var_cte -> . asigvector
    (115) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN generateGoSub
    (116) fcall -> . ID existfunc LPAREN RPAREN
    (123) vcall -> . ID LBRACE expres RBRACE
    (114) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 93
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    ID              shift and go to state 102
    CTE_I           shift and go to state 103
    CTE_F           shift and go to state 104
    CTE_S           shift and go to state 105
    TRUE            shift and go to state 106
    FALSE           shift and go to state 107

    expres                         shift and go to state 262
    exr                            shift and go to state 95
    ex                             shift and go to state 96
    term                           shift and go to state 97
    fact                           shift and go to state 100
    var_cte                        shift and go to state 101
    fcall                          shift and go to state 108
    vcall                          shift and go to state 109
    asigvector                     shift and go to state 110

state 256

    (28) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 257

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres . RKEY

    RKEY            shift and go to state 263


state 258

    (51) return1 -> RETURN expres . resreturn SEMICOLON
    (53) resreturn -> .

    SEMICOLON       reduce using rule 53 (resreturn -> .)

    resreturn                      shift and go to state 264

state 259

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (134) reselse -> .

    ID              reduce using rule 134 (reselse -> .)
    IF              reduce using rule 134 (reselse -> .)
    PRINT           reduce using rule 134 (reselse -> .)
    WHILE           reduce using rule 134 (reselse -> .)
    READ            reduce using rule 134 (reselse -> .)

    reselse                        shift and go to state 265

state 260

    (120) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 120 (fcall1 -> expres generateparam COMA fcall1 .)


state 261

    (79) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    LPAREN          reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PLUS            reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    MINUS           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    CTE_I           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    CTE_F           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    CTE_S           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    TRUE            reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    FALSE           reduce using rule 79 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 262

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres . RKEY

    RKEY            shift and go to state 266


state 263

    (29) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 expres RKEY .)


state 264

    (51) return1 -> RETURN expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 267


state 265

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (62) bloq -> . estat
    (63) bloq -> . estat bloq
    (64) estat -> . asign
    (65) estat -> . cond
    (66) estat -> . escrit
    (67) estat -> . ciclo
    (68) estat -> . leer
    (69) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (70) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres SEMICOLON
    (71) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (72) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (73) escrit -> . PRINT pushop LPAREN imprimirl escriti RPAREN SEMICOLON
    (79) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (80) leer -> . READ pushop LPAREN ID pushid readid RPAREN SEMICOLON

    ID              shift and go to state 60
    IF              shift and go to state 61
    PRINT           shift and go to state 62
    WHILE           shift and go to state 63
    READ            shift and go to state 64

    bloq                           shift and go to state 268
    estat                          shift and go to state 52
    asign                          shift and go to state 55
    cond                           shift and go to state 56
    escrit                         shift and go to state 57
    ciclo                          shift and go to state 58
    leer                           shift and go to state 59

state 266

    (26) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 expres RKEY .)


state 267

    (51) return1 -> RETURN expres resreturn SEMICOLON .

    LPAREN          reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    PLUS            reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    MINUS           reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    ID              reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    CTE_I           reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    CTE_F           reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    CTE_S           reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    TRUE            reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)
    FALSE           reduce using rule 51 (return1 -> RETURN expres resreturn SEMICOLON .)


state 268

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 269


state 269

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (135) finif -> .

    ID              reduce using rule 135 (finif -> .)
    IF              reduce using rule 135 (finif -> .)
    PRINT           reduce using rule 135 (finif -> .)
    WHILE           reduce using rule 135 (finif -> .)
    READ            reduce using rule 135 (finif -> .)
    RKEY            reduce using rule 135 (finif -> .)
    RETURN          reduce using rule 135 (finif -> .)
    LPAREN          reduce using rule 135 (finif -> .)
    PLUS            reduce using rule 135 (finif -> .)
    MINUS           reduce using rule 135 (finif -> .)
    CTE_I           reduce using rule 135 (finif -> .)
    CTE_F           reduce using rule 135 (finif -> .)
    CTE_S           reduce using rule 135 (finif -> .)
    TRUE            reduce using rule 135 (finif -> .)
    FALSE           reduce using rule 135 (finif -> .)

    finif                          shift and go to state 270

state 270

    (72) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    LPAREN          reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PLUS            reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    MINUS           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    CTE_I           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    CTE_F           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    CTE_S           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    TRUE            reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    FALSE           reduce using rule 72 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 52 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 102 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 116 resolved as shift
