Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 2     program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
Rule 3     program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain
Rule 4     program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain
Rule 5     gotomain -> <empty>
Rule 6     program2 -> crear program2
Rule 7     program2 -> crear
Rule 8     program3 -> function program3
Rule 9     program3 -> function
Rule 10    llenarmain -> <empty>
Rule 11    crear -> var
Rule 12    crear -> vector
Rule 13    global -> <empty>
Rule 14    finglobal -> <empty>
Rule 15    main1 -> <empty>
Rule 16    finmain -> <empty>
Rule 17    var -> VAR tipo ID SEMICOLON
Rule 18    tipo -> INT
Rule 19    tipo -> FLOAT
Rule 20    tipo -> STRING
Rule 21    tipo -> BOOL
Rule 22    vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
Rule 23    initvector -> <empty>
Rule 24    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
Rule 25    function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
Rule 26    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
Rule 27    function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
Rule 28    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 29    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
Rule 30    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
Rule 31    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
Rule 32    function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
Rule 33    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
Rule 34    function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY
Rule 35    functype -> INT
Rule 36    functype -> FLOAT
Rule 37    functype -> STRING
Rule 38    functype -> BOOL
Rule 39    pushvoid -> VOID
Rule 40    addInTable -> <empty>
Rule 41    funci -> tipo ID sumparam
Rule 42    funci -> tipo ID sumparam COMA funci
Rule 43    localvar -> var
Rule 44    localvar -> vector
Rule 45    localvar -> var localvar
Rule 46    localvar -> vector localvar
Rule 47    sumparam -> <empty>
Rule 48    return1 -> RETURN pushop expres resreturn SEMICOLON
Rule 49    return1 -> empty
Rule 50    resreturn -> <empty>
Rule 51    mainc -> LKEY RKEY
Rule 52    mainc -> LKEY localvar bloq RKEY
Rule 53    mainc -> LKEY localvar RKEY
Rule 54    mainc -> LKEY bloq RKEY
Rule 55    bloq -> estat
Rule 56    bloq -> estat bloq
Rule 57    estat -> asign
Rule 58    estat -> cond
Rule 59    estat -> escrit
Rule 60    estat -> ciclo
Rule 61    estat -> leer
Rule 62    estat -> fcallvoid
Rule 63    asign -> ID pushid EQUAL pushop fcall SEMICOLON
Rule 64    asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
Rule 65    asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
Rule 66    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
Rule 67    cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
Rule 68    escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON
Rule 69    escriti -> expres escrit1
Rule 70    escriti -> expres escrit2 COMA escriti
Rule 71    escrit1 -> <empty>
Rule 72    escrit2 -> <empty>
Rule 73    ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
Rule 74    leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
Rule 75    readid -> <empty>
Rule 76    expres -> exr
Rule 77    expres -> exr log expres reslog
Rule 78    exr -> ex
Rule 79    exr -> ex rel exr resrel
Rule 80    reslog -> <empty>
Rule 81    ex -> term resterm
Rule 82    ex -> term resterm PLUS pushop ex
Rule 83    ex -> term resterm MINUS pushop ex
Rule 84    term -> fact resfact
Rule 85    term -> fact resfact TIMES pushop term
Rule 86    term -> fact resfact DIVIDE pushop term
Rule 87    fact -> LPAREN pushop expres RPAREN popop
Rule 88    fact -> var_cte
Rule 89    fact -> PLUS pushop var_cte
Rule 90    fact -> MINUS pushop var_cte
Rule 91    rel -> LOWERTHAN
Rule 92    rel -> MORETHAN
Rule 93    rel -> LOWEREQ
Rule 94    rel -> MOREEQ
Rule 95    rel -> SAME
Rule 96    rel -> DIFFERENT
Rule 97    log -> OR
Rule 98    log -> AND
Rule 99    var_cte -> ID pushid
Rule 100   var_cte -> CTE_I pushcte
Rule 101   var_cte -> CTE_F pushcte
Rule 102   var_cte -> CTE_S pushcte
Rule 103   var_cte -> TRUE pushcte
Rule 104   var_cte -> FALSE pushcte
Rule 105   var_cte -> asigvector
Rule 106   asigvector -> ID pushid LBRACE ex RBRACE
Rule 107   fcall -> ID existfunc LPAREN startera fcall1 RPAREN
Rule 108   fcall -> ID existfunc LPAREN startera RPAREN
Rule 109   fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
Rule 110   fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON
Rule 111   existfunc -> <empty>
Rule 112   startera -> <empty>
Rule 113   fcall1 -> expres generateparam
Rule 114   fcall1 -> expres generateparam COMA fcall1
Rule 115   generateparam -> <empty>
Rule 116   empty -> <empty>
Rule 117   pushcte -> <empty>
Rule 118   pushid -> <empty>
Rule 119   pushop -> <empty>
Rule 120   popop -> <empty>
Rule 121   resolverasignacion -> <empty>
Rule 122   resasignvec -> <empty>
Rule 123   resfact -> <empty>
Rule 124   resterm -> <empty>
Rule 125   resrel -> <empty>
Rule 126   resif -> <empty>
Rule 127   reselse -> <empty>
Rule 128   finif -> <empty>
Rule 129   while1 -> <empty>
Rule 130   while2 -> <empty>
Rule 131   while3 -> <empty>

Terminals, with rules where they appear

AND                  : 98
BOOL                 : 21 38
COLON                : 1 2 3 4
COMA                 : 42 70 114
CTE_F                : 101
CTE_I                : 22 100
CTE_S                : 102
DIFFERENT            : 96
DIVIDE               : 86
ELSE                 : 67
EQUAL                : 63 64 65
FALSE                : 104
FLOAT                : 19 36
FUNCTION             : 24 25 26 27 28 29 30 31 32 33 34
ID                   : 17 22 24 25 26 27 28 29 30 31 32 33 34 41 42 63 64 65 74 99 106 107 108 109 110
IF                   : 66 67
INT                  : 18 35
LBRACE               : 22 65 106
LKEY                 : 24 25 26 27 28 29 30 31 32 33 34 51 52 53 54 66 67 67 73
LOWEREQ              : 93
LOWERTHAN            : 91
LPAREN               : 24 25 26 27 28 29 30 31 32 33 34 66 67 68 73 74 87 107 108 109 110
MAIN                 : 1 2 3 4
MINUS                : 83 90
MOREEQ               : 94
MORETHAN             : 92
OR                   : 97
PLUS                 : 82 89
PRINT                : 68
PROGRAM              : 1 2 3 4
RBRACE               : 22 65 106
READ                 : 74
RETURN               : 48
RKEY                 : 24 25 26 27 28 29 30 31 32 33 34 51 52 53 54 66 67 67 73
RPAREN               : 24 25 26 27 28 29 30 31 32 33 34 66 67 68 73 74 87 107 108 109 110
SAME                 : 95
SEMICOLON            : 17 22 48 63 64 65 68 74 109 110
STRING               : 20 37
TIMES                : 85
TRUE                 : 103
VAR                  : 17
VECTOR               : 22
VOID                 : 39
WHILE                : 73
error                : 

Nonterminals, with rules where they appear

addInTable           : 24 25 26 27 28 29 30 31 32 33 34
asign                : 57
asigvector           : 105
bloq                 : 24 25 26 27 30 31 32 33 52 54 56 66 67 67 73
ciclo                : 60
cond                 : 58
crear                : 6 7
empty                : 49
escrit               : 59
escrit1              : 69
escrit2              : 70
escriti              : 68 70
estat                : 55 56
ex                   : 78 79 82 83 106
existfunc            : 107 108 109 110
expres               : 48 64 65 66 67 69 70 73 77 87 113 114
exr                  : 65 76 77 79
fact                 : 84 85 86
fcall                : 63
fcall1               : 107 109 114
fcallvoid            : 62
finglobal            : 1 2 3
finif                : 66 67
finmain              : 1 2 3 4
funci                : 24 25 26 27 42
function             : 8 9
functype             : 24 25 28 30 33 34
generateparam        : 113 114
global               : 1 2 3
gotomain             : 1 2 3 4
initvector           : 22
leer                 : 61
llenarmain           : 1 2 3 4
localvar             : 24 26 28 29 30 31 45 46 52 53
log                  : 77
main1                : 1 2 3 4
mainc                : 1 2 3 4
popop                : 87
program              : 0
program2             : 1 2 6
program3             : 1 3 8
pushcte              : 100 101 102 103 104
pushid               : 63 64 65 74 99 106
pushop               : 48 63 64 65 68 74 82 83 85 86 87 89 90
pushvoid             : 26 27 29 31 32
readid               : 74
rel                  : 79
resasignvec          : 65
reselse              : 67
resfact              : 84 85 86
resif                : 66 67
reslog               : 77
resolverasignacion   : 64
resrel               : 79
resreturn            : 48
resterm              : 81 82 83
return1              : 24 25 30 33
startera             : 107 108 109 110
sumparam             : 41 42
term                 : 81 82 83 85 86
tipo                 : 17 22 41 42
var                  : 11 43 45
var_cte              : 88 89 90
vector               : 12 44 46
while1               : 73
while2               : 73
while3               : 73

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> . PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> . PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain
    (4) program -> . PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM . COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM . COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain
    (4) program -> PROGRAM . COLON gotomain llenarmain MAIN main1 mainc finmain

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON . gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON . gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain
    (4) program -> PROGRAM COLON . gotomain llenarmain MAIN main1 mainc finmain
    (5) gotomain -> .

    VAR             reduce using rule 5 (gotomain -> .)
    VECTOR          reduce using rule 5 (gotomain -> .)
    FUNCTION        reduce using rule 5 (gotomain -> .)
    MAIN            reduce using rule 5 (gotomain -> .)

    gotomain                       shift and go to state 4

state 4

    (1) program -> PROGRAM COLON gotomain . global program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain . global program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain . global finglobal program3 llenarmain MAIN main1 mainc finmain
    (4) program -> PROGRAM COLON gotomain . llenarmain MAIN main1 mainc finmain
    (13) global -> .
    (10) llenarmain -> .

    VAR             reduce using rule 13 (global -> .)
    VECTOR          reduce using rule 13 (global -> .)
    FUNCTION        reduce using rule 13 (global -> .)
    MAIN            reduce using rule 10 (llenarmain -> .)

    global                         shift and go to state 5
    llenarmain                     shift and go to state 6

state 5

    (1) program -> PROGRAM COLON gotomain global . program2 finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global . program2 finglobal llenarmain MAIN main1 mainc finmain
    (3) program -> PROGRAM COLON gotomain global . finglobal program3 llenarmain MAIN main1 mainc finmain
    (6) program2 -> . crear program2
    (7) program2 -> . crear
    (14) finglobal -> .
    (11) crear -> . var
    (12) crear -> . vector
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 14 (finglobal -> .)
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13

    program2                       shift and go to state 7
    finglobal                      shift and go to state 8
    crear                          shift and go to state 9
    var                            shift and go to state 10
    vector                         shift and go to state 11

state 6

    (4) program -> PROGRAM COLON gotomain llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 14


state 7

    (1) program -> PROGRAM COLON gotomain global program2 . finglobal program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 . finglobal llenarmain MAIN main1 mainc finmain
    (14) finglobal -> .

    FUNCTION        reduce using rule 14 (finglobal -> .)
    MAIN            reduce using rule 14 (finglobal -> .)

    finglobal                      shift and go to state 15

state 8

    (3) program -> PROGRAM COLON gotomain global finglobal . program3 llenarmain MAIN main1 mainc finmain
    (8) program3 -> . function program3
    (9) program3 -> . function
    (24) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (26) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (28) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (33) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    FUNCTION        shift and go to state 18

    program3                       shift and go to state 16
    function                       shift and go to state 17

state 9

    (6) program2 -> crear . program2
    (7) program2 -> crear .
    (6) program2 -> . crear program2
    (7) program2 -> . crear
    (11) crear -> . var
    (12) crear -> . vector
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON

    FUNCTION        reduce using rule 7 (program2 -> crear .)
    MAIN            reduce using rule 7 (program2 -> crear .)
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13

    crear                          shift and go to state 9
    program2                       shift and go to state 19
    var                            shift and go to state 10
    vector                         shift and go to state 11

state 10

    (11) crear -> var .

    VAR             reduce using rule 11 (crear -> var .)
    VECTOR          reduce using rule 11 (crear -> var .)
    FUNCTION        reduce using rule 11 (crear -> var .)
    MAIN            reduce using rule 11 (crear -> var .)


state 11

    (12) crear -> vector .

    VAR             reduce using rule 12 (crear -> vector .)
    VECTOR          reduce using rule 12 (crear -> vector .)
    FUNCTION        reduce using rule 12 (crear -> vector .)
    MAIN            reduce using rule 12 (crear -> vector .)


state 12

    (17) var -> VAR . tipo ID SEMICOLON
    (18) tipo -> . INT
    (19) tipo -> . FLOAT
    (20) tipo -> . STRING
    (21) tipo -> . BOOL

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    tipo                           shift and go to state 20

state 13

    (22) vector -> VECTOR . initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (23) initvector -> .

    INT             reduce using rule 23 (initvector -> .)
    FLOAT           reduce using rule 23 (initvector -> .)
    STRING          reduce using rule 23 (initvector -> .)
    BOOL            reduce using rule 23 (initvector -> .)

    initvector                     shift and go to state 25

state 14

    (4) program -> PROGRAM COLON gotomain llenarmain MAIN . main1 mainc finmain
    (15) main1 -> .

    LKEY            reduce using rule 15 (main1 -> .)

    main1                          shift and go to state 26

state 15

    (1) program -> PROGRAM COLON gotomain global program2 finglobal . program3 llenarmain MAIN main1 mainc finmain
    (2) program -> PROGRAM COLON gotomain global program2 finglobal . llenarmain MAIN main1 mainc finmain
    (8) program3 -> . function program3
    (9) program3 -> . function
    (10) llenarmain -> .
    (24) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (26) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (28) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (33) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 10 (llenarmain -> .)
    FUNCTION        shift and go to state 18

    program3                       shift and go to state 27
    llenarmain                     shift and go to state 28
    function                       shift and go to state 17

state 16

    (3) program -> PROGRAM COLON gotomain global finglobal program3 . llenarmain MAIN main1 mainc finmain
    (10) llenarmain -> .

    MAIN            reduce using rule 10 (llenarmain -> .)

    llenarmain                     shift and go to state 29

state 17

    (8) program3 -> function . program3
    (9) program3 -> function .
    (8) program3 -> . function program3
    (9) program3 -> . function
    (24) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> . FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (26) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> . FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (28) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (29) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (31) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> . FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (33) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> . FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY

    MAIN            reduce using rule 9 (program3 -> function .)
    FUNCTION        shift and go to state 18

    function                       shift and go to state 17
    program3                       shift and go to state 30

state 18

    (24) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION . functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (26) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION . pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (28) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (29) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (31) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> FUNCTION . pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY
    (33) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> FUNCTION . functype ID addInTable LPAREN RPAREN LKEY RKEY
    (35) functype -> . INT
    (36) functype -> . FLOAT
    (37) functype -> . STRING
    (38) functype -> . BOOL
    (39) pushvoid -> . VOID

    INT             shift and go to state 33
    FLOAT           shift and go to state 34
    STRING          shift and go to state 35
    BOOL            shift and go to state 36
    VOID            shift and go to state 37

    functype                       shift and go to state 31
    pushvoid                       shift and go to state 32

state 19

    (6) program2 -> crear program2 .

    FUNCTION        reduce using rule 6 (program2 -> crear program2 .)
    MAIN            reduce using rule 6 (program2 -> crear program2 .)


state 20

    (17) var -> VAR tipo . ID SEMICOLON

    ID              shift and go to state 38


state 21

    (18) tipo -> INT .

    ID              reduce using rule 18 (tipo -> INT .)


state 22

    (19) tipo -> FLOAT .

    ID              reduce using rule 19 (tipo -> FLOAT .)


state 23

    (20) tipo -> STRING .

    ID              reduce using rule 20 (tipo -> STRING .)


state 24

    (21) tipo -> BOOL .

    ID              reduce using rule 21 (tipo -> BOOL .)


state 25

    (22) vector -> VECTOR initvector . tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (18) tipo -> . INT
    (19) tipo -> . FLOAT
    (20) tipo -> . STRING
    (21) tipo -> . BOOL

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    tipo                           shift and go to state 39

state 26

    (4) program -> PROGRAM COLON gotomain llenarmain MAIN main1 . mainc finmain
    (51) mainc -> . LKEY RKEY
    (52) mainc -> . LKEY localvar bloq RKEY
    (53) mainc -> . LKEY localvar RKEY
    (54) mainc -> . LKEY bloq RKEY

    LKEY            shift and go to state 41

    mainc                          shift and go to state 40

state 27

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 . llenarmain MAIN main1 mainc finmain
    (10) llenarmain -> .

    MAIN            reduce using rule 10 (llenarmain -> .)

    llenarmain                     shift and go to state 42

state 28

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 43


state 29

    (3) program -> PROGRAM COLON gotomain global finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 44


state 30

    (8) program3 -> function program3 .

    MAIN            reduce using rule 8 (program3 -> function program3 .)


state 31

    (24) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype . ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> FUNCTION functype . ID addInTable LPAREN RPAREN LKEY RKEY

    ID              shift and go to state 45


state 32

    (26) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid . ID addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> FUNCTION pushvoid . ID addInTable LPAREN RPAREN LKEY bloq RKEY

    ID              shift and go to state 46


state 33

    (35) functype -> INT .

    ID              reduce using rule 35 (functype -> INT .)


state 34

    (36) functype -> FLOAT .

    ID              reduce using rule 36 (functype -> FLOAT .)


state 35

    (37) functype -> STRING .

    ID              reduce using rule 37 (functype -> STRING .)


state 36

    (38) functype -> BOOL .

    ID              reduce using rule 38 (functype -> BOOL .)


state 37

    (39) pushvoid -> VOID .

    ID              reduce using rule 39 (pushvoid -> VOID .)


state 38

    (17) var -> VAR tipo ID . SEMICOLON

    SEMICOLON       shift and go to state 47


state 39

    (22) vector -> VECTOR initvector tipo . ID LBRACE CTE_I RBRACE SEMICOLON

    ID              shift and go to state 48


state 40

    (4) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc . finmain
    (16) finmain -> .

    $end            reduce using rule 16 (finmain -> .)

    finmain                        shift and go to state 49

state 41

    (51) mainc -> LKEY . RKEY
    (52) mainc -> LKEY . localvar bloq RKEY
    (53) mainc -> LKEY . localvar RKEY
    (54) mainc -> LKEY . bloq RKEY
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 50
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 51
    bloq                           shift and go to state 52
    var                            shift and go to state 53
    vector                         shift and go to state 54
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 42

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain . MAIN main1 mainc finmain

    MAIN            shift and go to state 67


state 43

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN . main1 mainc finmain
    (15) main1 -> .

    LKEY            reduce using rule 15 (main1 -> .)

    main1                          shift and go to state 68

state 44

    (3) program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN . main1 mainc finmain
    (15) main1 -> .

    LKEY            reduce using rule 15 (main1 -> .)

    main1                          shift and go to state 69

state 45

    (24) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID . addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> FUNCTION functype ID . addInTable LPAREN RPAREN LKEY RKEY
    (40) addInTable -> .

    LPAREN          reduce using rule 40 (addInTable -> .)

    addInTable                     shift and go to state 70

state 46

    (26) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID . addInTable LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> FUNCTION pushvoid ID . addInTable LPAREN RPAREN LKEY bloq RKEY
    (40) addInTable -> .

    LPAREN          reduce using rule 40 (addInTable -> .)

    addInTable                     shift and go to state 71

state 47

    (17) var -> VAR tipo ID SEMICOLON .

    VAR             reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    VECTOR          reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    FUNCTION        reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    MAIN            reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    RKEY            reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    ID              reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    IF              reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    PRINT           reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    WHILE           reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)
    READ            reduce using rule 17 (var -> VAR tipo ID SEMICOLON .)


state 48

    (22) vector -> VECTOR initvector tipo ID . LBRACE CTE_I RBRACE SEMICOLON

    LBRACE          shift and go to state 72


state 49

    (4) program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 4 (program -> PROGRAM COLON gotomain llenarmain MAIN main1 mainc finmain .)


state 50

    (51) mainc -> LKEY RKEY .

    $end            reduce using rule 51 (mainc -> LKEY RKEY .)


state 51

    (52) mainc -> LKEY localvar . bloq RKEY
    (53) mainc -> LKEY localvar . RKEY
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 74
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 73
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 52

    (54) mainc -> LKEY bloq . RKEY

    RKEY            shift and go to state 75


state 53

    (43) localvar -> var .
    (45) localvar -> var . localvar
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 43 (localvar -> var .)
    ID              reduce using rule 43 (localvar -> var .)
    IF              reduce using rule 43 (localvar -> var .)
    PRINT           reduce using rule 43 (localvar -> var .)
    WHILE           reduce using rule 43 (localvar -> var .)
    READ            reduce using rule 43 (localvar -> var .)
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13

    var                            shift and go to state 53
    localvar                       shift and go to state 76
    vector                         shift and go to state 54

state 54

    (44) localvar -> vector .
    (46) localvar -> vector . localvar
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON

    RKEY            reduce using rule 44 (localvar -> vector .)
    ID              reduce using rule 44 (localvar -> vector .)
    IF              reduce using rule 44 (localvar -> vector .)
    PRINT           reduce using rule 44 (localvar -> vector .)
    WHILE           reduce using rule 44 (localvar -> vector .)
    READ            reduce using rule 44 (localvar -> vector .)
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13

    vector                         shift and go to state 54
    localvar                       shift and go to state 77
    var                            shift and go to state 53

state 55

    (55) bloq -> estat .
    (56) bloq -> estat . bloq
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            reduce using rule 55 (bloq -> estat .)
    RETURN          reduce using rule 55 (bloq -> estat .)
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    estat                          shift and go to state 55
    bloq                           shift and go to state 78
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 56

    (63) asign -> ID . pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> ID . pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> ID . pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (109) fcallvoid -> ID . existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> ID . existfunc LPAREN startera RPAREN SEMICOLON
    (118) pushid -> .
    (111) existfunc -> .

    EQUAL           reduce using rule 118 (pushid -> .)
    LBRACE          reduce using rule 118 (pushid -> .)
    LPAREN          reduce using rule 111 (existfunc -> .)

    pushid                         shift and go to state 79
    existfunc                      shift and go to state 80

state 57

    (57) estat -> asign .

    ID              reduce using rule 57 (estat -> asign .)
    IF              reduce using rule 57 (estat -> asign .)
    PRINT           reduce using rule 57 (estat -> asign .)
    WHILE           reduce using rule 57 (estat -> asign .)
    READ            reduce using rule 57 (estat -> asign .)
    RKEY            reduce using rule 57 (estat -> asign .)
    RETURN          reduce using rule 57 (estat -> asign .)


state 58

    (58) estat -> cond .

    ID              reduce using rule 58 (estat -> cond .)
    IF              reduce using rule 58 (estat -> cond .)
    PRINT           reduce using rule 58 (estat -> cond .)
    WHILE           reduce using rule 58 (estat -> cond .)
    READ            reduce using rule 58 (estat -> cond .)
    RKEY            reduce using rule 58 (estat -> cond .)
    RETURN          reduce using rule 58 (estat -> cond .)


state 59

    (59) estat -> escrit .

    ID              reduce using rule 59 (estat -> escrit .)
    IF              reduce using rule 59 (estat -> escrit .)
    PRINT           reduce using rule 59 (estat -> escrit .)
    WHILE           reduce using rule 59 (estat -> escrit .)
    READ            reduce using rule 59 (estat -> escrit .)
    RKEY            reduce using rule 59 (estat -> escrit .)
    RETURN          reduce using rule 59 (estat -> escrit .)


state 60

    (60) estat -> ciclo .

    ID              reduce using rule 60 (estat -> ciclo .)
    IF              reduce using rule 60 (estat -> ciclo .)
    PRINT           reduce using rule 60 (estat -> ciclo .)
    WHILE           reduce using rule 60 (estat -> ciclo .)
    READ            reduce using rule 60 (estat -> ciclo .)
    RKEY            reduce using rule 60 (estat -> ciclo .)
    RETURN          reduce using rule 60 (estat -> ciclo .)


state 61

    (61) estat -> leer .

    ID              reduce using rule 61 (estat -> leer .)
    IF              reduce using rule 61 (estat -> leer .)
    PRINT           reduce using rule 61 (estat -> leer .)
    WHILE           reduce using rule 61 (estat -> leer .)
    READ            reduce using rule 61 (estat -> leer .)
    RKEY            reduce using rule 61 (estat -> leer .)
    RETURN          reduce using rule 61 (estat -> leer .)


state 62

    (62) estat -> fcallvoid .

    ID              reduce using rule 62 (estat -> fcallvoid .)
    IF              reduce using rule 62 (estat -> fcallvoid .)
    PRINT           reduce using rule 62 (estat -> fcallvoid .)
    WHILE           reduce using rule 62 (estat -> fcallvoid .)
    READ            reduce using rule 62 (estat -> fcallvoid .)
    RKEY            reduce using rule 62 (estat -> fcallvoid .)
    RETURN          reduce using rule 62 (estat -> fcallvoid .)


state 63

    (66) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> IF . LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LPAREN          shift and go to state 81


state 64

    (68) escrit -> PRINT . pushop LPAREN escriti RPAREN SEMICOLON
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 82

state 65

    (73) ciclo -> WHILE . while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (129) while1 -> .

    LPAREN          reduce using rule 129 (while1 -> .)

    while1                         shift and go to state 83

state 66

    (74) leer -> READ . pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 84

state 67

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN . main1 mainc finmain
    (15) main1 -> .

    LKEY            reduce using rule 15 (main1 -> .)

    main1                          shift and go to state 85

state 68

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 . mainc finmain
    (51) mainc -> . LKEY RKEY
    (52) mainc -> . LKEY localvar bloq RKEY
    (53) mainc -> . LKEY localvar RKEY
    (54) mainc -> . LKEY bloq RKEY

    LKEY            shift and go to state 41

    mainc                          shift and go to state 86

state 69

    (3) program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 . mainc finmain
    (51) mainc -> . LKEY RKEY
    (52) mainc -> . LKEY localvar bloq RKEY
    (53) mainc -> . LKEY localvar RKEY
    (54) mainc -> . LKEY bloq RKEY

    LKEY            shift and go to state 41

    mainc                          shift and go to state 87

state 70

    (24) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID addInTable . LPAREN funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable . LPAREN RPAREN LKEY RKEY

    LPAREN          shift and go to state 88


state 71

    (26) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID addInTable . LPAREN funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY localvar bloq RKEY
    (32) function -> FUNCTION pushvoid ID addInTable . LPAREN RPAREN LKEY bloq RKEY

    LPAREN          shift and go to state 89


state 72

    (22) vector -> VECTOR initvector tipo ID LBRACE . CTE_I RBRACE SEMICOLON

    CTE_I           shift and go to state 90


state 73

    (52) mainc -> LKEY localvar bloq . RKEY

    RKEY            shift and go to state 91


state 74

    (53) mainc -> LKEY localvar RKEY .

    $end            reduce using rule 53 (mainc -> LKEY localvar RKEY .)


state 75

    (54) mainc -> LKEY bloq RKEY .

    $end            reduce using rule 54 (mainc -> LKEY bloq RKEY .)


state 76

    (45) localvar -> var localvar .

    RKEY            reduce using rule 45 (localvar -> var localvar .)
    ID              reduce using rule 45 (localvar -> var localvar .)
    IF              reduce using rule 45 (localvar -> var localvar .)
    PRINT           reduce using rule 45 (localvar -> var localvar .)
    WHILE           reduce using rule 45 (localvar -> var localvar .)
    READ            reduce using rule 45 (localvar -> var localvar .)


state 77

    (46) localvar -> vector localvar .

    RKEY            reduce using rule 46 (localvar -> vector localvar .)
    ID              reduce using rule 46 (localvar -> vector localvar .)
    IF              reduce using rule 46 (localvar -> vector localvar .)
    PRINT           reduce using rule 46 (localvar -> vector localvar .)
    WHILE           reduce using rule 46 (localvar -> vector localvar .)
    READ            reduce using rule 46 (localvar -> vector localvar .)


state 78

    (56) bloq -> estat bloq .

    RKEY            reduce using rule 56 (bloq -> estat bloq .)
    RETURN          reduce using rule 56 (bloq -> estat bloq .)


state 79

    (63) asign -> ID pushid . EQUAL pushop fcall SEMICOLON
    (64) asign -> ID pushid . EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> ID pushid . LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON

    EQUAL           shift and go to state 92
    LBRACE          shift and go to state 93


state 80

    (109) fcallvoid -> ID existfunc . LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> ID existfunc . LPAREN startera RPAREN SEMICOLON

    LPAREN          shift and go to state 94


state 81

    (66) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> IF LPAREN . expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 96
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 82

    (68) escrit -> PRINT pushop . LPAREN escriti RPAREN SEMICOLON

    LPAREN          shift and go to state 111


state 83

    (73) ciclo -> WHILE while1 . LPAREN expres RPAREN while2 LKEY bloq RKEY while3

    LPAREN          shift and go to state 112


state 84

    (74) leer -> READ pushop . LPAREN ID pushid RPAREN readid SEMICOLON

    LPAREN          shift and go to state 113


state 85

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 . mainc finmain
    (51) mainc -> . LKEY RKEY
    (52) mainc -> . LKEY localvar bloq RKEY
    (53) mainc -> . LKEY localvar RKEY
    (54) mainc -> . LKEY bloq RKEY

    LKEY            shift and go to state 41

    mainc                          shift and go to state 114

state 86

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc . finmain
    (16) finmain -> .

    $end            reduce using rule 16 (finmain -> .)

    finmain                        shift and go to state 115

state 87

    (3) program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc . finmain
    (16) finmain -> .

    $end            reduce using rule 16 (finmain -> .)

    finmain                        shift and go to state 116

state 88

    (24) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID addInTable LPAREN . funci RPAREN LKEY bloq return1 RKEY
    (28) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN . RPAREN LKEY RKEY
    (41) funci -> . tipo ID sumparam
    (42) funci -> . tipo ID sumparam COMA funci
    (18) tipo -> . INT
    (19) tipo -> . FLOAT
    (20) tipo -> . STRING
    (21) tipo -> . BOOL

    RPAREN          shift and go to state 118
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    funci                          shift and go to state 117
    tipo                           shift and go to state 119

state 89

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID addInTable LPAREN . funci RPAREN LKEY bloq RKEY
    (29) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY localvar bloq RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN . RPAREN LKEY bloq RKEY
    (41) funci -> . tipo ID sumparam
    (42) funci -> . tipo ID sumparam COMA funci
    (18) tipo -> . INT
    (19) tipo -> . FLOAT
    (20) tipo -> . STRING
    (21) tipo -> . BOOL

    RPAREN          shift and go to state 121
    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    funci                          shift and go to state 120
    tipo                           shift and go to state 119

state 90

    (22) vector -> VECTOR initvector tipo ID LBRACE CTE_I . RBRACE SEMICOLON

    RBRACE          shift and go to state 122


state 91

    (52) mainc -> LKEY localvar bloq RKEY .

    $end            reduce using rule 52 (mainc -> LKEY localvar bloq RKEY .)


state 92

    (63) asign -> ID pushid EQUAL . pushop fcall SEMICOLON
    (64) asign -> ID pushid EQUAL . pushop expres resolverasignacion SEMICOLON
    (119) pushop -> .

    ID              reduce using rule 119 (pushop -> .)
    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 123

state 93

    (65) asign -> ID pushid LBRACE . exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    exr                            shift and go to state 124
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 94

    (109) fcallvoid -> ID existfunc LPAREN . startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> ID existfunc LPAREN . startera RPAREN SEMICOLON
    (112) startera -> .

    RPAREN          reduce using rule 112 (startera -> .)
    LPAREN          reduce using rule 112 (startera -> .)
    PLUS            reduce using rule 112 (startera -> .)
    MINUS           reduce using rule 112 (startera -> .)
    ID              reduce using rule 112 (startera -> .)
    CTE_I           reduce using rule 112 (startera -> .)
    CTE_F           reduce using rule 112 (startera -> .)
    CTE_S           reduce using rule 112 (startera -> .)
    TRUE            reduce using rule 112 (startera -> .)
    FALSE           reduce using rule 112 (startera -> .)

    startera                       shift and go to state 125

state 95

    (87) fact -> LPAREN . pushop expres RPAREN popop
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 126

state 96

    (66) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY finif
    (67) cond -> IF LPAREN expres . RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    RPAREN          shift and go to state 127


state 97

    (76) expres -> exr .
    (77) expres -> exr . log expres reslog
    (97) log -> . OR
    (98) log -> . AND

    RPAREN          reduce using rule 76 (expres -> exr .)
    COMA            reduce using rule 76 (expres -> exr .)
    SEMICOLON       reduce using rule 76 (expres -> exr .)
    OR              shift and go to state 129
    AND             shift and go to state 130

    log                            shift and go to state 128

state 98

    (78) exr -> ex .
    (79) exr -> ex . rel exr resrel
    (91) rel -> . LOWERTHAN
    (92) rel -> . MORETHAN
    (93) rel -> . LOWEREQ
    (94) rel -> . MOREEQ
    (95) rel -> . SAME
    (96) rel -> . DIFFERENT

    OR              reduce using rule 78 (exr -> ex .)
    AND             reduce using rule 78 (exr -> ex .)
    RPAREN          reduce using rule 78 (exr -> ex .)
    RBRACE          reduce using rule 78 (exr -> ex .)
    COMA            reduce using rule 78 (exr -> ex .)
    SEMICOLON       reduce using rule 78 (exr -> ex .)
    LOWERTHAN       shift and go to state 132
    MORETHAN        shift and go to state 133
    LOWEREQ         shift and go to state 134
    MOREEQ          shift and go to state 135
    SAME            shift and go to state 136
    DIFFERENT       shift and go to state 137

    rel                            shift and go to state 131

state 99

    (81) ex -> term . resterm
    (82) ex -> term . resterm PLUS pushop ex
    (83) ex -> term . resterm MINUS pushop ex
    (124) resterm -> .

    PLUS            reduce using rule 124 (resterm -> .)
    MINUS           reduce using rule 124 (resterm -> .)
    LOWERTHAN       reduce using rule 124 (resterm -> .)
    MORETHAN        reduce using rule 124 (resterm -> .)
    LOWEREQ         reduce using rule 124 (resterm -> .)
    MOREEQ          reduce using rule 124 (resterm -> .)
    SAME            reduce using rule 124 (resterm -> .)
    DIFFERENT       reduce using rule 124 (resterm -> .)
    OR              reduce using rule 124 (resterm -> .)
    AND             reduce using rule 124 (resterm -> .)
    RPAREN          reduce using rule 124 (resterm -> .)
    RBRACE          reduce using rule 124 (resterm -> .)
    COMA            reduce using rule 124 (resterm -> .)
    SEMICOLON       reduce using rule 124 (resterm -> .)

    resterm                        shift and go to state 138

state 100

    (89) fact -> PLUS . pushop var_cte
    (119) pushop -> .

    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 139

state 101

    (90) fact -> MINUS . pushop var_cte
    (119) pushop -> .

    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 140

state 102

    (84) term -> fact . resfact
    (85) term -> fact . resfact TIMES pushop term
    (86) term -> fact . resfact DIVIDE pushop term
    (123) resfact -> .

    TIMES           reduce using rule 123 (resfact -> .)
    DIVIDE          reduce using rule 123 (resfact -> .)
    PLUS            reduce using rule 123 (resfact -> .)
    MINUS           reduce using rule 123 (resfact -> .)
    LOWERTHAN       reduce using rule 123 (resfact -> .)
    MORETHAN        reduce using rule 123 (resfact -> .)
    LOWEREQ         reduce using rule 123 (resfact -> .)
    MOREEQ          reduce using rule 123 (resfact -> .)
    SAME            reduce using rule 123 (resfact -> .)
    DIFFERENT       reduce using rule 123 (resfact -> .)
    OR              reduce using rule 123 (resfact -> .)
    AND             reduce using rule 123 (resfact -> .)
    RPAREN          reduce using rule 123 (resfact -> .)
    RBRACE          reduce using rule 123 (resfact -> .)
    COMA            reduce using rule 123 (resfact -> .)
    SEMICOLON       reduce using rule 123 (resfact -> .)

    resfact                        shift and go to state 141

state 103

    (88) fact -> var_cte .

    TIMES           reduce using rule 88 (fact -> var_cte .)
    DIVIDE          reduce using rule 88 (fact -> var_cte .)
    PLUS            reduce using rule 88 (fact -> var_cte .)
    MINUS           reduce using rule 88 (fact -> var_cte .)
    LOWERTHAN       reduce using rule 88 (fact -> var_cte .)
    MORETHAN        reduce using rule 88 (fact -> var_cte .)
    LOWEREQ         reduce using rule 88 (fact -> var_cte .)
    MOREEQ          reduce using rule 88 (fact -> var_cte .)
    SAME            reduce using rule 88 (fact -> var_cte .)
    DIFFERENT       reduce using rule 88 (fact -> var_cte .)
    OR              reduce using rule 88 (fact -> var_cte .)
    AND             reduce using rule 88 (fact -> var_cte .)
    RPAREN          reduce using rule 88 (fact -> var_cte .)
    RBRACE          reduce using rule 88 (fact -> var_cte .)
    COMA            reduce using rule 88 (fact -> var_cte .)
    SEMICOLON       reduce using rule 88 (fact -> var_cte .)


state 104

    (99) var_cte -> ID . pushid
    (106) asigvector -> ID . pushid LBRACE ex RBRACE
    (118) pushid -> .

    LBRACE          reduce using rule 118 (pushid -> .)
    TIMES           reduce using rule 118 (pushid -> .)
    DIVIDE          reduce using rule 118 (pushid -> .)
    PLUS            reduce using rule 118 (pushid -> .)
    MINUS           reduce using rule 118 (pushid -> .)
    LOWERTHAN       reduce using rule 118 (pushid -> .)
    MORETHAN        reduce using rule 118 (pushid -> .)
    LOWEREQ         reduce using rule 118 (pushid -> .)
    MOREEQ          reduce using rule 118 (pushid -> .)
    SAME            reduce using rule 118 (pushid -> .)
    DIFFERENT       reduce using rule 118 (pushid -> .)
    OR              reduce using rule 118 (pushid -> .)
    AND             reduce using rule 118 (pushid -> .)
    RPAREN          reduce using rule 118 (pushid -> .)
    RBRACE          reduce using rule 118 (pushid -> .)
    COMA            reduce using rule 118 (pushid -> .)
    SEMICOLON       reduce using rule 118 (pushid -> .)

    pushid                         shift and go to state 142

state 105

    (100) var_cte -> CTE_I . pushcte
    (117) pushcte -> .

    TIMES           reduce using rule 117 (pushcte -> .)
    DIVIDE          reduce using rule 117 (pushcte -> .)
    PLUS            reduce using rule 117 (pushcte -> .)
    MINUS           reduce using rule 117 (pushcte -> .)
    LOWERTHAN       reduce using rule 117 (pushcte -> .)
    MORETHAN        reduce using rule 117 (pushcte -> .)
    LOWEREQ         reduce using rule 117 (pushcte -> .)
    MOREEQ          reduce using rule 117 (pushcte -> .)
    SAME            reduce using rule 117 (pushcte -> .)
    DIFFERENT       reduce using rule 117 (pushcte -> .)
    OR              reduce using rule 117 (pushcte -> .)
    AND             reduce using rule 117 (pushcte -> .)
    RPAREN          reduce using rule 117 (pushcte -> .)
    RBRACE          reduce using rule 117 (pushcte -> .)
    COMA            reduce using rule 117 (pushcte -> .)
    SEMICOLON       reduce using rule 117 (pushcte -> .)

    pushcte                        shift and go to state 143

state 106

    (101) var_cte -> CTE_F . pushcte
    (117) pushcte -> .

    TIMES           reduce using rule 117 (pushcte -> .)
    DIVIDE          reduce using rule 117 (pushcte -> .)
    PLUS            reduce using rule 117 (pushcte -> .)
    MINUS           reduce using rule 117 (pushcte -> .)
    LOWERTHAN       reduce using rule 117 (pushcte -> .)
    MORETHAN        reduce using rule 117 (pushcte -> .)
    LOWEREQ         reduce using rule 117 (pushcte -> .)
    MOREEQ          reduce using rule 117 (pushcte -> .)
    SAME            reduce using rule 117 (pushcte -> .)
    DIFFERENT       reduce using rule 117 (pushcte -> .)
    OR              reduce using rule 117 (pushcte -> .)
    AND             reduce using rule 117 (pushcte -> .)
    RPAREN          reduce using rule 117 (pushcte -> .)
    RBRACE          reduce using rule 117 (pushcte -> .)
    COMA            reduce using rule 117 (pushcte -> .)
    SEMICOLON       reduce using rule 117 (pushcte -> .)

    pushcte                        shift and go to state 144

state 107

    (102) var_cte -> CTE_S . pushcte
    (117) pushcte -> .

    TIMES           reduce using rule 117 (pushcte -> .)
    DIVIDE          reduce using rule 117 (pushcte -> .)
    PLUS            reduce using rule 117 (pushcte -> .)
    MINUS           reduce using rule 117 (pushcte -> .)
    LOWERTHAN       reduce using rule 117 (pushcte -> .)
    MORETHAN        reduce using rule 117 (pushcte -> .)
    LOWEREQ         reduce using rule 117 (pushcte -> .)
    MOREEQ          reduce using rule 117 (pushcte -> .)
    SAME            reduce using rule 117 (pushcte -> .)
    DIFFERENT       reduce using rule 117 (pushcte -> .)
    OR              reduce using rule 117 (pushcte -> .)
    AND             reduce using rule 117 (pushcte -> .)
    RPAREN          reduce using rule 117 (pushcte -> .)
    RBRACE          reduce using rule 117 (pushcte -> .)
    COMA            reduce using rule 117 (pushcte -> .)
    SEMICOLON       reduce using rule 117 (pushcte -> .)

    pushcte                        shift and go to state 145

state 108

    (103) var_cte -> TRUE . pushcte
    (117) pushcte -> .

    TIMES           reduce using rule 117 (pushcte -> .)
    DIVIDE          reduce using rule 117 (pushcte -> .)
    PLUS            reduce using rule 117 (pushcte -> .)
    MINUS           reduce using rule 117 (pushcte -> .)
    LOWERTHAN       reduce using rule 117 (pushcte -> .)
    MORETHAN        reduce using rule 117 (pushcte -> .)
    LOWEREQ         reduce using rule 117 (pushcte -> .)
    MOREEQ          reduce using rule 117 (pushcte -> .)
    SAME            reduce using rule 117 (pushcte -> .)
    DIFFERENT       reduce using rule 117 (pushcte -> .)
    OR              reduce using rule 117 (pushcte -> .)
    AND             reduce using rule 117 (pushcte -> .)
    RPAREN          reduce using rule 117 (pushcte -> .)
    RBRACE          reduce using rule 117 (pushcte -> .)
    COMA            reduce using rule 117 (pushcte -> .)
    SEMICOLON       reduce using rule 117 (pushcte -> .)

    pushcte                        shift and go to state 146

state 109

    (104) var_cte -> FALSE . pushcte
    (117) pushcte -> .

    TIMES           reduce using rule 117 (pushcte -> .)
    DIVIDE          reduce using rule 117 (pushcte -> .)
    PLUS            reduce using rule 117 (pushcte -> .)
    MINUS           reduce using rule 117 (pushcte -> .)
    LOWERTHAN       reduce using rule 117 (pushcte -> .)
    MORETHAN        reduce using rule 117 (pushcte -> .)
    LOWEREQ         reduce using rule 117 (pushcte -> .)
    MOREEQ          reduce using rule 117 (pushcte -> .)
    SAME            reduce using rule 117 (pushcte -> .)
    DIFFERENT       reduce using rule 117 (pushcte -> .)
    OR              reduce using rule 117 (pushcte -> .)
    AND             reduce using rule 117 (pushcte -> .)
    RPAREN          reduce using rule 117 (pushcte -> .)
    RBRACE          reduce using rule 117 (pushcte -> .)
    COMA            reduce using rule 117 (pushcte -> .)
    SEMICOLON       reduce using rule 117 (pushcte -> .)

    pushcte                        shift and go to state 147

state 110

    (105) var_cte -> asigvector .

    TIMES           reduce using rule 105 (var_cte -> asigvector .)
    DIVIDE          reduce using rule 105 (var_cte -> asigvector .)
    PLUS            reduce using rule 105 (var_cte -> asigvector .)
    MINUS           reduce using rule 105 (var_cte -> asigvector .)
    LOWERTHAN       reduce using rule 105 (var_cte -> asigvector .)
    MORETHAN        reduce using rule 105 (var_cte -> asigvector .)
    LOWEREQ         reduce using rule 105 (var_cte -> asigvector .)
    MOREEQ          reduce using rule 105 (var_cte -> asigvector .)
    SAME            reduce using rule 105 (var_cte -> asigvector .)
    DIFFERENT       reduce using rule 105 (var_cte -> asigvector .)
    OR              reduce using rule 105 (var_cte -> asigvector .)
    AND             reduce using rule 105 (var_cte -> asigvector .)
    RPAREN          reduce using rule 105 (var_cte -> asigvector .)
    RBRACE          reduce using rule 105 (var_cte -> asigvector .)
    COMA            reduce using rule 105 (var_cte -> asigvector .)
    SEMICOLON       reduce using rule 105 (var_cte -> asigvector .)


state 111

    (68) escrit -> PRINT pushop LPAREN . escriti RPAREN SEMICOLON
    (69) escriti -> . expres escrit1
    (70) escriti -> . expres escrit2 COMA escriti
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    escriti                        shift and go to state 148
    expres                         shift and go to state 149
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 112

    (73) ciclo -> WHILE while1 LPAREN . expres RPAREN while2 LKEY bloq RKEY while3
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 150
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 113

    (74) leer -> READ pushop LPAREN . ID pushid RPAREN readid SEMICOLON

    ID              shift and go to state 151


state 114

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc . finmain
    (16) finmain -> .

    $end            reduce using rule 16 (finmain -> .)

    finmain                        shift and go to state 152

state 115

    (2) program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 2 (program -> PROGRAM COLON gotomain global program2 finglobal llenarmain MAIN main1 mainc finmain .)


state 116

    (3) program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 3 (program -> PROGRAM COLON gotomain global finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 117

    (24) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID addInTable LPAREN funci . RPAREN LKEY bloq return1 RKEY

    RPAREN          shift and go to state 153


state 118

    (28) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY localvar bloq return1 RKEY
    (33) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN . LKEY RKEY

    LKEY            shift and go to state 154


state 119

    (41) funci -> tipo . ID sumparam
    (42) funci -> tipo . ID sumparam COMA funci

    ID              shift and go to state 155


state 120

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci . RPAREN LKEY bloq RKEY

    RPAREN          shift and go to state 156


state 121

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY localvar bloq RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 157


state 122

    (22) vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 158


state 123

    (63) asign -> ID pushid EQUAL pushop . fcall SEMICOLON
    (64) asign -> ID pushid EQUAL pushop . expres resolverasignacion SEMICOLON
    (107) fcall -> . ID existfunc LPAREN startera fcall1 RPAREN
    (108) fcall -> . ID existfunc LPAREN startera RPAREN
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 159
    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    fcall                          shift and go to state 160
    expres                         shift and go to state 161
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 124

    (65) asign -> ID pushid LBRACE exr . RBRACE EQUAL pushop expres resasignvec SEMICOLON

    RBRACE          shift and go to state 162


state 125

    (109) fcallvoid -> ID existfunc LPAREN startera . fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> ID existfunc LPAREN startera . RPAREN SEMICOLON
    (113) fcall1 -> . expres generateparam
    (114) fcall1 -> . expres generateparam COMA fcall1
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 164
    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    fcall1                         shift and go to state 163
    expres                         shift and go to state 165
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 126

    (87) fact -> LPAREN pushop . expres RPAREN popop
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 166
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 127

    (66) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY finif
    (67) cond -> IF LPAREN expres RPAREN . LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 167


state 128

    (77) expres -> exr log . expres reslog
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    exr                            shift and go to state 97
    expres                         shift and go to state 168
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 129

    (97) log -> OR .

    LPAREN          reduce using rule 97 (log -> OR .)
    PLUS            reduce using rule 97 (log -> OR .)
    MINUS           reduce using rule 97 (log -> OR .)
    ID              reduce using rule 97 (log -> OR .)
    CTE_I           reduce using rule 97 (log -> OR .)
    CTE_F           reduce using rule 97 (log -> OR .)
    CTE_S           reduce using rule 97 (log -> OR .)
    TRUE            reduce using rule 97 (log -> OR .)
    FALSE           reduce using rule 97 (log -> OR .)


state 130

    (98) log -> AND .

    LPAREN          reduce using rule 98 (log -> AND .)
    PLUS            reduce using rule 98 (log -> AND .)
    MINUS           reduce using rule 98 (log -> AND .)
    ID              reduce using rule 98 (log -> AND .)
    CTE_I           reduce using rule 98 (log -> AND .)
    CTE_F           reduce using rule 98 (log -> AND .)
    CTE_S           reduce using rule 98 (log -> AND .)
    TRUE            reduce using rule 98 (log -> AND .)
    FALSE           reduce using rule 98 (log -> AND .)


state 131

    (79) exr -> ex rel . exr resrel
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    ex                             shift and go to state 98
    exr                            shift and go to state 169
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 132

    (91) rel -> LOWERTHAN .

    LPAREN          reduce using rule 91 (rel -> LOWERTHAN .)
    PLUS            reduce using rule 91 (rel -> LOWERTHAN .)
    MINUS           reduce using rule 91 (rel -> LOWERTHAN .)
    ID              reduce using rule 91 (rel -> LOWERTHAN .)
    CTE_I           reduce using rule 91 (rel -> LOWERTHAN .)
    CTE_F           reduce using rule 91 (rel -> LOWERTHAN .)
    CTE_S           reduce using rule 91 (rel -> LOWERTHAN .)
    TRUE            reduce using rule 91 (rel -> LOWERTHAN .)
    FALSE           reduce using rule 91 (rel -> LOWERTHAN .)


state 133

    (92) rel -> MORETHAN .

    LPAREN          reduce using rule 92 (rel -> MORETHAN .)
    PLUS            reduce using rule 92 (rel -> MORETHAN .)
    MINUS           reduce using rule 92 (rel -> MORETHAN .)
    ID              reduce using rule 92 (rel -> MORETHAN .)
    CTE_I           reduce using rule 92 (rel -> MORETHAN .)
    CTE_F           reduce using rule 92 (rel -> MORETHAN .)
    CTE_S           reduce using rule 92 (rel -> MORETHAN .)
    TRUE            reduce using rule 92 (rel -> MORETHAN .)
    FALSE           reduce using rule 92 (rel -> MORETHAN .)


state 134

    (93) rel -> LOWEREQ .

    LPAREN          reduce using rule 93 (rel -> LOWEREQ .)
    PLUS            reduce using rule 93 (rel -> LOWEREQ .)
    MINUS           reduce using rule 93 (rel -> LOWEREQ .)
    ID              reduce using rule 93 (rel -> LOWEREQ .)
    CTE_I           reduce using rule 93 (rel -> LOWEREQ .)
    CTE_F           reduce using rule 93 (rel -> LOWEREQ .)
    CTE_S           reduce using rule 93 (rel -> LOWEREQ .)
    TRUE            reduce using rule 93 (rel -> LOWEREQ .)
    FALSE           reduce using rule 93 (rel -> LOWEREQ .)


state 135

    (94) rel -> MOREEQ .

    LPAREN          reduce using rule 94 (rel -> MOREEQ .)
    PLUS            reduce using rule 94 (rel -> MOREEQ .)
    MINUS           reduce using rule 94 (rel -> MOREEQ .)
    ID              reduce using rule 94 (rel -> MOREEQ .)
    CTE_I           reduce using rule 94 (rel -> MOREEQ .)
    CTE_F           reduce using rule 94 (rel -> MOREEQ .)
    CTE_S           reduce using rule 94 (rel -> MOREEQ .)
    TRUE            reduce using rule 94 (rel -> MOREEQ .)
    FALSE           reduce using rule 94 (rel -> MOREEQ .)


state 136

    (95) rel -> SAME .

    LPAREN          reduce using rule 95 (rel -> SAME .)
    PLUS            reduce using rule 95 (rel -> SAME .)
    MINUS           reduce using rule 95 (rel -> SAME .)
    ID              reduce using rule 95 (rel -> SAME .)
    CTE_I           reduce using rule 95 (rel -> SAME .)
    CTE_F           reduce using rule 95 (rel -> SAME .)
    CTE_S           reduce using rule 95 (rel -> SAME .)
    TRUE            reduce using rule 95 (rel -> SAME .)
    FALSE           reduce using rule 95 (rel -> SAME .)


state 137

    (96) rel -> DIFFERENT .

    LPAREN          reduce using rule 96 (rel -> DIFFERENT .)
    PLUS            reduce using rule 96 (rel -> DIFFERENT .)
    MINUS           reduce using rule 96 (rel -> DIFFERENT .)
    ID              reduce using rule 96 (rel -> DIFFERENT .)
    CTE_I           reduce using rule 96 (rel -> DIFFERENT .)
    CTE_F           reduce using rule 96 (rel -> DIFFERENT .)
    CTE_S           reduce using rule 96 (rel -> DIFFERENT .)
    TRUE            reduce using rule 96 (rel -> DIFFERENT .)
    FALSE           reduce using rule 96 (rel -> DIFFERENT .)


state 138

    (81) ex -> term resterm .
    (82) ex -> term resterm . PLUS pushop ex
    (83) ex -> term resterm . MINUS pushop ex

    LOWERTHAN       reduce using rule 81 (ex -> term resterm .)
    MORETHAN        reduce using rule 81 (ex -> term resterm .)
    LOWEREQ         reduce using rule 81 (ex -> term resterm .)
    MOREEQ          reduce using rule 81 (ex -> term resterm .)
    SAME            reduce using rule 81 (ex -> term resterm .)
    DIFFERENT       reduce using rule 81 (ex -> term resterm .)
    OR              reduce using rule 81 (ex -> term resterm .)
    AND             reduce using rule 81 (ex -> term resterm .)
    RPAREN          reduce using rule 81 (ex -> term resterm .)
    RBRACE          reduce using rule 81 (ex -> term resterm .)
    COMA            reduce using rule 81 (ex -> term resterm .)
    SEMICOLON       reduce using rule 81 (ex -> term resterm .)
    PLUS            shift and go to state 170
    MINUS           shift and go to state 171


state 139

    (89) fact -> PLUS pushop . var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    var_cte                        shift and go to state 172
    asigvector                     shift and go to state 110

state 140

    (90) fact -> MINUS pushop . var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    var_cte                        shift and go to state 173
    asigvector                     shift and go to state 110

state 141

    (84) term -> fact resfact .
    (85) term -> fact resfact . TIMES pushop term
    (86) term -> fact resfact . DIVIDE pushop term

    PLUS            reduce using rule 84 (term -> fact resfact .)
    MINUS           reduce using rule 84 (term -> fact resfact .)
    LOWERTHAN       reduce using rule 84 (term -> fact resfact .)
    MORETHAN        reduce using rule 84 (term -> fact resfact .)
    LOWEREQ         reduce using rule 84 (term -> fact resfact .)
    MOREEQ          reduce using rule 84 (term -> fact resfact .)
    SAME            reduce using rule 84 (term -> fact resfact .)
    DIFFERENT       reduce using rule 84 (term -> fact resfact .)
    OR              reduce using rule 84 (term -> fact resfact .)
    AND             reduce using rule 84 (term -> fact resfact .)
    RPAREN          reduce using rule 84 (term -> fact resfact .)
    RBRACE          reduce using rule 84 (term -> fact resfact .)
    COMA            reduce using rule 84 (term -> fact resfact .)
    SEMICOLON       reduce using rule 84 (term -> fact resfact .)
    TIMES           shift and go to state 174
    DIVIDE          shift and go to state 175


state 142

    (99) var_cte -> ID pushid .
    (106) asigvector -> ID pushid . LBRACE ex RBRACE

    TIMES           reduce using rule 99 (var_cte -> ID pushid .)
    DIVIDE          reduce using rule 99 (var_cte -> ID pushid .)
    PLUS            reduce using rule 99 (var_cte -> ID pushid .)
    MINUS           reduce using rule 99 (var_cte -> ID pushid .)
    LOWERTHAN       reduce using rule 99 (var_cte -> ID pushid .)
    MORETHAN        reduce using rule 99 (var_cte -> ID pushid .)
    LOWEREQ         reduce using rule 99 (var_cte -> ID pushid .)
    MOREEQ          reduce using rule 99 (var_cte -> ID pushid .)
    SAME            reduce using rule 99 (var_cte -> ID pushid .)
    DIFFERENT       reduce using rule 99 (var_cte -> ID pushid .)
    OR              reduce using rule 99 (var_cte -> ID pushid .)
    AND             reduce using rule 99 (var_cte -> ID pushid .)
    RPAREN          reduce using rule 99 (var_cte -> ID pushid .)
    RBRACE          reduce using rule 99 (var_cte -> ID pushid .)
    COMA            reduce using rule 99 (var_cte -> ID pushid .)
    SEMICOLON       reduce using rule 99 (var_cte -> ID pushid .)
    LBRACE          shift and go to state 176


state 143

    (100) var_cte -> CTE_I pushcte .

    TIMES           reduce using rule 100 (var_cte -> CTE_I pushcte .)
    DIVIDE          reduce using rule 100 (var_cte -> CTE_I pushcte .)
    PLUS            reduce using rule 100 (var_cte -> CTE_I pushcte .)
    MINUS           reduce using rule 100 (var_cte -> CTE_I pushcte .)
    LOWERTHAN       reduce using rule 100 (var_cte -> CTE_I pushcte .)
    MORETHAN        reduce using rule 100 (var_cte -> CTE_I pushcte .)
    LOWEREQ         reduce using rule 100 (var_cte -> CTE_I pushcte .)
    MOREEQ          reduce using rule 100 (var_cte -> CTE_I pushcte .)
    SAME            reduce using rule 100 (var_cte -> CTE_I pushcte .)
    DIFFERENT       reduce using rule 100 (var_cte -> CTE_I pushcte .)
    OR              reduce using rule 100 (var_cte -> CTE_I pushcte .)
    AND             reduce using rule 100 (var_cte -> CTE_I pushcte .)
    RPAREN          reduce using rule 100 (var_cte -> CTE_I pushcte .)
    RBRACE          reduce using rule 100 (var_cte -> CTE_I pushcte .)
    COMA            reduce using rule 100 (var_cte -> CTE_I pushcte .)
    SEMICOLON       reduce using rule 100 (var_cte -> CTE_I pushcte .)


state 144

    (101) var_cte -> CTE_F pushcte .

    TIMES           reduce using rule 101 (var_cte -> CTE_F pushcte .)
    DIVIDE          reduce using rule 101 (var_cte -> CTE_F pushcte .)
    PLUS            reduce using rule 101 (var_cte -> CTE_F pushcte .)
    MINUS           reduce using rule 101 (var_cte -> CTE_F pushcte .)
    LOWERTHAN       reduce using rule 101 (var_cte -> CTE_F pushcte .)
    MORETHAN        reduce using rule 101 (var_cte -> CTE_F pushcte .)
    LOWEREQ         reduce using rule 101 (var_cte -> CTE_F pushcte .)
    MOREEQ          reduce using rule 101 (var_cte -> CTE_F pushcte .)
    SAME            reduce using rule 101 (var_cte -> CTE_F pushcte .)
    DIFFERENT       reduce using rule 101 (var_cte -> CTE_F pushcte .)
    OR              reduce using rule 101 (var_cte -> CTE_F pushcte .)
    AND             reduce using rule 101 (var_cte -> CTE_F pushcte .)
    RPAREN          reduce using rule 101 (var_cte -> CTE_F pushcte .)
    RBRACE          reduce using rule 101 (var_cte -> CTE_F pushcte .)
    COMA            reduce using rule 101 (var_cte -> CTE_F pushcte .)
    SEMICOLON       reduce using rule 101 (var_cte -> CTE_F pushcte .)


state 145

    (102) var_cte -> CTE_S pushcte .

    TIMES           reduce using rule 102 (var_cte -> CTE_S pushcte .)
    DIVIDE          reduce using rule 102 (var_cte -> CTE_S pushcte .)
    PLUS            reduce using rule 102 (var_cte -> CTE_S pushcte .)
    MINUS           reduce using rule 102 (var_cte -> CTE_S pushcte .)
    LOWERTHAN       reduce using rule 102 (var_cte -> CTE_S pushcte .)
    MORETHAN        reduce using rule 102 (var_cte -> CTE_S pushcte .)
    LOWEREQ         reduce using rule 102 (var_cte -> CTE_S pushcte .)
    MOREEQ          reduce using rule 102 (var_cte -> CTE_S pushcte .)
    SAME            reduce using rule 102 (var_cte -> CTE_S pushcte .)
    DIFFERENT       reduce using rule 102 (var_cte -> CTE_S pushcte .)
    OR              reduce using rule 102 (var_cte -> CTE_S pushcte .)
    AND             reduce using rule 102 (var_cte -> CTE_S pushcte .)
    RPAREN          reduce using rule 102 (var_cte -> CTE_S pushcte .)
    RBRACE          reduce using rule 102 (var_cte -> CTE_S pushcte .)
    COMA            reduce using rule 102 (var_cte -> CTE_S pushcte .)
    SEMICOLON       reduce using rule 102 (var_cte -> CTE_S pushcte .)


state 146

    (103) var_cte -> TRUE pushcte .

    TIMES           reduce using rule 103 (var_cte -> TRUE pushcte .)
    DIVIDE          reduce using rule 103 (var_cte -> TRUE pushcte .)
    PLUS            reduce using rule 103 (var_cte -> TRUE pushcte .)
    MINUS           reduce using rule 103 (var_cte -> TRUE pushcte .)
    LOWERTHAN       reduce using rule 103 (var_cte -> TRUE pushcte .)
    MORETHAN        reduce using rule 103 (var_cte -> TRUE pushcte .)
    LOWEREQ         reduce using rule 103 (var_cte -> TRUE pushcte .)
    MOREEQ          reduce using rule 103 (var_cte -> TRUE pushcte .)
    SAME            reduce using rule 103 (var_cte -> TRUE pushcte .)
    DIFFERENT       reduce using rule 103 (var_cte -> TRUE pushcte .)
    OR              reduce using rule 103 (var_cte -> TRUE pushcte .)
    AND             reduce using rule 103 (var_cte -> TRUE pushcte .)
    RPAREN          reduce using rule 103 (var_cte -> TRUE pushcte .)
    RBRACE          reduce using rule 103 (var_cte -> TRUE pushcte .)
    COMA            reduce using rule 103 (var_cte -> TRUE pushcte .)
    SEMICOLON       reduce using rule 103 (var_cte -> TRUE pushcte .)


state 147

    (104) var_cte -> FALSE pushcte .

    TIMES           reduce using rule 104 (var_cte -> FALSE pushcte .)
    DIVIDE          reduce using rule 104 (var_cte -> FALSE pushcte .)
    PLUS            reduce using rule 104 (var_cte -> FALSE pushcte .)
    MINUS           reduce using rule 104 (var_cte -> FALSE pushcte .)
    LOWERTHAN       reduce using rule 104 (var_cte -> FALSE pushcte .)
    MORETHAN        reduce using rule 104 (var_cte -> FALSE pushcte .)
    LOWEREQ         reduce using rule 104 (var_cte -> FALSE pushcte .)
    MOREEQ          reduce using rule 104 (var_cte -> FALSE pushcte .)
    SAME            reduce using rule 104 (var_cte -> FALSE pushcte .)
    DIFFERENT       reduce using rule 104 (var_cte -> FALSE pushcte .)
    OR              reduce using rule 104 (var_cte -> FALSE pushcte .)
    AND             reduce using rule 104 (var_cte -> FALSE pushcte .)
    RPAREN          reduce using rule 104 (var_cte -> FALSE pushcte .)
    RBRACE          reduce using rule 104 (var_cte -> FALSE pushcte .)
    COMA            reduce using rule 104 (var_cte -> FALSE pushcte .)
    SEMICOLON       reduce using rule 104 (var_cte -> FALSE pushcte .)


state 148

    (68) escrit -> PRINT pushop LPAREN escriti . RPAREN SEMICOLON

    RPAREN          shift and go to state 177


state 149

    (69) escriti -> expres . escrit1
    (70) escriti -> expres . escrit2 COMA escriti
    (71) escrit1 -> .
    (72) escrit2 -> .

    RPAREN          reduce using rule 71 (escrit1 -> .)
    COMA            reduce using rule 72 (escrit2 -> .)

    escrit1                        shift and go to state 178
    escrit2                        shift and go to state 179

state 150

    (73) ciclo -> WHILE while1 LPAREN expres . RPAREN while2 LKEY bloq RKEY while3

    RPAREN          shift and go to state 180


state 151

    (74) leer -> READ pushop LPAREN ID . pushid RPAREN readid SEMICOLON
    (118) pushid -> .

    RPAREN          reduce using rule 118 (pushid -> .)

    pushid                         shift and go to state 181

state 152

    (1) program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .

    $end            reduce using rule 1 (program -> PROGRAM COLON gotomain global program2 finglobal program3 llenarmain MAIN main1 mainc finmain .)


state 153

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN . LKEY bloq return1 RKEY

    LKEY            shift and go to state 182


state 154

    (28) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . localvar bloq return1 RKEY
    (33) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . bloq return1 RKEY
    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY . RKEY
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 184
    VAR             shift and go to state 12
    VECTOR          shift and go to state 13
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 183
    bloq                           shift and go to state 185
    var                            shift and go to state 53
    vector                         shift and go to state 54
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 155

    (41) funci -> tipo ID . sumparam
    (42) funci -> tipo ID . sumparam COMA funci
    (47) sumparam -> .

    COMA            reduce using rule 47 (sumparam -> .)
    RPAREN          reduce using rule 47 (sumparam -> .)

    sumparam                       shift and go to state 186

state 156

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN . LKEY bloq RKEY

    LKEY            shift and go to state 187


state 157

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . localvar bloq RKEY
    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY . bloq RKEY
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 12
    VECTOR          shift and go to state 13
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 188
    bloq                           shift and go to state 189
    var                            shift and go to state 53
    vector                         shift and go to state 54
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 158

    (22) vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .

    VAR             reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    VECTOR          reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    FUNCTION        reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    MAIN            reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    RKEY            reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    ID              reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    IF              reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    PRINT           reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    WHILE           reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)
    READ            reduce using rule 22 (vector -> VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON .)


state 159

    (107) fcall -> ID . existfunc LPAREN startera fcall1 RPAREN
    (108) fcall -> ID . existfunc LPAREN startera RPAREN
    (99) var_cte -> ID . pushid
    (106) asigvector -> ID . pushid LBRACE ex RBRACE
    (111) existfunc -> .
    (118) pushid -> .

    LPAREN          reduce using rule 111 (existfunc -> .)
    LBRACE          reduce using rule 118 (pushid -> .)
    TIMES           reduce using rule 118 (pushid -> .)
    DIVIDE          reduce using rule 118 (pushid -> .)
    PLUS            reduce using rule 118 (pushid -> .)
    MINUS           reduce using rule 118 (pushid -> .)
    LOWERTHAN       reduce using rule 118 (pushid -> .)
    MORETHAN        reduce using rule 118 (pushid -> .)
    LOWEREQ         reduce using rule 118 (pushid -> .)
    MOREEQ          reduce using rule 118 (pushid -> .)
    SAME            reduce using rule 118 (pushid -> .)
    DIFFERENT       reduce using rule 118 (pushid -> .)
    OR              reduce using rule 118 (pushid -> .)
    AND             reduce using rule 118 (pushid -> .)
    SEMICOLON       reduce using rule 118 (pushid -> .)

    existfunc                      shift and go to state 190
    pushid                         shift and go to state 142

state 160

    (63) asign -> ID pushid EQUAL pushop fcall . SEMICOLON

    SEMICOLON       shift and go to state 191


state 161

    (64) asign -> ID pushid EQUAL pushop expres . resolverasignacion SEMICOLON
    (121) resolverasignacion -> .

    SEMICOLON       reduce using rule 121 (resolverasignacion -> .)

    resolverasignacion             shift and go to state 192

state 162

    (65) asign -> ID pushid LBRACE exr RBRACE . EQUAL pushop expres resasignvec SEMICOLON

    EQUAL           shift and go to state 193


state 163

    (109) fcallvoid -> ID existfunc LPAREN startera fcall1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 194


state 164

    (110) fcallvoid -> ID existfunc LPAREN startera RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 195


state 165

    (113) fcall1 -> expres . generateparam
    (114) fcall1 -> expres . generateparam COMA fcall1
    (115) generateparam -> .

    COMA            reduce using rule 115 (generateparam -> .)
    RPAREN          reduce using rule 115 (generateparam -> .)

    generateparam                  shift and go to state 196

state 166

    (87) fact -> LPAREN pushop expres . RPAREN popop

    RPAREN          shift and go to state 197


state 167

    (66) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY finif
    (67) cond -> IF LPAREN expres RPAREN LKEY . resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (126) resif -> .

    ID              reduce using rule 126 (resif -> .)
    IF              reduce using rule 126 (resif -> .)
    PRINT           reduce using rule 126 (resif -> .)
    WHILE           reduce using rule 126 (resif -> .)
    READ            reduce using rule 126 (resif -> .)

    resif                          shift and go to state 198

state 168

    (77) expres -> exr log expres . reslog
    (80) reslog -> .

    RPAREN          reduce using rule 80 (reslog -> .)
    COMA            reduce using rule 80 (reslog -> .)
    SEMICOLON       reduce using rule 80 (reslog -> .)

    reslog                         shift and go to state 199

state 169

    (79) exr -> ex rel exr . resrel
    (125) resrel -> .

    OR              reduce using rule 125 (resrel -> .)
    AND             reduce using rule 125 (resrel -> .)
    RPAREN          reduce using rule 125 (resrel -> .)
    RBRACE          reduce using rule 125 (resrel -> .)
    COMA            reduce using rule 125 (resrel -> .)
    SEMICOLON       reduce using rule 125 (resrel -> .)

    resrel                         shift and go to state 200

state 170

    (82) ex -> term resterm PLUS . pushop ex
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 201

state 171

    (83) ex -> term resterm MINUS . pushop ex
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 202

state 172

    (89) fact -> PLUS pushop var_cte .

    TIMES           reduce using rule 89 (fact -> PLUS pushop var_cte .)
    DIVIDE          reduce using rule 89 (fact -> PLUS pushop var_cte .)
    PLUS            reduce using rule 89 (fact -> PLUS pushop var_cte .)
    MINUS           reduce using rule 89 (fact -> PLUS pushop var_cte .)
    LOWERTHAN       reduce using rule 89 (fact -> PLUS pushop var_cte .)
    MORETHAN        reduce using rule 89 (fact -> PLUS pushop var_cte .)
    LOWEREQ         reduce using rule 89 (fact -> PLUS pushop var_cte .)
    MOREEQ          reduce using rule 89 (fact -> PLUS pushop var_cte .)
    SAME            reduce using rule 89 (fact -> PLUS pushop var_cte .)
    DIFFERENT       reduce using rule 89 (fact -> PLUS pushop var_cte .)
    OR              reduce using rule 89 (fact -> PLUS pushop var_cte .)
    AND             reduce using rule 89 (fact -> PLUS pushop var_cte .)
    RPAREN          reduce using rule 89 (fact -> PLUS pushop var_cte .)
    RBRACE          reduce using rule 89 (fact -> PLUS pushop var_cte .)
    COMA            reduce using rule 89 (fact -> PLUS pushop var_cte .)
    SEMICOLON       reduce using rule 89 (fact -> PLUS pushop var_cte .)


state 173

    (90) fact -> MINUS pushop var_cte .

    TIMES           reduce using rule 90 (fact -> MINUS pushop var_cte .)
    DIVIDE          reduce using rule 90 (fact -> MINUS pushop var_cte .)
    PLUS            reduce using rule 90 (fact -> MINUS pushop var_cte .)
    MINUS           reduce using rule 90 (fact -> MINUS pushop var_cte .)
    LOWERTHAN       reduce using rule 90 (fact -> MINUS pushop var_cte .)
    MORETHAN        reduce using rule 90 (fact -> MINUS pushop var_cte .)
    LOWEREQ         reduce using rule 90 (fact -> MINUS pushop var_cte .)
    MOREEQ          reduce using rule 90 (fact -> MINUS pushop var_cte .)
    SAME            reduce using rule 90 (fact -> MINUS pushop var_cte .)
    DIFFERENT       reduce using rule 90 (fact -> MINUS pushop var_cte .)
    OR              reduce using rule 90 (fact -> MINUS pushop var_cte .)
    AND             reduce using rule 90 (fact -> MINUS pushop var_cte .)
    RPAREN          reduce using rule 90 (fact -> MINUS pushop var_cte .)
    RBRACE          reduce using rule 90 (fact -> MINUS pushop var_cte .)
    COMA            reduce using rule 90 (fact -> MINUS pushop var_cte .)
    SEMICOLON       reduce using rule 90 (fact -> MINUS pushop var_cte .)


state 174

    (85) term -> fact resfact TIMES . pushop term
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 203

state 175

    (86) term -> fact resfact DIVIDE . pushop term
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 204

state 176

    (106) asigvector -> ID pushid LBRACE . ex RBRACE
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    ex                             shift and go to state 205
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 177

    (68) escrit -> PRINT pushop LPAREN escriti RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 206


state 178

    (69) escriti -> expres escrit1 .

    RPAREN          reduce using rule 69 (escriti -> expres escrit1 .)


state 179

    (70) escriti -> expres escrit2 . COMA escriti

    COMA            shift and go to state 207


state 180

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN . while2 LKEY bloq RKEY while3
    (130) while2 -> .

    LKEY            reduce using rule 130 (while2 -> .)

    while2                         shift and go to state 208

state 181

    (74) leer -> READ pushop LPAREN ID pushid . RPAREN readid SEMICOLON

    RPAREN          shift and go to state 209


state 182

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . localvar bloq return1 RKEY
    (25) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY . bloq return1 RKEY
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 12
    VECTOR          shift and go to state 13
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 210
    bloq                           shift and go to state 211
    var                            shift and go to state 53
    vector                         shift and go to state 54
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 183

    (28) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar . bloq return1 RKEY
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 212
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 213
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 184

    (34) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .

    FUNCTION        reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)
    MAIN            reduce using rule 34 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY RKEY .)


state 185

    (33) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq . return1 RKEY
    (48) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (49) return1 -> . empty
    (116) empty -> .

    RETURN          shift and go to state 215
    RKEY            reduce using rule 116 (empty -> .)

    return1                        shift and go to state 214
    empty                          shift and go to state 216

state 186

    (41) funci -> tipo ID sumparam .
    (42) funci -> tipo ID sumparam . COMA funci

    RPAREN          reduce using rule 41 (funci -> tipo ID sumparam .)
    COMA            shift and go to state 217


state 187

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . localvar bloq RKEY
    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY . bloq RKEY
    (43) localvar -> . var
    (44) localvar -> . vector
    (45) localvar -> . var localvar
    (46) localvar -> . vector localvar
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (17) var -> . VAR tipo ID SEMICOLON
    (22) vector -> . VECTOR initvector tipo ID LBRACE CTE_I RBRACE SEMICOLON
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    VAR             shift and go to state 12
    VECTOR          shift and go to state 13
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    localvar                       shift and go to state 218
    bloq                           shift and go to state 219
    var                            shift and go to state 53
    vector                         shift and go to state 54
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 188

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . RKEY
    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar . bloq RKEY
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    RKEY            shift and go to state 220
    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 221
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 189

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 222


state 190

    (107) fcall -> ID existfunc . LPAREN startera fcall1 RPAREN
    (108) fcall -> ID existfunc . LPAREN startera RPAREN

    LPAREN          shift and go to state 223


state 191

    (63) asign -> ID pushid EQUAL pushop fcall SEMICOLON .

    ID              reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    IF              reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    PRINT           reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    WHILE           reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    READ            reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    RKEY            reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)
    RETURN          reduce using rule 63 (asign -> ID pushid EQUAL pushop fcall SEMICOLON .)


state 192

    (64) asign -> ID pushid EQUAL pushop expres resolverasignacion . SEMICOLON

    SEMICOLON       shift and go to state 224


state 193

    (65) asign -> ID pushid LBRACE exr RBRACE EQUAL . pushop expres resasignvec SEMICOLON
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 225

state 194

    (109) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 226


state 195

    (110) fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .

    ID              reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    IF              reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    PRINT           reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    WHILE           reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    READ            reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RKEY            reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)
    RETURN          reduce using rule 110 (fcallvoid -> ID existfunc LPAREN startera RPAREN SEMICOLON .)


state 196

    (113) fcall1 -> expres generateparam .
    (114) fcall1 -> expres generateparam . COMA fcall1

    RPAREN          reduce using rule 113 (fcall1 -> expres generateparam .)
    COMA            shift and go to state 227


state 197

    (87) fact -> LPAREN pushop expres RPAREN . popop
    (120) popop -> .

    TIMES           reduce using rule 120 (popop -> .)
    DIVIDE          reduce using rule 120 (popop -> .)
    PLUS            reduce using rule 120 (popop -> .)
    MINUS           reduce using rule 120 (popop -> .)
    LOWERTHAN       reduce using rule 120 (popop -> .)
    MORETHAN        reduce using rule 120 (popop -> .)
    LOWEREQ         reduce using rule 120 (popop -> .)
    MOREEQ          reduce using rule 120 (popop -> .)
    SAME            reduce using rule 120 (popop -> .)
    DIFFERENT       reduce using rule 120 (popop -> .)
    OR              reduce using rule 120 (popop -> .)
    AND             reduce using rule 120 (popop -> .)
    RPAREN          reduce using rule 120 (popop -> .)
    RBRACE          reduce using rule 120 (popop -> .)
    COMA            reduce using rule 120 (popop -> .)
    SEMICOLON       reduce using rule 120 (popop -> .)

    popop                          shift and go to state 228

state 198

    (66) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY finif
    (67) cond -> IF LPAREN expres RPAREN LKEY resif . bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 229
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 199

    (77) expres -> exr log expres reslog .

    RPAREN          reduce using rule 77 (expres -> exr log expres reslog .)
    COMA            reduce using rule 77 (expres -> exr log expres reslog .)
    SEMICOLON       reduce using rule 77 (expres -> exr log expres reslog .)


state 200

    (79) exr -> ex rel exr resrel .

    OR              reduce using rule 79 (exr -> ex rel exr resrel .)
    AND             reduce using rule 79 (exr -> ex rel exr resrel .)
    RPAREN          reduce using rule 79 (exr -> ex rel exr resrel .)
    RBRACE          reduce using rule 79 (exr -> ex rel exr resrel .)
    COMA            reduce using rule 79 (exr -> ex rel exr resrel .)
    SEMICOLON       reduce using rule 79 (exr -> ex rel exr resrel .)


state 201

    (82) ex -> term resterm PLUS pushop . ex
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    term                           shift and go to state 99
    ex                             shift and go to state 230
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 202

    (83) ex -> term resterm MINUS pushop . ex
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    term                           shift and go to state 99
    ex                             shift and go to state 231
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 203

    (85) term -> fact resfact TIMES pushop . term
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    fact                           shift and go to state 102
    term                           shift and go to state 232
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 204

    (86) term -> fact resfact DIVIDE pushop . term
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    fact                           shift and go to state 102
    term                           shift and go to state 233
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 205

    (106) asigvector -> ID pushid LBRACE ex . RBRACE

    RBRACE          shift and go to state 234


state 206

    (68) escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .

    ID              reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    IF              reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    PRINT           reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    WHILE           reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    READ            reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    RKEY            reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)
    RETURN          reduce using rule 68 (escrit -> PRINT pushop LPAREN escriti RPAREN SEMICOLON .)


state 207

    (70) escriti -> expres escrit2 COMA . escriti
    (69) escriti -> . expres escrit1
    (70) escriti -> . expres escrit2 COMA escriti
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 149
    escriti                        shift and go to state 235
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 208

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN while2 . LKEY bloq RKEY while3

    LKEY            shift and go to state 236


state 209

    (74) leer -> READ pushop LPAREN ID pushid RPAREN . readid SEMICOLON
    (75) readid -> .

    SEMICOLON       reduce using rule 75 (readid -> .)

    readid                         shift and go to state 237

state 210

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar . bloq return1 RKEY
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 238
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 211

    (25) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq . return1 RKEY
    (48) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (49) return1 -> . empty
    (116) empty -> .

    RETURN          shift and go to state 215
    RKEY            reduce using rule 116 (empty -> .)

    return1                        shift and go to state 239
    empty                          shift and go to state 216

state 212

    (28) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 28 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 28 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 213

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq . return1 RKEY
    (48) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (49) return1 -> . empty
    (116) empty -> .

    RETURN          shift and go to state 215
    RKEY            reduce using rule 116 (empty -> .)

    return1                        shift and go to state 240
    empty                          shift and go to state 216

state 214

    (33) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 241


state 215

    (48) return1 -> RETURN . pushop expres resreturn SEMICOLON
    (119) pushop -> .

    LPAREN          reduce using rule 119 (pushop -> .)
    PLUS            reduce using rule 119 (pushop -> .)
    MINUS           reduce using rule 119 (pushop -> .)
    ID              reduce using rule 119 (pushop -> .)
    CTE_I           reduce using rule 119 (pushop -> .)
    CTE_F           reduce using rule 119 (pushop -> .)
    CTE_S           reduce using rule 119 (pushop -> .)
    TRUE            reduce using rule 119 (pushop -> .)
    FALSE           reduce using rule 119 (pushop -> .)

    pushop                         shift and go to state 242

state 216

    (49) return1 -> empty .

    RKEY            reduce using rule 49 (return1 -> empty .)


state 217

    (42) funci -> tipo ID sumparam COMA . funci
    (41) funci -> . tipo ID sumparam
    (42) funci -> . tipo ID sumparam COMA funci
    (18) tipo -> . INT
    (19) tipo -> . FLOAT
    (20) tipo -> . STRING
    (21) tipo -> . BOOL

    INT             shift and go to state 21
    FLOAT           shift and go to state 22
    STRING          shift and go to state 23
    BOOL            shift and go to state 24

    tipo                           shift and go to state 119
    funci                          shift and go to state 243

state 218

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar . bloq RKEY
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 244
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 219

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq . RKEY

    RKEY            shift and go to state 245


state 220

    (29) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .

    FUNCTION        reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)
    MAIN            reduce using rule 29 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar RKEY .)


state 221

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 246


state 222

    (32) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 32 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY bloq RKEY .)


state 223

    (107) fcall -> ID existfunc LPAREN . startera fcall1 RPAREN
    (108) fcall -> ID existfunc LPAREN . startera RPAREN
    (112) startera -> .

    RPAREN          reduce using rule 112 (startera -> .)
    LPAREN          reduce using rule 112 (startera -> .)
    PLUS            reduce using rule 112 (startera -> .)
    MINUS           reduce using rule 112 (startera -> .)
    ID              reduce using rule 112 (startera -> .)
    CTE_I           reduce using rule 112 (startera -> .)
    CTE_F           reduce using rule 112 (startera -> .)
    CTE_S           reduce using rule 112 (startera -> .)
    TRUE            reduce using rule 112 (startera -> .)
    FALSE           reduce using rule 112 (startera -> .)

    startera                       shift and go to state 247

state 224

    (64) asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .

    ID              reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    IF              reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    PRINT           reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    WHILE           reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    READ            reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RKEY            reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)
    RETURN          reduce using rule 64 (asign -> ID pushid EQUAL pushop expres resolverasignacion SEMICOLON .)


state 225

    (65) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop . expres resasignvec SEMICOLON
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    exr                            shift and go to state 97
    expres                         shift and go to state 248
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 226

    (109) fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .

    ID              reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    IF              reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    READ            reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RKEY            reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)
    RETURN          reduce using rule 109 (fcallvoid -> ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON .)


state 227

    (114) fcall1 -> expres generateparam COMA . fcall1
    (113) fcall1 -> . expres generateparam
    (114) fcall1 -> . expres generateparam COMA fcall1
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 165
    fcall1                         shift and go to state 249
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 228

    (87) fact -> LPAREN pushop expres RPAREN popop .

    TIMES           reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    DIVIDE          reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    PLUS            reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    MINUS           reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWERTHAN       reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    MORETHAN        reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    LOWEREQ         reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    MOREEQ          reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    SAME            reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    DIFFERENT       reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    OR              reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    AND             reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    RPAREN          reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    RBRACE          reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    COMA            reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)
    SEMICOLON       reduce using rule 87 (fact -> LPAREN pushop expres RPAREN popop .)


state 229

    (66) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY finif
    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq . RKEY ELSE LKEY reselse bloq RKEY finif

    RKEY            shift and go to state 250


state 230

    (82) ex -> term resterm PLUS pushop ex .

    LOWERTHAN       reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    MORETHAN        reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    LOWEREQ         reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    MOREEQ          reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    SAME            reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    DIFFERENT       reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    OR              reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    AND             reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    RPAREN          reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    RBRACE          reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    COMA            reduce using rule 82 (ex -> term resterm PLUS pushop ex .)
    SEMICOLON       reduce using rule 82 (ex -> term resterm PLUS pushop ex .)


state 231

    (83) ex -> term resterm MINUS pushop ex .

    LOWERTHAN       reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    MORETHAN        reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    LOWEREQ         reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    MOREEQ          reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    SAME            reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    DIFFERENT       reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    OR              reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    AND             reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    RPAREN          reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    RBRACE          reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    COMA            reduce using rule 83 (ex -> term resterm MINUS pushop ex .)
    SEMICOLON       reduce using rule 83 (ex -> term resterm MINUS pushop ex .)


state 232

    (85) term -> fact resfact TIMES pushop term .

    PLUS            reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    MINUS           reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    LOWERTHAN       reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    MORETHAN        reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    LOWEREQ         reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    MOREEQ          reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    SAME            reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    DIFFERENT       reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    OR              reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    AND             reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    RPAREN          reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    RBRACE          reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    COMA            reduce using rule 85 (term -> fact resfact TIMES pushop term .)
    SEMICOLON       reduce using rule 85 (term -> fact resfact TIMES pushop term .)


state 233

    (86) term -> fact resfact DIVIDE pushop term .

    PLUS            reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    MINUS           reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    LOWERTHAN       reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    MORETHAN        reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    LOWEREQ         reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    MOREEQ          reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    SAME            reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    DIFFERENT       reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    OR              reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    AND             reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    RPAREN          reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    RBRACE          reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    COMA            reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)
    SEMICOLON       reduce using rule 86 (term -> fact resfact DIVIDE pushop term .)


state 234

    (106) asigvector -> ID pushid LBRACE ex RBRACE .

    TIMES           reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIVIDE          reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    PLUS            reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MINUS           reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWERTHAN       reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MORETHAN        reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    LOWEREQ         reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    MOREEQ          reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SAME            reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    DIFFERENT       reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    OR              reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    AND             reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RPAREN          reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    RBRACE          reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    COMA            reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)
    SEMICOLON       reduce using rule 106 (asigvector -> ID pushid LBRACE ex RBRACE .)


state 235

    (70) escriti -> expres escrit2 COMA escriti .

    RPAREN          reduce using rule 70 (escriti -> expres escrit2 COMA escriti .)


state 236

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY . bloq RKEY while3
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 251
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 237

    (74) leer -> READ pushop LPAREN ID pushid RPAREN readid . SEMICOLON

    SEMICOLON       shift and go to state 252


state 238

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq . return1 RKEY
    (48) return1 -> . RETURN pushop expres resreturn SEMICOLON
    (49) return1 -> . empty
    (116) empty -> .

    RETURN          shift and go to state 215
    RKEY            reduce using rule 116 (empty -> .)

    return1                        shift and go to state 253
    empty                          shift and go to state 216

state 239

    (25) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 . RKEY

    RKEY            shift and go to state 254


state 240

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 255


state 241

    (33) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 33 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 33 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY bloq return1 RKEY .)


state 242

    (48) return1 -> RETURN pushop . expres resreturn SEMICOLON
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    expres                         shift and go to state 256
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 243

    (42) funci -> tipo ID sumparam COMA funci .

    RPAREN          reduce using rule 42 (funci -> tipo ID sumparam COMA funci .)


state 244

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq . RKEY

    RKEY            shift and go to state 257


state 245

    (27) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .

    FUNCTION        reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)
    MAIN            reduce using rule 27 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY bloq RKEY .)


state 246

    (31) function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 31 (function -> FUNCTION pushvoid ID addInTable LPAREN RPAREN LKEY localvar bloq RKEY .)


state 247

    (107) fcall -> ID existfunc LPAREN startera . fcall1 RPAREN
    (108) fcall -> ID existfunc LPAREN startera . RPAREN
    (113) fcall1 -> . expres generateparam
    (114) fcall1 -> . expres generateparam COMA fcall1
    (76) expres -> . exr
    (77) expres -> . exr log expres reslog
    (78) exr -> . ex
    (79) exr -> . ex rel exr resrel
    (81) ex -> . term resterm
    (82) ex -> . term resterm PLUS pushop ex
    (83) ex -> . term resterm MINUS pushop ex
    (84) term -> . fact resfact
    (85) term -> . fact resfact TIMES pushop term
    (86) term -> . fact resfact DIVIDE pushop term
    (87) fact -> . LPAREN pushop expres RPAREN popop
    (88) fact -> . var_cte
    (89) fact -> . PLUS pushop var_cte
    (90) fact -> . MINUS pushop var_cte
    (99) var_cte -> . ID pushid
    (100) var_cte -> . CTE_I pushcte
    (101) var_cte -> . CTE_F pushcte
    (102) var_cte -> . CTE_S pushcte
    (103) var_cte -> . TRUE pushcte
    (104) var_cte -> . FALSE pushcte
    (105) var_cte -> . asigvector
    (106) asigvector -> . ID pushid LBRACE ex RBRACE

    RPAREN          shift and go to state 259
    LPAREN          shift and go to state 95
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    ID              shift and go to state 104
    CTE_I           shift and go to state 105
    CTE_F           shift and go to state 106
    CTE_S           shift and go to state 107
    TRUE            shift and go to state 108
    FALSE           shift and go to state 109

    fcall1                         shift and go to state 258
    expres                         shift and go to state 165
    exr                            shift and go to state 97
    ex                             shift and go to state 98
    term                           shift and go to state 99
    fact                           shift and go to state 102
    var_cte                        shift and go to state 103
    asigvector                     shift and go to state 110

state 248

    (65) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres . resasignvec SEMICOLON
    (122) resasignvec -> .

    SEMICOLON       reduce using rule 122 (resasignvec -> .)

    resasignvec                    shift and go to state 260

state 249

    (114) fcall1 -> expres generateparam COMA fcall1 .

    RPAREN          reduce using rule 114 (fcall1 -> expres generateparam COMA fcall1 .)


state 250

    (66) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . finif
    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY . ELSE LKEY reselse bloq RKEY finif
    (128) finif -> .

    ELSE            shift and go to state 262
    ID              reduce using rule 128 (finif -> .)
    IF              reduce using rule 128 (finif -> .)
    PRINT           reduce using rule 128 (finif -> .)
    WHILE           reduce using rule 128 (finif -> .)
    READ            reduce using rule 128 (finif -> .)
    RKEY            reduce using rule 128 (finif -> .)
    RETURN          reduce using rule 128 (finif -> .)

    finif                          shift and go to state 261

state 251

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq . RKEY while3

    RKEY            shift and go to state 263


state 252

    (74) leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .

    ID              reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    IF              reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    PRINT           reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    WHILE           reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    READ            reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    RKEY            reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)
    RETURN          reduce using rule 74 (leer -> READ pushop LPAREN ID pushid RPAREN readid SEMICOLON .)


state 253

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 . RKEY

    RKEY            shift and go to state 264


state 254

    (25) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .

    FUNCTION        reduce using rule 25 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)
    MAIN            reduce using rule 25 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY bloq return1 RKEY .)


state 255

    (30) function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 30 (function -> FUNCTION functype ID addInTable LPAREN RPAREN LKEY localvar bloq return1 RKEY .)


state 256

    (48) return1 -> RETURN pushop expres . resreturn SEMICOLON
    (50) resreturn -> .

    SEMICOLON       reduce using rule 50 (resreturn -> .)

    resreturn                      shift and go to state 265

state 257

    (26) function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .

    FUNCTION        reduce using rule 26 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)
    MAIN            reduce using rule 26 (function -> FUNCTION pushvoid ID addInTable LPAREN funci RPAREN LKEY localvar bloq RKEY .)


state 258

    (107) fcall -> ID existfunc LPAREN startera fcall1 . RPAREN

    RPAREN          shift and go to state 266


state 259

    (108) fcall -> ID existfunc LPAREN startera RPAREN .

    SEMICOLON       reduce using rule 108 (fcall -> ID existfunc LPAREN startera RPAREN .)


state 260

    (65) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec . SEMICOLON

    SEMICOLON       shift and go to state 267


state 261

    (66) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .

    ID              reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    IF              reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    PRINT           reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    WHILE           reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    READ            reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RKEY            reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)
    RETURN          reduce using rule 66 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY finif .)


state 262

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE . LKEY reselse bloq RKEY finif

    LKEY            shift and go to state 268


state 263

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY . while3
    (131) while3 -> .

    ID              reduce using rule 131 (while3 -> .)
    IF              reduce using rule 131 (while3 -> .)
    PRINT           reduce using rule 131 (while3 -> .)
    WHILE           reduce using rule 131 (while3 -> .)
    READ            reduce using rule 131 (while3 -> .)
    RKEY            reduce using rule 131 (while3 -> .)
    RETURN          reduce using rule 131 (while3 -> .)

    while3                         shift and go to state 269

state 264

    (24) function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .

    FUNCTION        reduce using rule 24 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)
    MAIN            reduce using rule 24 (function -> FUNCTION functype ID addInTable LPAREN funci RPAREN LKEY localvar bloq return1 RKEY .)


state 265

    (48) return1 -> RETURN pushop expres resreturn . SEMICOLON

    SEMICOLON       shift and go to state 270


state 266

    (107) fcall -> ID existfunc LPAREN startera fcall1 RPAREN .

    SEMICOLON       reduce using rule 107 (fcall -> ID existfunc LPAREN startera fcall1 RPAREN .)


state 267

    (65) asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .

    ID              reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    IF              reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    PRINT           reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    WHILE           reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    READ            reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    RKEY            reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)
    RETURN          reduce using rule 65 (asign -> ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON .)


state 268

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY . reselse bloq RKEY finif
    (127) reselse -> .

    ID              reduce using rule 127 (reselse -> .)
    IF              reduce using rule 127 (reselse -> .)
    PRINT           reduce using rule 127 (reselse -> .)
    WHILE           reduce using rule 127 (reselse -> .)
    READ            reduce using rule 127 (reselse -> .)

    reselse                        shift and go to state 271

state 269

    (73) ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .

    ID              reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    IF              reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    PRINT           reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    WHILE           reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    READ            reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RKEY            reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)
    RETURN          reduce using rule 73 (ciclo -> WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3 .)


state 270

    (48) return1 -> RETURN pushop expres resreturn SEMICOLON .

    RKEY            reduce using rule 48 (return1 -> RETURN pushop expres resreturn SEMICOLON .)


state 271

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse . bloq RKEY finif
    (55) bloq -> . estat
    (56) bloq -> . estat bloq
    (57) estat -> . asign
    (58) estat -> . cond
    (59) estat -> . escrit
    (60) estat -> . ciclo
    (61) estat -> . leer
    (62) estat -> . fcallvoid
    (63) asign -> . ID pushid EQUAL pushop fcall SEMICOLON
    (64) asign -> . ID pushid EQUAL pushop expres resolverasignacion SEMICOLON
    (65) asign -> . ID pushid LBRACE exr RBRACE EQUAL pushop expres resasignvec SEMICOLON
    (66) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY finif
    (67) cond -> . IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif
    (68) escrit -> . PRINT pushop LPAREN escriti RPAREN SEMICOLON
    (73) ciclo -> . WHILE while1 LPAREN expres RPAREN while2 LKEY bloq RKEY while3
    (74) leer -> . READ pushop LPAREN ID pushid RPAREN readid SEMICOLON
    (109) fcallvoid -> . ID existfunc LPAREN startera fcall1 RPAREN SEMICOLON
    (110) fcallvoid -> . ID existfunc LPAREN startera RPAREN SEMICOLON

    ID              shift and go to state 56
    IF              shift and go to state 63
    PRINT           shift and go to state 64
    WHILE           shift and go to state 65
    READ            shift and go to state 66

    bloq                           shift and go to state 272
    estat                          shift and go to state 55
    asign                          shift and go to state 57
    cond                           shift and go to state 58
    escrit                         shift and go to state 59
    ciclo                          shift and go to state 60
    leer                           shift and go to state 61
    fcallvoid                      shift and go to state 62

state 272

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq . RKEY finif

    RKEY            shift and go to state 273


state 273

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY . finif
    (128) finif -> .

    ID              reduce using rule 128 (finif -> .)
    IF              reduce using rule 128 (finif -> .)
    PRINT           reduce using rule 128 (finif -> .)
    WHILE           reduce using rule 128 (finif -> .)
    READ            reduce using rule 128 (finif -> .)
    RKEY            reduce using rule 128 (finif -> .)
    RETURN          reduce using rule 128 (finif -> .)

    finif                          shift and go to state 274

state 274

    (67) cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .

    ID              reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    IF              reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    PRINT           reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    WHILE           reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    READ            reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RKEY            reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)
    RETURN          reduce using rule 67 (cond -> IF LPAREN expres RPAREN LKEY resif bloq RKEY ELSE LKEY reselse bloq RKEY finif .)

